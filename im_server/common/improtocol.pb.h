// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: improtocol.proto

#ifndef PROTOBUF_improtocol_2eproto__INCLUDED
#define PROTOBUF_improtocol_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include "base.pb.h"
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_improtocol_2eproto();
void protobuf_AssignDesc_improtocol_2eproto();
void protobuf_ShutdownFile_improtocol_2eproto();

class XT_HEAD_PB;
class DataPacket;
class MsgInfo;
class MsgList;
class UserOfflineIND;
class Buf_ServerSend;
class Buf_ClientSend;
class BaseReq;
class MsgRemindAck;
class CsUpdateOperReq;
class OrderGoodsInfo;
class NewOrder;
class PayOrder;
class GoodsComment;
class ReturnGoodsInfo;
class ReturnOrder;
class MsgPushInd;
class csTeamInfoReq;
class csTeamInfo;
class csTeamInfoAck;
class csTeamQueueInfo;

enum XT_HEAD_PB_EN_FLAG {
  XT_HEAD_PB_EN_FLAG_FLAG_SRVACTION = 240,
  XT_HEAD_PB_EN_FLAG_FLAG_SRVACK = 241,
  XT_HEAD_PB_EN_FLAG_FLAG_CNTREQUEST = 242,
  XT_HEAD_PB_EN_FLAG_FLAG_CNTACK = 243,
  XT_HEAD_PB_EN_FLAG_FLAG_SELLCNTREQ = 253
};
bool XT_HEAD_PB_EN_FLAG_IsValid(int value);
const XT_HEAD_PB_EN_FLAG XT_HEAD_PB_EN_FLAG_EN_FLAG_MIN = XT_HEAD_PB_EN_FLAG_FLAG_SRVACTION;
const XT_HEAD_PB_EN_FLAG XT_HEAD_PB_EN_FLAG_EN_FLAG_MAX = XT_HEAD_PB_EN_FLAG_FLAG_SELLCNTREQ;
const int XT_HEAD_PB_EN_FLAG_EN_FLAG_ARRAYSIZE = XT_HEAD_PB_EN_FLAG_EN_FLAG_MAX + 1;

enum XT_HEAD_PB_EN_FROM {
  XT_HEAD_PB_EN_FROM_FROM_SERVER = 256,
  XT_HEAD_PB_EN_FROM_FROM_CLIENT = 2000,
  XT_HEAD_PB_EN_FROM_FROM_TRANSFER = 512
};
bool XT_HEAD_PB_EN_FROM_IsValid(int value);
const XT_HEAD_PB_EN_FROM XT_HEAD_PB_EN_FROM_EN_FROM_MIN = XT_HEAD_PB_EN_FROM_FROM_SERVER;
const XT_HEAD_PB_EN_FROM XT_HEAD_PB_EN_FROM_EN_FROM_MAX = XT_HEAD_PB_EN_FROM_FROM_CLIENT;
const int XT_HEAD_PB_EN_FROM_EN_FROM_ARRAYSIZE = XT_HEAD_PB_EN_FROM_EN_FROM_MAX + 1;

enum XT_HEAD_PB_EN_SID {
  XT_HEAD_PB_EN_SID_SID_SERVER = 0
};
bool XT_HEAD_PB_EN_SID_IsValid(int value);
const XT_HEAD_PB_EN_SID XT_HEAD_PB_EN_SID_EN_SID_MIN = XT_HEAD_PB_EN_SID_SID_SERVER;
const XT_HEAD_PB_EN_SID XT_HEAD_PB_EN_SID_EN_SID_MAX = XT_HEAD_PB_EN_SID_SID_SERVER;
const int XT_HEAD_PB_EN_SID_EN_SID_ARRAYSIZE = XT_HEAD_PB_EN_SID_EN_SID_MAX + 1;

enum XT_HEAD_PB_EN_DSET_TYPE {
  XT_HEAD_PB_EN_DSET_TYPE_DEST_TYPE_SERVER = 0,
  XT_HEAD_PB_EN_DSET_TYPE_DEST_TYPE_USER = 1,
  XT_HEAD_PB_EN_DSET_TYPE_DEST_TYPE_FAMILY = 2,
  XT_HEAD_PB_EN_DSET_TYPE_DEST_TYPE_TRANSMIT = 3
};
bool XT_HEAD_PB_EN_DSET_TYPE_IsValid(int value);
const XT_HEAD_PB_EN_DSET_TYPE XT_HEAD_PB_EN_DSET_TYPE_EN_DSET_TYPE_MIN = XT_HEAD_PB_EN_DSET_TYPE_DEST_TYPE_SERVER;
const XT_HEAD_PB_EN_DSET_TYPE XT_HEAD_PB_EN_DSET_TYPE_EN_DSET_TYPE_MAX = XT_HEAD_PB_EN_DSET_TYPE_DEST_TYPE_TRANSMIT;
const int XT_HEAD_PB_EN_DSET_TYPE_EN_DSET_TYPE_ARRAYSIZE = XT_HEAD_PB_EN_DSET_TYPE_EN_DSET_TYPE_MAX + 1;

enum EN_BUFLOCATION {
  LOCATION_MEM = 0,
  LOCATION_DB = 1
};
bool EN_BUFLOCATION_IsValid(int value);
const EN_BUFLOCATION EN_BUFLOCATION_MIN = LOCATION_MEM;
const EN_BUFLOCATION EN_BUFLOCATION_MAX = LOCATION_DB;
const int EN_BUFLOCATION_ARRAYSIZE = EN_BUFLOCATION_MAX + 1;

enum REMIND_TYPE {
  RT_RECEIVE_AND_POPMSG = 1,
  RT_RECEIVE_NOT_POPMSG = 2,
  RT_OFF = 3
};
bool REMIND_TYPE_IsValid(int value);
const REMIND_TYPE REMIND_TYPE_MIN = RT_RECEIVE_AND_POPMSG;
const REMIND_TYPE REMIND_TYPE_MAX = RT_OFF;
const int REMIND_TYPE_ARRAYSIZE = REMIND_TYPE_MAX + 1;

enum CS_UPDATE_OPER {
  UO_ADD_CUST = 1,
  UO_DEL_CUST = 2,
  UO_SET_MASTER = 3,
  UO_SET_CHATTING_CUST = 4,
  UO_ADD_RECPTION = 5,
  UO_DEL_RECPTION = 6
};
bool CS_UPDATE_OPER_IsValid(int value);
const CS_UPDATE_OPER CS_UPDATE_OPER_MIN = UO_ADD_CUST;
const CS_UPDATE_OPER CS_UPDATE_OPER_MAX = UO_DEL_RECPTION;
const int CS_UPDATE_OPER_ARRAYSIZE = CS_UPDATE_OPER_MAX + 1;

// ===================================================================

class XT_HEAD_PB : public ::google::protobuf::MessageLite {
 public:
  XT_HEAD_PB();
  virtual ~XT_HEAD_PB();

  XT_HEAD_PB(const XT_HEAD_PB& from);

  inline XT_HEAD_PB& operator=(const XT_HEAD_PB& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const XT_HEAD_PB& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const XT_HEAD_PB* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(XT_HEAD_PB* other);

  // implements Message ----------------------------------------------

  XT_HEAD_PB* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const XT_HEAD_PB& from);
  void MergeFrom(const XT_HEAD_PB& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef XT_HEAD_PB_EN_FLAG EN_FLAG;
  static const EN_FLAG FLAG_SRVACTION = XT_HEAD_PB_EN_FLAG_FLAG_SRVACTION;
  static const EN_FLAG FLAG_SRVACK = XT_HEAD_PB_EN_FLAG_FLAG_SRVACK;
  static const EN_FLAG FLAG_CNTREQUEST = XT_HEAD_PB_EN_FLAG_FLAG_CNTREQUEST;
  static const EN_FLAG FLAG_CNTACK = XT_HEAD_PB_EN_FLAG_FLAG_CNTACK;
  static const EN_FLAG FLAG_SELLCNTREQ = XT_HEAD_PB_EN_FLAG_FLAG_SELLCNTREQ;
  static inline bool EN_FLAG_IsValid(int value) {
    return XT_HEAD_PB_EN_FLAG_IsValid(value);
  }
  static const EN_FLAG EN_FLAG_MIN =
    XT_HEAD_PB_EN_FLAG_EN_FLAG_MIN;
  static const EN_FLAG EN_FLAG_MAX =
    XT_HEAD_PB_EN_FLAG_EN_FLAG_MAX;
  static const int EN_FLAG_ARRAYSIZE =
    XT_HEAD_PB_EN_FLAG_EN_FLAG_ARRAYSIZE;

  typedef XT_HEAD_PB_EN_FROM EN_FROM;
  static const EN_FROM FROM_SERVER = XT_HEAD_PB_EN_FROM_FROM_SERVER;
  static const EN_FROM FROM_CLIENT = XT_HEAD_PB_EN_FROM_FROM_CLIENT;
  static const EN_FROM FROM_TRANSFER = XT_HEAD_PB_EN_FROM_FROM_TRANSFER;
  static inline bool EN_FROM_IsValid(int value) {
    return XT_HEAD_PB_EN_FROM_IsValid(value);
  }
  static const EN_FROM EN_FROM_MIN =
    XT_HEAD_PB_EN_FROM_EN_FROM_MIN;
  static const EN_FROM EN_FROM_MAX =
    XT_HEAD_PB_EN_FROM_EN_FROM_MAX;
  static const int EN_FROM_ARRAYSIZE =
    XT_HEAD_PB_EN_FROM_EN_FROM_ARRAYSIZE;

  typedef XT_HEAD_PB_EN_SID EN_SID;
  static const EN_SID SID_SERVER = XT_HEAD_PB_EN_SID_SID_SERVER;
  static inline bool EN_SID_IsValid(int value) {
    return XT_HEAD_PB_EN_SID_IsValid(value);
  }
  static const EN_SID EN_SID_MIN =
    XT_HEAD_PB_EN_SID_EN_SID_MIN;
  static const EN_SID EN_SID_MAX =
    XT_HEAD_PB_EN_SID_EN_SID_MAX;
  static const int EN_SID_ARRAYSIZE =
    XT_HEAD_PB_EN_SID_EN_SID_ARRAYSIZE;

  typedef XT_HEAD_PB_EN_DSET_TYPE EN_DSET_TYPE;
  static const EN_DSET_TYPE DEST_TYPE_SERVER = XT_HEAD_PB_EN_DSET_TYPE_DEST_TYPE_SERVER;
  static const EN_DSET_TYPE DEST_TYPE_USER = XT_HEAD_PB_EN_DSET_TYPE_DEST_TYPE_USER;
  static const EN_DSET_TYPE DEST_TYPE_FAMILY = XT_HEAD_PB_EN_DSET_TYPE_DEST_TYPE_FAMILY;
  static const EN_DSET_TYPE DEST_TYPE_TRANSMIT = XT_HEAD_PB_EN_DSET_TYPE_DEST_TYPE_TRANSMIT;
  static inline bool EN_DSET_TYPE_IsValid(int value) {
    return XT_HEAD_PB_EN_DSET_TYPE_IsValid(value);
  }
  static const EN_DSET_TYPE EN_DSET_TYPE_MIN =
    XT_HEAD_PB_EN_DSET_TYPE_EN_DSET_TYPE_MIN;
  static const EN_DSET_TYPE EN_DSET_TYPE_MAX =
    XT_HEAD_PB_EN_DSET_TYPE_EN_DSET_TYPE_MAX;
  static const int EN_DSET_TYPE_ARRAYSIZE =
    XT_HEAD_PB_EN_DSET_TYPE_EN_DSET_TYPE_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional int32 flag = 1;
  inline bool has_flag() const;
  inline void clear_flag();
  static const int kFlagFieldNumber = 1;
  inline ::google::protobuf::int32 flag() const;
  inline void set_flag(::google::protobuf::int32 value);

  // optional int32 from = 2;
  inline bool has_from() const;
  inline void clear_from();
  static const int kFromFieldNumber = 2;
  inline ::google::protobuf::int32 from() const;
  inline void set_from(::google::protobuf::int32 value);

  // optional int32 cmd = 3;
  inline bool has_cmd() const;
  inline void clear_cmd();
  static const int kCmdFieldNumber = 3;
  inline ::google::protobuf::int32 cmd() const;
  inline void set_cmd(::google::protobuf::int32 value);

  // optional int32 seq = 4;
  inline bool has_seq() const;
  inline void clear_seq();
  static const int kSeqFieldNumber = 4;
  inline ::google::protobuf::int32 seq() const;
  inline void set_seq(::google::protobuf::int32 value);

  // optional int32 sid = 5;
  inline bool has_sid() const;
  inline void clear_sid();
  static const int kSidFieldNumber = 5;
  inline ::google::protobuf::int32 sid() const;
  inline void set_sid(::google::protobuf::int32 value);

  // optional int32 dtype = 6;
  inline bool has_dtype() const;
  inline void clear_dtype();
  static const int kDtypeFieldNumber = 6;
  inline ::google::protobuf::int32 dtype() const;
  inline void set_dtype(::google::protobuf::int32 value);

  // optional int32 did = 7;
  inline bool has_did() const;
  inline void clear_did();
  static const int kDidFieldNumber = 7;
  inline ::google::protobuf::int32 did() const;
  inline void set_did(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:XT_HEAD_PB)
 private:
  inline void set_has_flag();
  inline void clear_has_flag();
  inline void set_has_from();
  inline void clear_has_from();
  inline void set_has_cmd();
  inline void clear_has_cmd();
  inline void set_has_seq();
  inline void clear_has_seq();
  inline void set_has_sid();
  inline void clear_has_sid();
  inline void set_has_dtype();
  inline void clear_has_dtype();
  inline void set_has_did();
  inline void clear_has_did();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 flag_;
  ::google::protobuf::int32 from_;
  ::google::protobuf::int32 cmd_;
  ::google::protobuf::int32 seq_;
  ::google::protobuf::int32 sid_;
  ::google::protobuf::int32 dtype_;
  ::google::protobuf::int32 did_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_improtocol_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_improtocol_2eproto();
  #endif
  friend void protobuf_AssignDesc_improtocol_2eproto();
  friend void protobuf_ShutdownFile_improtocol_2eproto();

  void InitAsDefaultInstance();
  static XT_HEAD_PB* default_instance_;
};
// -------------------------------------------------------------------

class DataPacket : public ::google::protobuf::MessageLite {
 public:
  DataPacket();
  virtual ~DataPacket();

  DataPacket(const DataPacket& from);

  inline DataPacket& operator=(const DataPacket& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const DataPacket& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const DataPacket* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(DataPacket* other);

  // implements Message ----------------------------------------------

  DataPacket* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DataPacket& from);
  void MergeFrom(const DataPacket& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .XT_HEAD_PB head = 1;
  inline bool has_head() const;
  inline void clear_head();
  static const int kHeadFieldNumber = 1;
  inline const ::XT_HEAD_PB& head() const;
  inline ::XT_HEAD_PB* mutable_head();
  inline ::XT_HEAD_PB* release_head();
  inline void set_allocated_head(::XT_HEAD_PB* head);

  // required bytes data = 2;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 2;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:DataPacket)
 private:
  inline void set_has_head();
  inline void clear_has_head();
  inline void set_has_data();
  inline void clear_has_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::XT_HEAD_PB* head_;
  ::std::string* data_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_improtocol_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_improtocol_2eproto();
  #endif
  friend void protobuf_AssignDesc_improtocol_2eproto();
  friend void protobuf_ShutdownFile_improtocol_2eproto();

  void InitAsDefaultInstance();
  static DataPacket* default_instance_;
};
// -------------------------------------------------------------------

class MsgInfo : public ::google::protobuf::MessageLite {
 public:
  MsgInfo();
  virtual ~MsgInfo();

  MsgInfo(const MsgInfo& from);

  inline MsgInfo& operator=(const MsgInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const MsgInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const MsgInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(MsgInfo* other);

  // implements Message ----------------------------------------------

  MsgInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MsgInfo& from);
  void MergeFrom(const MsgInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 msgid = 1;
  inline bool has_msgid() const;
  inline void clear_msgid();
  static const int kMsgidFieldNumber = 1;
  inline ::google::protobuf::uint32 msgid() const;
  inline void set_msgid(::google::protobuf::uint32 value);

  // optional string uuid = 2;
  inline bool has_uuid() const;
  inline void clear_uuid();
  static const int kUuidFieldNumber = 2;
  inline const ::std::string& uuid() const;
  inline void set_uuid(const ::std::string& value);
  inline void set_uuid(const char* value);
  inline void set_uuid(const char* value, size_t size);
  inline ::std::string* mutable_uuid();
  inline ::std::string* release_uuid();
  inline void set_allocated_uuid(::std::string* uuid);

  // optional uint32 fromid = 3;
  inline bool has_fromid() const;
  inline void clear_fromid();
  static const int kFromidFieldNumber = 3;
  inline ::google::protobuf::uint32 fromid() const;
  inline void set_fromid(::google::protobuf::uint32 value);

  // optional uint32 toid = 4;
  inline bool has_toid() const;
  inline void clear_toid();
  static const int kToidFieldNumber = 4;
  inline ::google::protobuf::uint32 toid() const;
  inline void set_toid(::google::protobuf::uint32 value);

  // optional uint32 send_time = 5;
  inline bool has_send_time() const;
  inline void clear_send_time();
  static const int kSendTimeFieldNumber = 5;
  inline ::google::protobuf::uint32 send_time() const;
  inline void set_send_time(::google::protobuf::uint32 value);

  // optional string data = 6;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 6;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const char* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // optional string fromnickname = 7;
  inline bool has_fromnickname() const;
  inline void clear_fromnickname();
  static const int kFromnicknameFieldNumber = 7;
  inline const ::std::string& fromnickname() const;
  inline void set_fromnickname(const ::std::string& value);
  inline void set_fromnickname(const char* value);
  inline void set_fromnickname(const char* value, size_t size);
  inline ::std::string* mutable_fromnickname();
  inline ::std::string* release_fromnickname();
  inline void set_allocated_fromnickname(::std::string* fromnickname);

  // optional uint32 fontSize = 8;
  inline bool has_fontsize() const;
  inline void clear_fontsize();
  static const int kFontSizeFieldNumber = 8;
  inline ::google::protobuf::uint32 fontsize() const;
  inline void set_fontsize(::google::protobuf::uint32 value);

  // optional uint32 fontColor = 9;
  inline bool has_fontcolor() const;
  inline void clear_fontcolor();
  static const int kFontColorFieldNumber = 9;
  inline ::google::protobuf::uint32 fontcolor() const;
  inline void set_fontcolor(::google::protobuf::uint32 value);

  // optional uint32 fontStyle = 10;
  inline bool has_fontstyle() const;
  inline void clear_fontstyle();
  static const int kFontStyleFieldNumber = 10;
  inline ::google::protobuf::uint32 fontstyle() const;
  inline void set_fontstyle(::google::protobuf::uint32 value);

  // optional string fontName = 11;
  inline bool has_fontname() const;
  inline void clear_fontname();
  static const int kFontNameFieldNumber = 11;
  inline const ::std::string& fontname() const;
  inline void set_fontname(const ::std::string& value);
  inline void set_fontname(const char* value);
  inline void set_fontname(const char* value, size_t size);
  inline ::std::string* mutable_fontname();
  inline ::std::string* release_fontname();
  inline void set_allocated_fontname(::std::string* fontname);

  // @@protoc_insertion_point(class_scope:MsgInfo)
 private:
  inline void set_has_msgid();
  inline void clear_has_msgid();
  inline void set_has_uuid();
  inline void clear_has_uuid();
  inline void set_has_fromid();
  inline void clear_has_fromid();
  inline void set_has_toid();
  inline void clear_has_toid();
  inline void set_has_send_time();
  inline void clear_has_send_time();
  inline void set_has_data();
  inline void clear_has_data();
  inline void set_has_fromnickname();
  inline void clear_has_fromnickname();
  inline void set_has_fontsize();
  inline void clear_has_fontsize();
  inline void set_has_fontcolor();
  inline void clear_has_fontcolor();
  inline void set_has_fontstyle();
  inline void clear_has_fontstyle();
  inline void set_has_fontname();
  inline void clear_has_fontname();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* uuid_;
  ::google::protobuf::uint32 msgid_;
  ::google::protobuf::uint32 fromid_;
  ::google::protobuf::uint32 toid_;
  ::google::protobuf::uint32 send_time_;
  ::std::string* data_;
  ::std::string* fromnickname_;
  ::google::protobuf::uint32 fontsize_;
  ::google::protobuf::uint32 fontcolor_;
  ::std::string* fontname_;
  ::google::protobuf::uint32 fontstyle_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_improtocol_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_improtocol_2eproto();
  #endif
  friend void protobuf_AssignDesc_improtocol_2eproto();
  friend void protobuf_ShutdownFile_improtocol_2eproto();

  void InitAsDefaultInstance();
  static MsgInfo* default_instance_;
};
// -------------------------------------------------------------------

class MsgList : public ::google::protobuf::MessageLite {
 public:
  MsgList();
  virtual ~MsgList();

  MsgList(const MsgList& from);

  inline MsgList& operator=(const MsgList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const MsgList& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const MsgList* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(MsgList* other);

  // implements Message ----------------------------------------------

  MsgList* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MsgList& from);
  void MergeFrom(const MsgList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 ret = 1;
  inline bool has_ret() const;
  inline void clear_ret();
  static const int kRetFieldNumber = 1;
  inline ::google::protobuf::uint32 ret() const;
  inline void set_ret(::google::protobuf::uint32 value);

  // repeated .MsgInfo msglist = 15;
  inline int msglist_size() const;
  inline void clear_msglist();
  static const int kMsglistFieldNumber = 15;
  inline const ::MsgInfo& msglist(int index) const;
  inline ::MsgInfo* mutable_msglist(int index);
  inline ::MsgInfo* add_msglist();
  inline const ::google::protobuf::RepeatedPtrField< ::MsgInfo >&
      msglist() const;
  inline ::google::protobuf::RepeatedPtrField< ::MsgInfo >*
      mutable_msglist();

  // @@protoc_insertion_point(class_scope:MsgList)
 private:
  inline void set_has_ret();
  inline void clear_has_ret();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::MsgInfo > msglist_;
  ::google::protobuf::uint32 ret_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_improtocol_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_improtocol_2eproto();
  #endif
  friend void protobuf_AssignDesc_improtocol_2eproto();
  friend void protobuf_ShutdownFile_improtocol_2eproto();

  void InitAsDefaultInstance();
  static MsgList* default_instance_;
};
// -------------------------------------------------------------------

class UserOfflineIND : public ::google::protobuf::MessageLite {
 public:
  UserOfflineIND();
  virtual ~UserOfflineIND();

  UserOfflineIND(const UserOfflineIND& from);

  inline UserOfflineIND& operator=(const UserOfflineIND& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const UserOfflineIND& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UserOfflineIND* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UserOfflineIND* other);

  // implements Message ----------------------------------------------

  UserOfflineIND* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UserOfflineIND& from);
  void MergeFrom(const UserOfflineIND& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 userid = 1;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUseridFieldNumber = 1;
  inline ::google::protobuf::uint32 userid() const;
  inline void set_userid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:UserOfflineIND)
 private:
  inline void set_has_userid();
  inline void clear_has_userid();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 userid_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_improtocol_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_improtocol_2eproto();
  #endif
  friend void protobuf_AssignDesc_improtocol_2eproto();
  friend void protobuf_ShutdownFile_improtocol_2eproto();

  void InitAsDefaultInstance();
  static UserOfflineIND* default_instance_;
};
// -------------------------------------------------------------------

class Buf_ServerSend : public ::google::protobuf::MessageLite {
 public:
  Buf_ServerSend();
  virtual ~Buf_ServerSend();

  Buf_ServerSend(const Buf_ServerSend& from);

  inline Buf_ServerSend& operator=(const Buf_ServerSend& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const Buf_ServerSend& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Buf_ServerSend* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Buf_ServerSend* other);

  // implements Message ----------------------------------------------

  Buf_ServerSend* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Buf_ServerSend& from);
  void MergeFrom(const Buf_ServerSend& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 packetCount = 1;
  inline bool has_packetcount() const;
  inline void clear_packetcount();
  static const int kPacketCountFieldNumber = 1;
  inline ::google::protobuf::uint32 packetcount() const;
  inline void set_packetcount(::google::protobuf::uint32 value);

  // required uint32 idxPacket = 2;
  inline bool has_idxpacket() const;
  inline void clear_idxpacket();
  static const int kIdxPacketFieldNumber = 2;
  inline ::google::protobuf::uint32 idxpacket() const;
  inline void set_idxpacket(::google::protobuf::uint32 value);

  // required string bufUnitIdx = 3;
  inline bool has_bufunitidx() const;
  inline void clear_bufunitidx();
  static const int kBufUnitIdxFieldNumber = 3;
  inline const ::std::string& bufunitidx() const;
  inline void set_bufunitidx(const ::std::string& value);
  inline void set_bufunitidx(const char* value);
  inline void set_bufunitidx(const char* value, size_t size);
  inline ::std::string* mutable_bufunitidx();
  inline ::std::string* release_bufunitidx();
  inline void set_allocated_bufunitidx(::std::string* bufunitidx);

  // required .EN_BUFLOCATION buflocation = 4;
  inline bool has_buflocation() const;
  inline void clear_buflocation();
  static const int kBuflocationFieldNumber = 4;
  inline ::EN_BUFLOCATION buflocation() const;
  inline void set_buflocation(::EN_BUFLOCATION value);

  // required bytes packetData = 5;
  inline bool has_packetdata() const;
  inline void clear_packetdata();
  static const int kPacketDataFieldNumber = 5;
  inline const ::std::string& packetdata() const;
  inline void set_packetdata(const ::std::string& value);
  inline void set_packetdata(const char* value);
  inline void set_packetdata(const void* value, size_t size);
  inline ::std::string* mutable_packetdata();
  inline ::std::string* release_packetdata();
  inline void set_allocated_packetdata(::std::string* packetdata);

  // @@protoc_insertion_point(class_scope:Buf_ServerSend)
 private:
  inline void set_has_packetcount();
  inline void clear_has_packetcount();
  inline void set_has_idxpacket();
  inline void clear_has_idxpacket();
  inline void set_has_bufunitidx();
  inline void clear_has_bufunitidx();
  inline void set_has_buflocation();
  inline void clear_has_buflocation();
  inline void set_has_packetdata();
  inline void clear_has_packetdata();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 packetcount_;
  ::google::protobuf::uint32 idxpacket_;
  ::std::string* bufunitidx_;
  ::std::string* packetdata_;
  int buflocation_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_improtocol_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_improtocol_2eproto();
  #endif
  friend void protobuf_AssignDesc_improtocol_2eproto();
  friend void protobuf_ShutdownFile_improtocol_2eproto();

  void InitAsDefaultInstance();
  static Buf_ServerSend* default_instance_;
};
// -------------------------------------------------------------------

class Buf_ClientSend : public ::google::protobuf::MessageLite {
 public:
  Buf_ClientSend();
  virtual ~Buf_ClientSend();

  Buf_ClientSend(const Buf_ClientSend& from);

  inline Buf_ClientSend& operator=(const Buf_ClientSend& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const Buf_ClientSend& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Buf_ClientSend* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Buf_ClientSend* other);

  // implements Message ----------------------------------------------

  Buf_ClientSend* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Buf_ClientSend& from);
  void MergeFrom(const Buf_ClientSend& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 idxPacketReq = 1;
  inline bool has_idxpacketreq() const;
  inline void clear_idxpacketreq();
  static const int kIdxPacketReqFieldNumber = 1;
  inline ::google::protobuf::uint32 idxpacketreq() const;
  inline void set_idxpacketreq(::google::protobuf::uint32 value);

  // required string bufUnitIdx = 2;
  inline bool has_bufunitidx() const;
  inline void clear_bufunitidx();
  static const int kBufUnitIdxFieldNumber = 2;
  inline const ::std::string& bufunitidx() const;
  inline void set_bufunitidx(const ::std::string& value);
  inline void set_bufunitidx(const char* value);
  inline void set_bufunitidx(const char* value, size_t size);
  inline ::std::string* mutable_bufunitidx();
  inline ::std::string* release_bufunitidx();
  inline void set_allocated_bufunitidx(::std::string* bufunitidx);

  // required .EN_BUFLOCATION buflocation = 3;
  inline bool has_buflocation() const;
  inline void clear_buflocation();
  static const int kBuflocationFieldNumber = 3;
  inline ::EN_BUFLOCATION buflocation() const;
  inline void set_buflocation(::EN_BUFLOCATION value);

  // @@protoc_insertion_point(class_scope:Buf_ClientSend)
 private:
  inline void set_has_idxpacketreq();
  inline void clear_has_idxpacketreq();
  inline void set_has_bufunitidx();
  inline void clear_has_bufunitidx();
  inline void set_has_buflocation();
  inline void clear_has_buflocation();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* bufunitidx_;
  ::google::protobuf::uint32 idxpacketreq_;
  int buflocation_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_improtocol_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_improtocol_2eproto();
  #endif
  friend void protobuf_AssignDesc_improtocol_2eproto();
  friend void protobuf_ShutdownFile_improtocol_2eproto();

  void InitAsDefaultInstance();
  static Buf_ClientSend* default_instance_;
};
// -------------------------------------------------------------------

class BaseReq : public ::google::protobuf::MessageLite {
 public:
  BaseReq();
  virtual ~BaseReq();

  BaseReq(const BaseReq& from);

  inline BaseReq& operator=(const BaseReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const BaseReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const BaseReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(BaseReq* other);

  // implements Message ----------------------------------------------

  BaseReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BaseReq& from);
  void MergeFrom(const BaseReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 userid = 1;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUseridFieldNumber = 1;
  inline ::google::protobuf::uint32 userid() const;
  inline void set_userid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:BaseReq)
 private:
  inline void set_has_userid();
  inline void clear_has_userid();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 userid_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_improtocol_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_improtocol_2eproto();
  #endif
  friend void protobuf_AssignDesc_improtocol_2eproto();
  friend void protobuf_ShutdownFile_improtocol_2eproto();

  void InitAsDefaultInstance();
  static BaseReq* default_instance_;
};
// -------------------------------------------------------------------

class MsgRemindAck : public ::google::protobuf::MessageLite {
 public:
  MsgRemindAck();
  virtual ~MsgRemindAck();

  MsgRemindAck(const MsgRemindAck& from);

  inline MsgRemindAck& operator=(const MsgRemindAck& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const MsgRemindAck& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const MsgRemindAck* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(MsgRemindAck* other);

  // implements Message ----------------------------------------------

  MsgRemindAck* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MsgRemindAck& from);
  void MergeFrom(const MsgRemindAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .REMIND_TYPE neworder = 1 [default = RT_RECEIVE_AND_POPMSG];
  inline bool has_neworder() const;
  inline void clear_neworder();
  static const int kNeworderFieldNumber = 1;
  inline ::REMIND_TYPE neworder() const;
  inline void set_neworder(::REMIND_TYPE value);

  // optional .REMIND_TYPE payorder = 2 [default = RT_RECEIVE_AND_POPMSG];
  inline bool has_payorder() const;
  inline void clear_payorder();
  static const int kPayorderFieldNumber = 2;
  inline ::REMIND_TYPE payorder() const;
  inline void set_payorder(::REMIND_TYPE value);

  // optional .REMIND_TYPE goodscomment = 3 [default = RT_RECEIVE_AND_POPMSG];
  inline bool has_goodscomment() const;
  inline void clear_goodscomment();
  static const int kGoodscommentFieldNumber = 3;
  inline ::REMIND_TYPE goodscomment() const;
  inline void set_goodscomment(::REMIND_TYPE value);

  // optional .REMIND_TYPE returnorder = 4 [default = RT_RECEIVE_AND_POPMSG];
  inline bool has_returnorder() const;
  inline void clear_returnorder();
  static const int kReturnorderFieldNumber = 4;
  inline ::REMIND_TYPE returnorder() const;
  inline void set_returnorder(::REMIND_TYPE value);

  // @@protoc_insertion_point(class_scope:MsgRemindAck)
 private:
  inline void set_has_neworder();
  inline void clear_has_neworder();
  inline void set_has_payorder();
  inline void clear_has_payorder();
  inline void set_has_goodscomment();
  inline void clear_has_goodscomment();
  inline void set_has_returnorder();
  inline void clear_has_returnorder();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int neworder_;
  int payorder_;
  int goodscomment_;
  int returnorder_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_improtocol_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_improtocol_2eproto();
  #endif
  friend void protobuf_AssignDesc_improtocol_2eproto();
  friend void protobuf_ShutdownFile_improtocol_2eproto();

  void InitAsDefaultInstance();
  static MsgRemindAck* default_instance_;
};
// -------------------------------------------------------------------

class CsUpdateOperReq : public ::google::protobuf::MessageLite {
 public:
  CsUpdateOperReq();
  virtual ~CsUpdateOperReq();

  CsUpdateOperReq(const CsUpdateOperReq& from);

  inline CsUpdateOperReq& operator=(const CsUpdateOperReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CsUpdateOperReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CsUpdateOperReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CsUpdateOperReq* other);

  // implements Message ----------------------------------------------

  CsUpdateOperReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CsUpdateOperReq& from);
  void MergeFrom(const CsUpdateOperReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .CS_UPDATE_OPER updateoper = 1;
  inline bool has_updateoper() const;
  inline void clear_updateoper();
  static const int kUpdateoperFieldNumber = 1;
  inline ::CS_UPDATE_OPER updateoper() const;
  inline void set_updateoper(::CS_UPDATE_OPER value);

  // required uint32 csid = 2;
  inline bool has_csid() const;
  inline void clear_csid();
  static const int kCsidFieldNumber = 2;
  inline ::google::protobuf::uint32 csid() const;
  inline void set_csid(::google::protobuf::uint32 value);

  // required uint32 custid = 3;
  inline bool has_custid() const;
  inline void clear_custid();
  static const int kCustidFieldNumber = 3;
  inline ::google::protobuf::uint32 custid() const;
  inline void set_custid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:CsUpdateOperReq)
 private:
  inline void set_has_updateoper();
  inline void clear_has_updateoper();
  inline void set_has_csid();
  inline void clear_has_csid();
  inline void set_has_custid();
  inline void clear_has_custid();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int updateoper_;
  ::google::protobuf::uint32 csid_;
  ::google::protobuf::uint32 custid_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_improtocol_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_improtocol_2eproto();
  #endif
  friend void protobuf_AssignDesc_improtocol_2eproto();
  friend void protobuf_ShutdownFile_improtocol_2eproto();

  void InitAsDefaultInstance();
  static CsUpdateOperReq* default_instance_;
};
// -------------------------------------------------------------------

class OrderGoodsInfo : public ::google::protobuf::MessageLite {
 public:
  OrderGoodsInfo();
  virtual ~OrderGoodsInfo();

  OrderGoodsInfo(const OrderGoodsInfo& from);

  inline OrderGoodsInfo& operator=(const OrderGoodsInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const OrderGoodsInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const OrderGoodsInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(OrderGoodsInfo* other);

  // implements Message ----------------------------------------------

  OrderGoodsInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const OrderGoodsInfo& from);
  void MergeFrom(const OrderGoodsInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string itno = 1;
  inline bool has_itno() const;
  inline void clear_itno();
  static const int kItnoFieldNumber = 1;
  inline const ::std::string& itno() const;
  inline void set_itno(const ::std::string& value);
  inline void set_itno(const char* value);
  inline void set_itno(const char* value, size_t size);
  inline ::std::string* mutable_itno();
  inline ::std::string* release_itno();
  inline void set_allocated_itno(::std::string* itno);

  // optional string productName = 2;
  inline bool has_productname() const;
  inline void clear_productname();
  static const int kProductNameFieldNumber = 2;
  inline const ::std::string& productname() const;
  inline void set_productname(const ::std::string& value);
  inline void set_productname(const char* value);
  inline void set_productname(const char* value, size_t size);
  inline ::std::string* mutable_productname();
  inline ::std::string* release_productname();
  inline void set_allocated_productname(::std::string* productname);

  // optional string sourceUrl = 3;
  inline bool has_sourceurl() const;
  inline void clear_sourceurl();
  static const int kSourceUrlFieldNumber = 3;
  inline const ::std::string& sourceurl() const;
  inline void set_sourceurl(const ::std::string& value);
  inline void set_sourceurl(const char* value);
  inline void set_sourceurl(const char* value, size_t size);
  inline ::std::string* mutable_sourceurl();
  inline ::std::string* release_sourceurl();
  inline void set_allocated_sourceurl(::std::string* sourceurl);

  // optional string picUrl = 4;
  inline bool has_picurl() const;
  inline void clear_picurl();
  static const int kPicUrlFieldNumber = 4;
  inline const ::std::string& picurl() const;
  inline void set_picurl(const ::std::string& value);
  inline void set_picurl(const char* value);
  inline void set_picurl(const char* value, size_t size);
  inline ::std::string* mutable_picurl();
  inline ::std::string* release_picurl();
  inline void set_allocated_picurl(::std::string* picurl);

  // optional uint32 qty = 5;
  inline bool has_qty() const;
  inline void clear_qty();
  static const int kQtyFieldNumber = 5;
  inline ::google::protobuf::uint32 qty() const;
  inline void set_qty(::google::protobuf::uint32 value);

  // optional uint32 isMall = 6;
  inline bool has_ismall() const;
  inline void clear_ismall();
  static const int kIsMallFieldNumber = 6;
  inline ::google::protobuf::uint32 ismall() const;
  inline void set_ismall(::google::protobuf::uint32 value);

  // optional string skuId = 7;
  inline bool has_skuid() const;
  inline void clear_skuid();
  static const int kSkuIdFieldNumber = 7;
  inline const ::std::string& skuid() const;
  inline void set_skuid(const ::std::string& value);
  inline void set_skuid(const char* value);
  inline void set_skuid(const char* value, size_t size);
  inline ::std::string* mutable_skuid();
  inline ::std::string* release_skuid();
  inline void set_allocated_skuid(::std::string* skuid);

  // optional double price = 8;
  inline bool has_price() const;
  inline void clear_price();
  static const int kPriceFieldNumber = 8;
  inline double price() const;
  inline void set_price(double value);

  // optional double subTotalPrice = 9;
  inline bool has_subtotalprice() const;
  inline void clear_subtotalprice();
  static const int kSubTotalPriceFieldNumber = 9;
  inline double subtotalprice() const;
  inline void set_subtotalprice(double value);

  // optional double coupons = 10;
  inline bool has_coupons() const;
  inline void clear_coupons();
  static const int kCouponsFieldNumber = 10;
  inline double coupons() const;
  inline void set_coupons(double value);

  // optional double voucher = 11;
  inline bool has_voucher() const;
  inline void clear_voucher();
  static const int kVoucherFieldNumber = 11;
  inline double voucher() const;
  inline void set_voucher(double value);

  // optional double shoppingCash = 12;
  inline bool has_shoppingcash() const;
  inline void clear_shoppingcash();
  static const int kShoppingCashFieldNumber = 12;
  inline double shoppingcash() const;
  inline void set_shoppingcash(double value);

  // optional double shoppingCard = 13;
  inline bool has_shoppingcard() const;
  inline void clear_shoppingcard();
  static const int kShoppingCardFieldNumber = 13;
  inline double shoppingcard() const;
  inline void set_shoppingcard(double value);

  // optional double pointsPrice = 14;
  inline bool has_pointsprice() const;
  inline void clear_pointsprice();
  static const int kPointsPriceFieldNumber = 14;
  inline double pointsprice() const;
  inline void set_pointsprice(double value);

  // optional double promote = 15;
  inline bool has_promote() const;
  inline void clear_promote();
  static const int kPromoteFieldNumber = 15;
  inline double promote() const;
  inline void set_promote(double value);

  // optional double shippingTax = 16;
  inline bool has_shippingtax() const;
  inline void clear_shippingtax();
  static const int kShippingTaxFieldNumber = 16;
  inline double shippingtax() const;
  inline void set_shippingtax(double value);

  // optional string freightNumber = 17;
  inline bool has_freightnumber() const;
  inline void clear_freightnumber();
  static const int kFreightNumberFieldNumber = 17;
  inline const ::std::string& freightnumber() const;
  inline void set_freightnumber(const ::std::string& value);
  inline void set_freightnumber(const char* value);
  inline void set_freightnumber(const char* value, size_t size);
  inline ::std::string* mutable_freightnumber();
  inline ::std::string* release_freightnumber();
  inline void set_allocated_freightnumber(::std::string* freightnumber);

  // optional string kind = 18;
  inline bool has_kind() const;
  inline void clear_kind();
  static const int kKindFieldNumber = 18;
  inline const ::std::string& kind() const;
  inline void set_kind(const ::std::string& value);
  inline void set_kind(const char* value);
  inline void set_kind(const char* value, size_t size);
  inline ::std::string* mutable_kind();
  inline ::std::string* release_kind();
  inline void set_allocated_kind(::std::string* kind);

  // optional string color = 19;
  inline bool has_color() const;
  inline void clear_color();
  static const int kColorFieldNumber = 19;
  inline const ::std::string& color() const;
  inline void set_color(const ::std::string& value);
  inline void set_color(const char* value);
  inline void set_color(const char* value, size_t size);
  inline ::std::string* mutable_color();
  inline ::std::string* release_color();
  inline void set_allocated_color(::std::string* color);

  // optional string size = 20;
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 20;
  inline const ::std::string& size() const;
  inline void set_size(const ::std::string& value);
  inline void set_size(const char* value);
  inline void set_size(const char* value, size_t size);
  inline ::std::string* mutable_size();
  inline ::std::string* release_size();
  inline void set_allocated_size(::std::string* size);

  // @@protoc_insertion_point(class_scope:OrderGoodsInfo)
 private:
  inline void set_has_itno();
  inline void clear_has_itno();
  inline void set_has_productname();
  inline void clear_has_productname();
  inline void set_has_sourceurl();
  inline void clear_has_sourceurl();
  inline void set_has_picurl();
  inline void clear_has_picurl();
  inline void set_has_qty();
  inline void clear_has_qty();
  inline void set_has_ismall();
  inline void clear_has_ismall();
  inline void set_has_skuid();
  inline void clear_has_skuid();
  inline void set_has_price();
  inline void clear_has_price();
  inline void set_has_subtotalprice();
  inline void clear_has_subtotalprice();
  inline void set_has_coupons();
  inline void clear_has_coupons();
  inline void set_has_voucher();
  inline void clear_has_voucher();
  inline void set_has_shoppingcash();
  inline void clear_has_shoppingcash();
  inline void set_has_shoppingcard();
  inline void clear_has_shoppingcard();
  inline void set_has_pointsprice();
  inline void clear_has_pointsprice();
  inline void set_has_promote();
  inline void clear_has_promote();
  inline void set_has_shippingtax();
  inline void clear_has_shippingtax();
  inline void set_has_freightnumber();
  inline void clear_has_freightnumber();
  inline void set_has_kind();
  inline void clear_has_kind();
  inline void set_has_color();
  inline void clear_has_color();
  inline void set_has_size();
  inline void clear_has_size();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* itno_;
  ::std::string* productname_;
  ::std::string* sourceurl_;
  ::std::string* picurl_;
  ::google::protobuf::uint32 qty_;
  ::google::protobuf::uint32 ismall_;
  ::std::string* skuid_;
  double price_;
  double subtotalprice_;
  double coupons_;
  double voucher_;
  double shoppingcash_;
  double shoppingcard_;
  double pointsprice_;
  double promote_;
  double shippingtax_;
  ::std::string* freightnumber_;
  ::std::string* kind_;
  ::std::string* color_;
  ::std::string* size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_improtocol_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_improtocol_2eproto();
  #endif
  friend void protobuf_AssignDesc_improtocol_2eproto();
  friend void protobuf_ShutdownFile_improtocol_2eproto();

  void InitAsDefaultInstance();
  static OrderGoodsInfo* default_instance_;
};
// -------------------------------------------------------------------

class NewOrder : public ::google::protobuf::MessageLite {
 public:
  NewOrder();
  virtual ~NewOrder();

  NewOrder(const NewOrder& from);

  inline NewOrder& operator=(const NewOrder& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const NewOrder& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const NewOrder* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(NewOrder* other);

  // implements Message ----------------------------------------------

  NewOrder* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const NewOrder& from);
  void MergeFrom(const NewOrder& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string ogNo = 1;
  inline bool has_ogno() const;
  inline void clear_ogno();
  static const int kOgNoFieldNumber = 1;
  inline const ::std::string& ogno() const;
  inline void set_ogno(const ::std::string& value);
  inline void set_ogno(const char* value);
  inline void set_ogno(const char* value, size_t size);
  inline ::std::string* mutable_ogno();
  inline ::std::string* release_ogno();
  inline void set_allocated_ogno(::std::string* ogno);

  // optional string ogSeq = 2;
  inline bool has_ogseq() const;
  inline void clear_ogseq();
  static const int kOgSeqFieldNumber = 2;
  inline const ::std::string& ogseq() const;
  inline void set_ogseq(const ::std::string& value);
  inline void set_ogseq(const char* value);
  inline void set_ogseq(const char* value, size_t size);
  inline ::std::string* mutable_ogseq();
  inline ::std::string* release_ogseq();
  inline void set_allocated_ogseq(::std::string* ogseq);

  // optional string memGuid = 3;
  inline bool has_memguid() const;
  inline void clear_memguid();
  static const int kMemGuidFieldNumber = 3;
  inline const ::std::string& memguid() const;
  inline void set_memguid(const ::std::string& value);
  inline void set_memguid(const char* value);
  inline void set_memguid(const char* value, size_t size);
  inline ::std::string* mutable_memguid();
  inline ::std::string* release_memguid();
  inline void set_allocated_memguid(::std::string* memguid);

  // optional double totalPay = 4;
  inline bool has_totalpay() const;
  inline void clear_totalpay();
  static const int kTotalPayFieldNumber = 4;
  inline double totalpay() const;
  inline void set_totalpay(double value);

  // optional string memberName = 5;
  inline bool has_membername() const;
  inline void clear_membername();
  static const int kMemberNameFieldNumber = 5;
  inline const ::std::string& membername() const;
  inline void set_membername(const ::std::string& value);
  inline void set_membername(const char* value);
  inline void set_membername(const char* value, size_t size);
  inline ::std::string* mutable_membername();
  inline ::std::string* release_membername();
  inline void set_allocated_membername(::std::string* membername);

  // optional string memberCellphone = 6;
  inline bool has_membercellphone() const;
  inline void clear_membercellphone();
  static const int kMemberCellphoneFieldNumber = 6;
  inline const ::std::string& membercellphone() const;
  inline void set_membercellphone(const ::std::string& value);
  inline void set_membercellphone(const char* value);
  inline void set_membercellphone(const char* value, size_t size);
  inline ::std::string* mutable_membercellphone();
  inline ::std::string* release_membercellphone();
  inline void set_allocated_membercellphone(::std::string* membercellphone);

  // optional string insertDate = 7;
  inline bool has_insertdate() const;
  inline void clear_insertdate();
  static const int kInsertDateFieldNumber = 7;
  inline const ::std::string& insertdate() const;
  inline void set_insertdate(const ::std::string& value);
  inline void set_insertdate(const char* value);
  inline void set_insertdate(const char* value, size_t size);
  inline ::std::string* mutable_insertdate();
  inline ::std::string* release_insertdate();
  inline void set_allocated_insertdate(::std::string* insertdate);

  // optional string payType = 8;
  inline bool has_paytype() const;
  inline void clear_paytype();
  static const int kPayTypeFieldNumber = 8;
  inline const ::std::string& paytype() const;
  inline void set_paytype(const ::std::string& value);
  inline void set_paytype(const char* value);
  inline void set_paytype(const char* value, size_t size);
  inline ::std::string* mutable_paytype();
  inline ::std::string* release_paytype();
  inline void set_allocated_paytype(::std::string* paytype);

  // optional string packNo = 9;
  inline bool has_packno() const;
  inline void clear_packno();
  static const int kPackNoFieldNumber = 9;
  inline const ::std::string& packno() const;
  inline void set_packno(const ::std::string& value);
  inline void set_packno(const char* value);
  inline void set_packno(const char* value, size_t size);
  inline ::std::string* mutable_packno();
  inline ::std::string* release_packno();
  inline void set_allocated_packno(::std::string* packno);

  // optional uint32 packState = 10;
  inline bool has_packstate() const;
  inline void clear_packstate();
  static const int kPackStateFieldNumber = 10;
  inline ::google::protobuf::uint32 packstate() const;
  inline void set_packstate(::google::protobuf::uint32 value);

  // optional string packStateStr = 11;
  inline bool has_packstatestr() const;
  inline void clear_packstatestr();
  static const int kPackStateStrFieldNumber = 11;
  inline const ::std::string& packstatestr() const;
  inline void set_packstatestr(const ::std::string& value);
  inline void set_packstatestr(const char* value);
  inline void set_packstatestr(const char* value, size_t size);
  inline ::std::string* mutable_packstatestr();
  inline ::std::string* release_packstatestr();
  inline void set_allocated_packstatestr(::std::string* packstatestr);

  // optional uint32 type = 12;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 12;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // optional string packQueryNo = 13;
  inline bool has_packqueryno() const;
  inline void clear_packqueryno();
  static const int kPackQueryNoFieldNumber = 13;
  inline const ::std::string& packqueryno() const;
  inline void set_packqueryno(const ::std::string& value);
  inline void set_packqueryno(const char* value);
  inline void set_packqueryno(const char* value, size_t size);
  inline ::std::string* mutable_packqueryno();
  inline ::std::string* release_packqueryno();
  inline void set_allocated_packqueryno(::std::string* packqueryno);

  // optional string merchantId = 14;
  inline bool has_merchantid() const;
  inline void clear_merchantid();
  static const int kMerchantIdFieldNumber = 14;
  inline const ::std::string& merchantid() const;
  inline void set_merchantid(const ::std::string& value);
  inline void set_merchantid(const char* value);
  inline void set_merchantid(const char* value, size_t size);
  inline ::std::string* mutable_merchantid();
  inline ::std::string* release_merchantid();
  inline void set_allocated_merchantid(::std::string* merchantid);

  // optional double freight = 15;
  inline bool has_freight() const;
  inline void clear_freight();
  static const int kFreightFieldNumber = 15;
  inline double freight() const;
  inline void set_freight(double value);

  // optional string buyername = 16;
  inline bool has_buyername() const;
  inline void clear_buyername();
  static const int kBuyernameFieldNumber = 16;
  inline const ::std::string& buyername() const;
  inline void set_buyername(const ::std::string& value);
  inline void set_buyername(const char* value);
  inline void set_buyername(const char* value, size_t size);
  inline ::std::string* mutable_buyername();
  inline ::std::string* release_buyername();
  inline void set_allocated_buyername(::std::string* buyername);

  // repeated .OrderGoodsInfo goodslist = 25;
  inline int goodslist_size() const;
  inline void clear_goodslist();
  static const int kGoodslistFieldNumber = 25;
  inline const ::OrderGoodsInfo& goodslist(int index) const;
  inline ::OrderGoodsInfo* mutable_goodslist(int index);
  inline ::OrderGoodsInfo* add_goodslist();
  inline const ::google::protobuf::RepeatedPtrField< ::OrderGoodsInfo >&
      goodslist() const;
  inline ::google::protobuf::RepeatedPtrField< ::OrderGoodsInfo >*
      mutable_goodslist();

  // @@protoc_insertion_point(class_scope:NewOrder)
 private:
  inline void set_has_ogno();
  inline void clear_has_ogno();
  inline void set_has_ogseq();
  inline void clear_has_ogseq();
  inline void set_has_memguid();
  inline void clear_has_memguid();
  inline void set_has_totalpay();
  inline void clear_has_totalpay();
  inline void set_has_membername();
  inline void clear_has_membername();
  inline void set_has_membercellphone();
  inline void clear_has_membercellphone();
  inline void set_has_insertdate();
  inline void clear_has_insertdate();
  inline void set_has_paytype();
  inline void clear_has_paytype();
  inline void set_has_packno();
  inline void clear_has_packno();
  inline void set_has_packstate();
  inline void clear_has_packstate();
  inline void set_has_packstatestr();
  inline void clear_has_packstatestr();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_packqueryno();
  inline void clear_has_packqueryno();
  inline void set_has_merchantid();
  inline void clear_has_merchantid();
  inline void set_has_freight();
  inline void clear_has_freight();
  inline void set_has_buyername();
  inline void clear_has_buyername();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* ogno_;
  ::std::string* ogseq_;
  ::std::string* memguid_;
  double totalpay_;
  ::std::string* membername_;
  ::std::string* membercellphone_;
  ::std::string* insertdate_;
  ::std::string* paytype_;
  ::std::string* packno_;
  ::std::string* packstatestr_;
  ::google::protobuf::uint32 packstate_;
  ::google::protobuf::uint32 type_;
  ::std::string* packqueryno_;
  ::std::string* merchantid_;
  double freight_;
  ::std::string* buyername_;
  ::google::protobuf::RepeatedPtrField< ::OrderGoodsInfo > goodslist_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_improtocol_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_improtocol_2eproto();
  #endif
  friend void protobuf_AssignDesc_improtocol_2eproto();
  friend void protobuf_ShutdownFile_improtocol_2eproto();

  void InitAsDefaultInstance();
  static NewOrder* default_instance_;
};
// -------------------------------------------------------------------

class PayOrder : public ::google::protobuf::MessageLite {
 public:
  PayOrder();
  virtual ~PayOrder();

  PayOrder(const PayOrder& from);

  inline PayOrder& operator=(const PayOrder& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const PayOrder& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PayOrder* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PayOrder* other);

  // implements Message ----------------------------------------------

  PayOrder* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PayOrder& from);
  void MergeFrom(const PayOrder& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string ogNo = 1;
  inline bool has_ogno() const;
  inline void clear_ogno();
  static const int kOgNoFieldNumber = 1;
  inline const ::std::string& ogno() const;
  inline void set_ogno(const ::std::string& value);
  inline void set_ogno(const char* value);
  inline void set_ogno(const char* value, size_t size);
  inline ::std::string* mutable_ogno();
  inline ::std::string* release_ogno();
  inline void set_allocated_ogno(::std::string* ogno);

  // optional string ogSeq = 2;
  inline bool has_ogseq() const;
  inline void clear_ogseq();
  static const int kOgSeqFieldNumber = 2;
  inline const ::std::string& ogseq() const;
  inline void set_ogseq(const ::std::string& value);
  inline void set_ogseq(const char* value);
  inline void set_ogseq(const char* value, size_t size);
  inline ::std::string* mutable_ogseq();
  inline ::std::string* release_ogseq();
  inline void set_allocated_ogseq(::std::string* ogseq);

  // optional string memGuid = 3;
  inline bool has_memguid() const;
  inline void clear_memguid();
  static const int kMemGuidFieldNumber = 3;
  inline const ::std::string& memguid() const;
  inline void set_memguid(const ::std::string& value);
  inline void set_memguid(const char* value);
  inline void set_memguid(const char* value, size_t size);
  inline ::std::string* mutable_memguid();
  inline ::std::string* release_memguid();
  inline void set_allocated_memguid(::std::string* memguid);

  // optional double totalPay = 4;
  inline bool has_totalpay() const;
  inline void clear_totalpay();
  static const int kTotalPayFieldNumber = 4;
  inline double totalpay() const;
  inline void set_totalpay(double value);

  // optional string memberName = 5;
  inline bool has_membername() const;
  inline void clear_membername();
  static const int kMemberNameFieldNumber = 5;
  inline const ::std::string& membername() const;
  inline void set_membername(const ::std::string& value);
  inline void set_membername(const char* value);
  inline void set_membername(const char* value, size_t size);
  inline ::std::string* mutable_membername();
  inline ::std::string* release_membername();
  inline void set_allocated_membername(::std::string* membername);

  // optional string memberCellphone = 6;
  inline bool has_membercellphone() const;
  inline void clear_membercellphone();
  static const int kMemberCellphoneFieldNumber = 6;
  inline const ::std::string& membercellphone() const;
  inline void set_membercellphone(const ::std::string& value);
  inline void set_membercellphone(const char* value);
  inline void set_membercellphone(const char* value, size_t size);
  inline ::std::string* mutable_membercellphone();
  inline ::std::string* release_membercellphone();
  inline void set_allocated_membercellphone(::std::string* membercellphone);

  // optional string insertDate = 7;
  inline bool has_insertdate() const;
  inline void clear_insertdate();
  static const int kInsertDateFieldNumber = 7;
  inline const ::std::string& insertdate() const;
  inline void set_insertdate(const ::std::string& value);
  inline void set_insertdate(const char* value);
  inline void set_insertdate(const char* value, size_t size);
  inline ::std::string* mutable_insertdate();
  inline ::std::string* release_insertdate();
  inline void set_allocated_insertdate(::std::string* insertdate);

  // optional string payType = 8;
  inline bool has_paytype() const;
  inline void clear_paytype();
  static const int kPayTypeFieldNumber = 8;
  inline const ::std::string& paytype() const;
  inline void set_paytype(const ::std::string& value);
  inline void set_paytype(const char* value);
  inline void set_paytype(const char* value, size_t size);
  inline ::std::string* mutable_paytype();
  inline ::std::string* release_paytype();
  inline void set_allocated_paytype(::std::string* paytype);

  // optional string packNo = 9;
  inline bool has_packno() const;
  inline void clear_packno();
  static const int kPackNoFieldNumber = 9;
  inline const ::std::string& packno() const;
  inline void set_packno(const ::std::string& value);
  inline void set_packno(const char* value);
  inline void set_packno(const char* value, size_t size);
  inline ::std::string* mutable_packno();
  inline ::std::string* release_packno();
  inline void set_allocated_packno(::std::string* packno);

  // optional uint32 packState = 10;
  inline bool has_packstate() const;
  inline void clear_packstate();
  static const int kPackStateFieldNumber = 10;
  inline ::google::protobuf::uint32 packstate() const;
  inline void set_packstate(::google::protobuf::uint32 value);

  // optional string packStateStr = 11;
  inline bool has_packstatestr() const;
  inline void clear_packstatestr();
  static const int kPackStateStrFieldNumber = 11;
  inline const ::std::string& packstatestr() const;
  inline void set_packstatestr(const ::std::string& value);
  inline void set_packstatestr(const char* value);
  inline void set_packstatestr(const char* value, size_t size);
  inline ::std::string* mutable_packstatestr();
  inline ::std::string* release_packstatestr();
  inline void set_allocated_packstatestr(::std::string* packstatestr);

  // optional uint32 type = 12;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 12;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // optional string packQueryNo = 13;
  inline bool has_packqueryno() const;
  inline void clear_packqueryno();
  static const int kPackQueryNoFieldNumber = 13;
  inline const ::std::string& packqueryno() const;
  inline void set_packqueryno(const ::std::string& value);
  inline void set_packqueryno(const char* value);
  inline void set_packqueryno(const char* value, size_t size);
  inline ::std::string* mutable_packqueryno();
  inline ::std::string* release_packqueryno();
  inline void set_allocated_packqueryno(::std::string* packqueryno);

  // optional string merchantId = 14;
  inline bool has_merchantid() const;
  inline void clear_merchantid();
  static const int kMerchantIdFieldNumber = 14;
  inline const ::std::string& merchantid() const;
  inline void set_merchantid(const ::std::string& value);
  inline void set_merchantid(const char* value);
  inline void set_merchantid(const char* value, size_t size);
  inline ::std::string* mutable_merchantid();
  inline ::std::string* release_merchantid();
  inline void set_allocated_merchantid(::std::string* merchantid);

  // optional double freight = 15;
  inline bool has_freight() const;
  inline void clear_freight();
  static const int kFreightFieldNumber = 15;
  inline double freight() const;
  inline void set_freight(double value);

  // optional string buyername = 16;
  inline bool has_buyername() const;
  inline void clear_buyername();
  static const int kBuyernameFieldNumber = 16;
  inline const ::std::string& buyername() const;
  inline void set_buyername(const ::std::string& value);
  inline void set_buyername(const char* value);
  inline void set_buyername(const char* value, size_t size);
  inline ::std::string* mutable_buyername();
  inline ::std::string* release_buyername();
  inline void set_allocated_buyername(::std::string* buyername);

  // optional string payDate = 17;
  inline bool has_paydate() const;
  inline void clear_paydate();
  static const int kPayDateFieldNumber = 17;
  inline const ::std::string& paydate() const;
  inline void set_paydate(const ::std::string& value);
  inline void set_paydate(const char* value);
  inline void set_paydate(const char* value, size_t size);
  inline ::std::string* mutable_paydate();
  inline ::std::string* release_paydate();
  inline void set_allocated_paydate(::std::string* paydate);

  // repeated .OrderGoodsInfo goodslist = 25;
  inline int goodslist_size() const;
  inline void clear_goodslist();
  static const int kGoodslistFieldNumber = 25;
  inline const ::OrderGoodsInfo& goodslist(int index) const;
  inline ::OrderGoodsInfo* mutable_goodslist(int index);
  inline ::OrderGoodsInfo* add_goodslist();
  inline const ::google::protobuf::RepeatedPtrField< ::OrderGoodsInfo >&
      goodslist() const;
  inline ::google::protobuf::RepeatedPtrField< ::OrderGoodsInfo >*
      mutable_goodslist();

  // @@protoc_insertion_point(class_scope:PayOrder)
 private:
  inline void set_has_ogno();
  inline void clear_has_ogno();
  inline void set_has_ogseq();
  inline void clear_has_ogseq();
  inline void set_has_memguid();
  inline void clear_has_memguid();
  inline void set_has_totalpay();
  inline void clear_has_totalpay();
  inline void set_has_membername();
  inline void clear_has_membername();
  inline void set_has_membercellphone();
  inline void clear_has_membercellphone();
  inline void set_has_insertdate();
  inline void clear_has_insertdate();
  inline void set_has_paytype();
  inline void clear_has_paytype();
  inline void set_has_packno();
  inline void clear_has_packno();
  inline void set_has_packstate();
  inline void clear_has_packstate();
  inline void set_has_packstatestr();
  inline void clear_has_packstatestr();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_packqueryno();
  inline void clear_has_packqueryno();
  inline void set_has_merchantid();
  inline void clear_has_merchantid();
  inline void set_has_freight();
  inline void clear_has_freight();
  inline void set_has_buyername();
  inline void clear_has_buyername();
  inline void set_has_paydate();
  inline void clear_has_paydate();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* ogno_;
  ::std::string* ogseq_;
  ::std::string* memguid_;
  double totalpay_;
  ::std::string* membername_;
  ::std::string* membercellphone_;
  ::std::string* insertdate_;
  ::std::string* paytype_;
  ::std::string* packno_;
  ::std::string* packstatestr_;
  ::google::protobuf::uint32 packstate_;
  ::google::protobuf::uint32 type_;
  ::std::string* packqueryno_;
  ::std::string* merchantid_;
  double freight_;
  ::std::string* buyername_;
  ::std::string* paydate_;
  ::google::protobuf::RepeatedPtrField< ::OrderGoodsInfo > goodslist_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_improtocol_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_improtocol_2eproto();
  #endif
  friend void protobuf_AssignDesc_improtocol_2eproto();
  friend void protobuf_ShutdownFile_improtocol_2eproto();

  void InitAsDefaultInstance();
  static PayOrder* default_instance_;
};
// -------------------------------------------------------------------

class GoodsComment : public ::google::protobuf::MessageLite {
 public:
  GoodsComment();
  virtual ~GoodsComment();

  GoodsComment(const GoodsComment& from);

  inline GoodsComment& operator=(const GoodsComment& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GoodsComment& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GoodsComment* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GoodsComment* other);

  // implements Message ----------------------------------------------

  GoodsComment* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GoodsComment& from);
  void MergeFrom(const GoodsComment& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string ogNo = 1;
  inline bool has_ogno() const;
  inline void clear_ogno();
  static const int kOgNoFieldNumber = 1;
  inline const ::std::string& ogno() const;
  inline void set_ogno(const ::std::string& value);
  inline void set_ogno(const char* value);
  inline void set_ogno(const char* value, size_t size);
  inline ::std::string* mutable_ogno();
  inline ::std::string* release_ogno();
  inline void set_allocated_ogno(::std::string* ogno);

  // optional string ogSeq = 2;
  inline bool has_ogseq() const;
  inline void clear_ogseq();
  static const int kOgSeqFieldNumber = 2;
  inline const ::std::string& ogseq() const;
  inline void set_ogseq(const ::std::string& value);
  inline void set_ogseq(const char* value);
  inline void set_ogseq(const char* value, size_t size);
  inline ::std::string* mutable_ogseq();
  inline ::std::string* release_ogseq();
  inline void set_allocated_ogseq(::std::string* ogseq);

  // optional string memGuid = 3;
  inline bool has_memguid() const;
  inline void clear_memguid();
  static const int kMemGuidFieldNumber = 3;
  inline const ::std::string& memguid() const;
  inline void set_memguid(const ::std::string& value);
  inline void set_memguid(const char* value);
  inline void set_memguid(const char* value, size_t size);
  inline ::std::string* mutable_memguid();
  inline ::std::string* release_memguid();
  inline void set_allocated_memguid(::std::string* memguid);

  // optional string memberName = 4;
  inline bool has_membername() const;
  inline void clear_membername();
  static const int kMemberNameFieldNumber = 4;
  inline const ::std::string& membername() const;
  inline void set_membername(const ::std::string& value);
  inline void set_membername(const char* value);
  inline void set_membername(const char* value, size_t size);
  inline ::std::string* mutable_membername();
  inline ::std::string* release_membername();
  inline void set_allocated_membername(::std::string* membername);

  // optional string memberCellphone = 5;
  inline bool has_membercellphone() const;
  inline void clear_membercellphone();
  static const int kMemberCellphoneFieldNumber = 5;
  inline const ::std::string& membercellphone() const;
  inline void set_membercellphone(const ::std::string& value);
  inline void set_membercellphone(const char* value);
  inline void set_membercellphone(const char* value, size_t size);
  inline ::std::string* mutable_membercellphone();
  inline ::std::string* release_membercellphone();
  inline void set_allocated_membercellphone(::std::string* membercellphone);

  // optional string insertDate = 6;
  inline bool has_insertdate() const;
  inline void clear_insertdate();
  static const int kInsertDateFieldNumber = 6;
  inline const ::std::string& insertdate() const;
  inline void set_insertdate(const ::std::string& value);
  inline void set_insertdate(const char* value);
  inline void set_insertdate(const char* value, size_t size);
  inline ::std::string* mutable_insertdate();
  inline ::std::string* release_insertdate();
  inline void set_allocated_insertdate(::std::string* insertdate);

  // optional string payType = 7;
  inline bool has_paytype() const;
  inline void clear_paytype();
  static const int kPayTypeFieldNumber = 7;
  inline const ::std::string& paytype() const;
  inline void set_paytype(const ::std::string& value);
  inline void set_paytype(const char* value);
  inline void set_paytype(const char* value, size_t size);
  inline ::std::string* mutable_paytype();
  inline ::std::string* release_paytype();
  inline void set_allocated_paytype(::std::string* paytype);

  // optional string merchantId = 8;
  inline bool has_merchantid() const;
  inline void clear_merchantid();
  static const int kMerchantIdFieldNumber = 8;
  inline const ::std::string& merchantid() const;
  inline void set_merchantid(const ::std::string& value);
  inline void set_merchantid(const char* value);
  inline void set_merchantid(const char* value, size_t size);
  inline ::std::string* mutable_merchantid();
  inline ::std::string* release_merchantid();
  inline void set_allocated_merchantid(::std::string* merchantid);

  // optional string bugername = 9;
  inline bool has_bugername() const;
  inline void clear_bugername();
  static const int kBugernameFieldNumber = 9;
  inline const ::std::string& bugername() const;
  inline void set_bugername(const ::std::string& value);
  inline void set_bugername(const char* value);
  inline void set_bugername(const char* value, size_t size);
  inline ::std::string* mutable_bugername();
  inline ::std::string* release_bugername();
  inline void set_allocated_bugername(::std::string* bugername);

  // optional double evaluatelevel = 10;
  inline bool has_evaluatelevel() const;
  inline void clear_evaluatelevel();
  static const int kEvaluatelevelFieldNumber = 10;
  inline double evaluatelevel() const;
  inline void set_evaluatelevel(double value);

  // optional string evaluatecontext = 11;
  inline bool has_evaluatecontext() const;
  inline void clear_evaluatecontext();
  static const int kEvaluatecontextFieldNumber = 11;
  inline const ::std::string& evaluatecontext() const;
  inline void set_evaluatecontext(const ::std::string& value);
  inline void set_evaluatecontext(const char* value);
  inline void set_evaluatecontext(const char* value, size_t size);
  inline ::std::string* mutable_evaluatecontext();
  inline ::std::string* release_evaluatecontext();
  inline void set_allocated_evaluatecontext(::std::string* evaluatecontext);

  // optional string commentDate = 17;
  inline bool has_commentdate() const;
  inline void clear_commentdate();
  static const int kCommentDateFieldNumber = 17;
  inline const ::std::string& commentdate() const;
  inline void set_commentdate(const ::std::string& value);
  inline void set_commentdate(const char* value);
  inline void set_commentdate(const char* value, size_t size);
  inline ::std::string* mutable_commentdate();
  inline ::std::string* release_commentdate();
  inline void set_allocated_commentdate(::std::string* commentdate);

  // optional .OrderGoodsInfo goods = 15;
  inline bool has_goods() const;
  inline void clear_goods();
  static const int kGoodsFieldNumber = 15;
  inline const ::OrderGoodsInfo& goods() const;
  inline ::OrderGoodsInfo* mutable_goods();
  inline ::OrderGoodsInfo* release_goods();
  inline void set_allocated_goods(::OrderGoodsInfo* goods);

  // @@protoc_insertion_point(class_scope:GoodsComment)
 private:
  inline void set_has_ogno();
  inline void clear_has_ogno();
  inline void set_has_ogseq();
  inline void clear_has_ogseq();
  inline void set_has_memguid();
  inline void clear_has_memguid();
  inline void set_has_membername();
  inline void clear_has_membername();
  inline void set_has_membercellphone();
  inline void clear_has_membercellphone();
  inline void set_has_insertdate();
  inline void clear_has_insertdate();
  inline void set_has_paytype();
  inline void clear_has_paytype();
  inline void set_has_merchantid();
  inline void clear_has_merchantid();
  inline void set_has_bugername();
  inline void clear_has_bugername();
  inline void set_has_evaluatelevel();
  inline void clear_has_evaluatelevel();
  inline void set_has_evaluatecontext();
  inline void clear_has_evaluatecontext();
  inline void set_has_commentdate();
  inline void clear_has_commentdate();
  inline void set_has_goods();
  inline void clear_has_goods();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* ogno_;
  ::std::string* ogseq_;
  ::std::string* memguid_;
  ::std::string* membername_;
  ::std::string* membercellphone_;
  ::std::string* insertdate_;
  ::std::string* paytype_;
  ::std::string* merchantid_;
  ::std::string* bugername_;
  double evaluatelevel_;
  ::std::string* evaluatecontext_;
  ::std::string* commentdate_;
  ::OrderGoodsInfo* goods_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_improtocol_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_improtocol_2eproto();
  #endif
  friend void protobuf_AssignDesc_improtocol_2eproto();
  friend void protobuf_ShutdownFile_improtocol_2eproto();

  void InitAsDefaultInstance();
  static GoodsComment* default_instance_;
};
// -------------------------------------------------------------------

class ReturnGoodsInfo : public ::google::protobuf::MessageLite {
 public:
  ReturnGoodsInfo();
  virtual ~ReturnGoodsInfo();

  ReturnGoodsInfo(const ReturnGoodsInfo& from);

  inline ReturnGoodsInfo& operator=(const ReturnGoodsInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ReturnGoodsInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ReturnGoodsInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ReturnGoodsInfo* other);

  // implements Message ----------------------------------------------

  ReturnGoodsInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ReturnGoodsInfo& from);
  void MergeFrom(const ReturnGoodsInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string skuId = 1;
  inline bool has_skuid() const;
  inline void clear_skuid();
  static const int kSkuIdFieldNumber = 1;
  inline const ::std::string& skuid() const;
  inline void set_skuid(const ::std::string& value);
  inline void set_skuid(const char* value);
  inline void set_skuid(const char* value, size_t size);
  inline ::std::string* mutable_skuid();
  inline ::std::string* release_skuid();
  inline void set_allocated_skuid(::std::string* skuid);

  // optional double productPrice = 2;
  inline bool has_productprice() const;
  inline void clear_productprice();
  static const int kProductPriceFieldNumber = 2;
  inline double productprice() const;
  inline void set_productprice(double value);

  // optional int32 productQty = 3;
  inline bool has_productqty() const;
  inline void clear_productqty();
  static const int kProductQtyFieldNumber = 3;
  inline ::google::protobuf::int32 productqty() const;
  inline void set_productqty(::google::protobuf::int32 value);

  // optional int32 returnQty = 4;
  inline bool has_returnqty() const;
  inline void clear_returnqty();
  static const int kReturnQtyFieldNumber = 4;
  inline ::google::protobuf::int32 returnqty() const;
  inline void set_returnqty(::google::protobuf::int32 value);

  // optional string productMainUrl = 5;
  inline bool has_productmainurl() const;
  inline void clear_productmainurl();
  static const int kProductMainUrlFieldNumber = 5;
  inline const ::std::string& productmainurl() const;
  inline void set_productmainurl(const ::std::string& value);
  inline void set_productmainurl(const char* value);
  inline void set_productmainurl(const char* value, size_t size);
  inline ::std::string* mutable_productmainurl();
  inline ::std::string* release_productmainurl();
  inline void set_allocated_productmainurl(::std::string* productmainurl);

  // optional string sourceUrl = 6;
  inline bool has_sourceurl() const;
  inline void clear_sourceurl();
  static const int kSourceUrlFieldNumber = 6;
  inline const ::std::string& sourceurl() const;
  inline void set_sourceurl(const ::std::string& value);
  inline void set_sourceurl(const char* value);
  inline void set_sourceurl(const char* value, size_t size);
  inline ::std::string* mutable_sourceurl();
  inline ::std::string* release_sourceurl();
  inline void set_allocated_sourceurl(::std::string* sourceurl);

  // optional string color = 7;
  inline bool has_color() const;
  inline void clear_color();
  static const int kColorFieldNumber = 7;
  inline const ::std::string& color() const;
  inline void set_color(const ::std::string& value);
  inline void set_color(const char* value);
  inline void set_color(const char* value, size_t size);
  inline ::std::string* mutable_color();
  inline ::std::string* release_color();
  inline void set_allocated_color(::std::string* color);

  // optional string size = 8;
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 8;
  inline const ::std::string& size() const;
  inline void set_size(const ::std::string& value);
  inline void set_size(const char* value);
  inline void set_size(const char* value, size_t size);
  inline ::std::string* mutable_size();
  inline ::std::string* release_size();
  inline void set_allocated_size(::std::string* size);

  // optional string reason = 9;
  inline bool has_reason() const;
  inline void clear_reason();
  static const int kReasonFieldNumber = 9;
  inline const ::std::string& reason() const;
  inline void set_reason(const ::std::string& value);
  inline void set_reason(const char* value);
  inline void set_reason(const char* value, size_t size);
  inline ::std::string* mutable_reason();
  inline ::std::string* release_reason();
  inline void set_allocated_reason(::std::string* reason);

  // optional double aprnPromote = 10;
  inline bool has_aprnpromote() const;
  inline void clear_aprnpromote();
  static const int kAprnPromoteFieldNumber = 10;
  inline double aprnpromote() const;
  inline void set_aprnpromote(double value);

  // optional double aprnVoucher = 11;
  inline bool has_aprnvoucher() const;
  inline void clear_aprnvoucher();
  static const int kAprnVoucherFieldNumber = 11;
  inline double aprnvoucher() const;
  inline void set_aprnvoucher(double value);

  // optional double shippingTax = 12;
  inline bool has_shippingtax() const;
  inline void clear_shippingtax();
  static const int kShippingTaxFieldNumber = 12;
  inline double shippingtax() const;
  inline void set_shippingtax(double value);

  // optional double origPrice = 13;
  inline bool has_origprice() const;
  inline void clear_origprice();
  static const int kOrigPriceFieldNumber = 13;
  inline double origprice() const;
  inline void set_origprice(double value);

  // optional double aprnPoint = 14;
  inline bool has_aprnpoint() const;
  inline void clear_aprnpoint();
  static const int kAprnPointFieldNumber = 14;
  inline double aprnpoint() const;
  inline void set_aprnpoint(double value);

  // optional double aprnPointPrice = 15;
  inline bool has_aprnpointprice() const;
  inline void clear_aprnpointprice();
  static const int kAprnPointPriceFieldNumber = 15;
  inline double aprnpointprice() const;
  inline void set_aprnpointprice(double value);

  // optional double aprnCash = 16;
  inline bool has_aprncash() const;
  inline void clear_aprncash();
  static const int kAprnCashFieldNumber = 16;
  inline double aprncash() const;
  inline void set_aprncash(double value);

  // optional double refundablePrice = 17;
  inline bool has_refundableprice() const;
  inline void clear_refundableprice();
  static const int kRefundablePriceFieldNumber = 17;
  inline double refundableprice() const;
  inline void set_refundableprice(double value);

  // optional string productName = 18;
  inline bool has_productname() const;
  inline void clear_productname();
  static const int kProductNameFieldNumber = 18;
  inline const ::std::string& productname() const;
  inline void set_productname(const ::std::string& value);
  inline void set_productname(const char* value);
  inline void set_productname(const char* value, size_t size);
  inline ::std::string* mutable_productname();
  inline ::std::string* release_productname();
  inline void set_allocated_productname(::std::string* productname);

  // optional string rssSeq = 19;
  inline bool has_rssseq() const;
  inline void clear_rssseq();
  static const int kRssSeqFieldNumber = 19;
  inline const ::std::string& rssseq() const;
  inline void set_rssseq(const ::std::string& value);
  inline void set_rssseq(const char* value);
  inline void set_rssseq(const char* value, size_t size);
  inline ::std::string* mutable_rssseq();
  inline ::std::string* release_rssseq();
  inline void set_allocated_rssseq(::std::string* rssseq);

  // @@protoc_insertion_point(class_scope:ReturnGoodsInfo)
 private:
  inline void set_has_skuid();
  inline void clear_has_skuid();
  inline void set_has_productprice();
  inline void clear_has_productprice();
  inline void set_has_productqty();
  inline void clear_has_productqty();
  inline void set_has_returnqty();
  inline void clear_has_returnqty();
  inline void set_has_productmainurl();
  inline void clear_has_productmainurl();
  inline void set_has_sourceurl();
  inline void clear_has_sourceurl();
  inline void set_has_color();
  inline void clear_has_color();
  inline void set_has_size();
  inline void clear_has_size();
  inline void set_has_reason();
  inline void clear_has_reason();
  inline void set_has_aprnpromote();
  inline void clear_has_aprnpromote();
  inline void set_has_aprnvoucher();
  inline void clear_has_aprnvoucher();
  inline void set_has_shippingtax();
  inline void clear_has_shippingtax();
  inline void set_has_origprice();
  inline void clear_has_origprice();
  inline void set_has_aprnpoint();
  inline void clear_has_aprnpoint();
  inline void set_has_aprnpointprice();
  inline void clear_has_aprnpointprice();
  inline void set_has_aprncash();
  inline void clear_has_aprncash();
  inline void set_has_refundableprice();
  inline void clear_has_refundableprice();
  inline void set_has_productname();
  inline void clear_has_productname();
  inline void set_has_rssseq();
  inline void clear_has_rssseq();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* skuid_;
  double productprice_;
  ::google::protobuf::int32 productqty_;
  ::google::protobuf::int32 returnqty_;
  ::std::string* productmainurl_;
  ::std::string* sourceurl_;
  ::std::string* color_;
  ::std::string* size_;
  ::std::string* reason_;
  double aprnpromote_;
  double aprnvoucher_;
  double shippingtax_;
  double origprice_;
  double aprnpoint_;
  double aprnpointprice_;
  double aprncash_;
  double refundableprice_;
  ::std::string* productname_;
  ::std::string* rssseq_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_improtocol_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_improtocol_2eproto();
  #endif
  friend void protobuf_AssignDesc_improtocol_2eproto();
  friend void protobuf_ShutdownFile_improtocol_2eproto();

  void InitAsDefaultInstance();
  static ReturnGoodsInfo* default_instance_;
};
// -------------------------------------------------------------------

class ReturnOrder : public ::google::protobuf::MessageLite {
 public:
  ReturnOrder();
  virtual ~ReturnOrder();

  ReturnOrder(const ReturnOrder& from);

  inline ReturnOrder& operator=(const ReturnOrder& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ReturnOrder& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ReturnOrder* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ReturnOrder* other);

  // implements Message ----------------------------------------------

  ReturnOrder* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ReturnOrder& from);
  void MergeFrom(const ReturnOrder& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string rsSeq = 1;
  inline bool has_rsseq() const;
  inline void clear_rsseq();
  static const int kRsSeqFieldNumber = 1;
  inline const ::std::string& rsseq() const;
  inline void set_rsseq(const ::std::string& value);
  inline void set_rsseq(const char* value);
  inline void set_rsseq(const char* value, size_t size);
  inline ::std::string* mutable_rsseq();
  inline ::std::string* release_rsseq();
  inline void set_allocated_rsseq(::std::string* rsseq);

  // optional string ogNo = 2;
  inline bool has_ogno() const;
  inline void clear_ogno();
  static const int kOgNoFieldNumber = 2;
  inline const ::std::string& ogno() const;
  inline void set_ogno(const ::std::string& value);
  inline void set_ogno(const char* value);
  inline void set_ogno(const char* value, size_t size);
  inline ::std::string* mutable_ogno();
  inline ::std::string* release_ogno();
  inline void set_allocated_ogno(::std::string* ogno);

  // optional string ogsSeq = 3;
  inline bool has_ogsseq() const;
  inline void clear_ogsseq();
  static const int kOgsSeqFieldNumber = 3;
  inline const ::std::string& ogsseq() const;
  inline void set_ogsseq(const ::std::string& value);
  inline void set_ogsseq(const char* value);
  inline void set_ogsseq(const char* value, size_t size);
  inline ::std::string* mutable_ogsseq();
  inline ::std::string* release_ogsseq();
  inline void set_allocated_ogsseq(::std::string* ogsseq);

  // optional string applyDate = 4;
  inline bool has_applydate() const;
  inline void clear_applydate();
  static const int kApplyDateFieldNumber = 4;
  inline const ::std::string& applydate() const;
  inline void set_applydate(const ::std::string& value);
  inline void set_applydate(const char* value);
  inline void set_applydate(const char* value, size_t size);
  inline ::std::string* mutable_applydate();
  inline ::std::string* release_applydate();
  inline void set_allocated_applydate(::std::string* applydate);

  // optional double applyPrice = 5;
  inline bool has_applyprice() const;
  inline void clear_applyprice();
  static const int kApplyPriceFieldNumber = 5;
  inline double applyprice() const;
  inline void set_applyprice(double value);

  // optional string merchantId = 6;
  inline bool has_merchantid() const;
  inline void clear_merchantid();
  static const int kMerchantIdFieldNumber = 6;
  inline const ::std::string& merchantid() const;
  inline void set_merchantid(const ::std::string& value);
  inline void set_merchantid(const char* value);
  inline void set_merchantid(const char* value, size_t size);
  inline ::std::string* mutable_merchantid();
  inline ::std::string* release_merchantid();
  inline void set_allocated_merchantid(::std::string* merchantid);

  // optional string memGuid = 7;
  inline bool has_memguid() const;
  inline void clear_memguid();
  static const int kMemGuidFieldNumber = 7;
  inline const ::std::string& memguid() const;
  inline void set_memguid(const ::std::string& value);
  inline void set_memguid(const char* value);
  inline void set_memguid(const char* value, size_t size);
  inline ::std::string* mutable_memguid();
  inline ::std::string* release_memguid();
  inline void set_allocated_memguid(::std::string* memguid);

  // optional string buyername = 8;
  inline bool has_buyername() const;
  inline void clear_buyername();
  static const int kBuyernameFieldNumber = 8;
  inline const ::std::string& buyername() const;
  inline void set_buyername(const ::std::string& value);
  inline void set_buyername(const char* value);
  inline void set_buyername(const char* value, size_t size);
  inline ::std::string* mutable_buyername();
  inline ::std::string* release_buyername();
  inline void set_allocated_buyername(::std::string* buyername);

  // repeated .ReturnGoodsInfo goodslist = 25;
  inline int goodslist_size() const;
  inline void clear_goodslist();
  static const int kGoodslistFieldNumber = 25;
  inline const ::ReturnGoodsInfo& goodslist(int index) const;
  inline ::ReturnGoodsInfo* mutable_goodslist(int index);
  inline ::ReturnGoodsInfo* add_goodslist();
  inline const ::google::protobuf::RepeatedPtrField< ::ReturnGoodsInfo >&
      goodslist() const;
  inline ::google::protobuf::RepeatedPtrField< ::ReturnGoodsInfo >*
      mutable_goodslist();

  // @@protoc_insertion_point(class_scope:ReturnOrder)
 private:
  inline void set_has_rsseq();
  inline void clear_has_rsseq();
  inline void set_has_ogno();
  inline void clear_has_ogno();
  inline void set_has_ogsseq();
  inline void clear_has_ogsseq();
  inline void set_has_applydate();
  inline void clear_has_applydate();
  inline void set_has_applyprice();
  inline void clear_has_applyprice();
  inline void set_has_merchantid();
  inline void clear_has_merchantid();
  inline void set_has_memguid();
  inline void clear_has_memguid();
  inline void set_has_buyername();
  inline void clear_has_buyername();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* rsseq_;
  ::std::string* ogno_;
  ::std::string* ogsseq_;
  ::std::string* applydate_;
  double applyprice_;
  ::std::string* merchantid_;
  ::std::string* memguid_;
  ::std::string* buyername_;
  ::google::protobuf::RepeatedPtrField< ::ReturnGoodsInfo > goodslist_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_improtocol_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_improtocol_2eproto();
  #endif
  friend void protobuf_AssignDesc_improtocol_2eproto();
  friend void protobuf_ShutdownFile_improtocol_2eproto();

  void InitAsDefaultInstance();
  static ReturnOrder* default_instance_;
};
// -------------------------------------------------------------------

class MsgPushInd : public ::google::protobuf::MessageLite {
 public:
  MsgPushInd();
  virtual ~MsgPushInd();

  MsgPushInd(const MsgPushInd& from);

  inline MsgPushInd& operator=(const MsgPushInd& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const MsgPushInd& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const MsgPushInd* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(MsgPushInd* other);

  // implements Message ----------------------------------------------

  MsgPushInd* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MsgPushInd& from);
  void MergeFrom(const MsgPushInd& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .EuMsgPush mpType = 1;
  inline bool has_mptype() const;
  inline void clear_mptype();
  static const int kMpTypeFieldNumber = 1;
  inline ::EuMsgPush mptype() const;
  inline void set_mptype(::EuMsgPush value);

  // required bytes mpData = 2;
  inline bool has_mpdata() const;
  inline void clear_mpdata();
  static const int kMpDataFieldNumber = 2;
  inline const ::std::string& mpdata() const;
  inline void set_mpdata(const ::std::string& value);
  inline void set_mpdata(const char* value);
  inline void set_mpdata(const void* value, size_t size);
  inline ::std::string* mutable_mpdata();
  inline ::std::string* release_mpdata();
  inline void set_allocated_mpdata(::std::string* mpdata);

  // @@protoc_insertion_point(class_scope:MsgPushInd)
 private:
  inline void set_has_mptype();
  inline void clear_has_mptype();
  inline void set_has_mpdata();
  inline void clear_has_mpdata();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* mpdata_;
  int mptype_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_improtocol_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_improtocol_2eproto();
  #endif
  friend void protobuf_AssignDesc_improtocol_2eproto();
  friend void protobuf_ShutdownFile_improtocol_2eproto();

  void InitAsDefaultInstance();
  static MsgPushInd* default_instance_;
};
// -------------------------------------------------------------------

class csTeamInfoReq : public ::google::protobuf::MessageLite {
 public:
  csTeamInfoReq();
  virtual ~csTeamInfoReq();

  csTeamInfoReq(const csTeamInfoReq& from);

  inline csTeamInfoReq& operator=(const csTeamInfoReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const csTeamInfoReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const csTeamInfoReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(csTeamInfoReq* other);

  // implements Message ----------------------------------------------

  csTeamInfoReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const csTeamInfoReq& from);
  void MergeFrom(const csTeamInfoReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 csId = 1;
  inline bool has_csid() const;
  inline void clear_csid();
  static const int kCsIdFieldNumber = 1;
  inline ::google::protobuf::int32 csid() const;
  inline void set_csid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:csTeamInfoReq)
 private:
  inline void set_has_csid();
  inline void clear_has_csid();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 csid_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_improtocol_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_improtocol_2eproto();
  #endif
  friend void protobuf_AssignDesc_improtocol_2eproto();
  friend void protobuf_ShutdownFile_improtocol_2eproto();

  void InitAsDefaultInstance();
  static csTeamInfoReq* default_instance_;
};
// -------------------------------------------------------------------

class csTeamInfo : public ::google::protobuf::MessageLite {
 public:
  csTeamInfo();
  virtual ~csTeamInfo();

  csTeamInfo(const csTeamInfo& from);

  inline csTeamInfo& operator=(const csTeamInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const csTeamInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const csTeamInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(csTeamInfo* other);

  // implements Message ----------------------------------------------

  csTeamInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const csTeamInfo& from);
  void MergeFrom(const csTeamInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 csTeamid = 1;
  inline bool has_csteamid() const;
  inline void clear_csteamid();
  static const int kCsTeamidFieldNumber = 1;
  inline ::google::protobuf::int32 csteamid() const;
  inline void set_csteamid(::google::protobuf::int32 value);

  // required int32 csQueueLength = 2;
  inline bool has_csqueuelength() const;
  inline void clear_csqueuelength();
  static const int kCsQueueLengthFieldNumber = 2;
  inline ::google::protobuf::int32 csqueuelength() const;
  inline void set_csqueuelength(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:csTeamInfo)
 private:
  inline void set_has_csteamid();
  inline void clear_has_csteamid();
  inline void set_has_csqueuelength();
  inline void clear_has_csqueuelength();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 csteamid_;
  ::google::protobuf::int32 csqueuelength_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_improtocol_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_improtocol_2eproto();
  #endif
  friend void protobuf_AssignDesc_improtocol_2eproto();
  friend void protobuf_ShutdownFile_improtocol_2eproto();

  void InitAsDefaultInstance();
  static csTeamInfo* default_instance_;
};
// -------------------------------------------------------------------

class csTeamInfoAck : public ::google::protobuf::MessageLite {
 public:
  csTeamInfoAck();
  virtual ~csTeamInfoAck();

  csTeamInfoAck(const csTeamInfoAck& from);

  inline csTeamInfoAck& operator=(const csTeamInfoAck& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const csTeamInfoAck& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const csTeamInfoAck* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(csTeamInfoAck* other);

  // implements Message ----------------------------------------------

  csTeamInfoAck* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const csTeamInfoAck& from);
  void MergeFrom(const csTeamInfoAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 ret = 1;
  inline bool has_ret() const;
  inline void clear_ret();
  static const int kRetFieldNumber = 1;
  inline ::google::protobuf::int32 ret() const;
  inline void set_ret(::google::protobuf::int32 value);

  // required int32 csId = 2;
  inline bool has_csid() const;
  inline void clear_csid();
  static const int kCsIdFieldNumber = 2;
  inline ::google::protobuf::int32 csid() const;
  inline void set_csid(::google::protobuf::int32 value);

  // repeated .csTeamInfo teaminfo = 3;
  inline int teaminfo_size() const;
  inline void clear_teaminfo();
  static const int kTeaminfoFieldNumber = 3;
  inline const ::csTeamInfo& teaminfo(int index) const;
  inline ::csTeamInfo* mutable_teaminfo(int index);
  inline ::csTeamInfo* add_teaminfo();
  inline const ::google::protobuf::RepeatedPtrField< ::csTeamInfo >&
      teaminfo() const;
  inline ::google::protobuf::RepeatedPtrField< ::csTeamInfo >*
      mutable_teaminfo();

  // @@protoc_insertion_point(class_scope:csTeamInfoAck)
 private:
  inline void set_has_ret();
  inline void clear_has_ret();
  inline void set_has_csid();
  inline void clear_has_csid();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 ret_;
  ::google::protobuf::int32 csid_;
  ::google::protobuf::RepeatedPtrField< ::csTeamInfo > teaminfo_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_improtocol_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_improtocol_2eproto();
  #endif
  friend void protobuf_AssignDesc_improtocol_2eproto();
  friend void protobuf_ShutdownFile_improtocol_2eproto();

  void InitAsDefaultInstance();
  static csTeamInfoAck* default_instance_;
};
// -------------------------------------------------------------------

class csTeamQueueInfo : public ::google::protobuf::MessageLite {
 public:
  csTeamQueueInfo();
  virtual ~csTeamQueueInfo();

  csTeamQueueInfo(const csTeamQueueInfo& from);

  inline csTeamQueueInfo& operator=(const csTeamQueueInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const csTeamQueueInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const csTeamQueueInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(csTeamQueueInfo* other);

  // implements Message ----------------------------------------------

  csTeamQueueInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const csTeamQueueInfo& from);
  void MergeFrom(const csTeamQueueInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 ret = 1;
  inline bool has_ret() const;
  inline void clear_ret();
  static const int kRetFieldNumber = 1;
  inline ::google::protobuf::int32 ret() const;
  inline void set_ret(::google::protobuf::int32 value);

  // required int32 csTeamId = 2;
  inline bool has_csteamid() const;
  inline void clear_csteamid();
  static const int kCsTeamIdFieldNumber = 2;
  inline ::google::protobuf::int32 csteamid() const;
  inline void set_csteamid(::google::protobuf::int32 value);

  // required int32 csQueueLength = 3;
  inline bool has_csqueuelength() const;
  inline void clear_csqueuelength();
  static const int kCsQueueLengthFieldNumber = 3;
  inline ::google::protobuf::int32 csqueuelength() const;
  inline void set_csqueuelength(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:csTeamQueueInfo)
 private:
  inline void set_has_ret();
  inline void clear_has_ret();
  inline void set_has_csteamid();
  inline void clear_has_csteamid();
  inline void set_has_csqueuelength();
  inline void clear_has_csqueuelength();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 ret_;
  ::google::protobuf::int32 csteamid_;
  ::google::protobuf::int32 csqueuelength_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_improtocol_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_improtocol_2eproto();
  #endif
  friend void protobuf_AssignDesc_improtocol_2eproto();
  friend void protobuf_ShutdownFile_improtocol_2eproto();

  void InitAsDefaultInstance();
  static csTeamQueueInfo* default_instance_;
};
// ===================================================================


// ===================================================================

// XT_HEAD_PB

// optional int32 flag = 1;
inline bool XT_HEAD_PB::has_flag() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void XT_HEAD_PB::set_has_flag() {
  _has_bits_[0] |= 0x00000001u;
}
inline void XT_HEAD_PB::clear_has_flag() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void XT_HEAD_PB::clear_flag() {
  flag_ = 0;
  clear_has_flag();
}
inline ::google::protobuf::int32 XT_HEAD_PB::flag() const {
  // @@protoc_insertion_point(field_get:XT_HEAD_PB.flag)
  return flag_;
}
inline void XT_HEAD_PB::set_flag(::google::protobuf::int32 value) {
  set_has_flag();
  flag_ = value;
  // @@protoc_insertion_point(field_set:XT_HEAD_PB.flag)
}

// optional int32 from = 2;
inline bool XT_HEAD_PB::has_from() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void XT_HEAD_PB::set_has_from() {
  _has_bits_[0] |= 0x00000002u;
}
inline void XT_HEAD_PB::clear_has_from() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void XT_HEAD_PB::clear_from() {
  from_ = 0;
  clear_has_from();
}
inline ::google::protobuf::int32 XT_HEAD_PB::from() const {
  // @@protoc_insertion_point(field_get:XT_HEAD_PB.from)
  return from_;
}
inline void XT_HEAD_PB::set_from(::google::protobuf::int32 value) {
  set_has_from();
  from_ = value;
  // @@protoc_insertion_point(field_set:XT_HEAD_PB.from)
}

// optional int32 cmd = 3;
inline bool XT_HEAD_PB::has_cmd() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void XT_HEAD_PB::set_has_cmd() {
  _has_bits_[0] |= 0x00000004u;
}
inline void XT_HEAD_PB::clear_has_cmd() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void XT_HEAD_PB::clear_cmd() {
  cmd_ = 0;
  clear_has_cmd();
}
inline ::google::protobuf::int32 XT_HEAD_PB::cmd() const {
  // @@protoc_insertion_point(field_get:XT_HEAD_PB.cmd)
  return cmd_;
}
inline void XT_HEAD_PB::set_cmd(::google::protobuf::int32 value) {
  set_has_cmd();
  cmd_ = value;
  // @@protoc_insertion_point(field_set:XT_HEAD_PB.cmd)
}

// optional int32 seq = 4;
inline bool XT_HEAD_PB::has_seq() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void XT_HEAD_PB::set_has_seq() {
  _has_bits_[0] |= 0x00000008u;
}
inline void XT_HEAD_PB::clear_has_seq() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void XT_HEAD_PB::clear_seq() {
  seq_ = 0;
  clear_has_seq();
}
inline ::google::protobuf::int32 XT_HEAD_PB::seq() const {
  // @@protoc_insertion_point(field_get:XT_HEAD_PB.seq)
  return seq_;
}
inline void XT_HEAD_PB::set_seq(::google::protobuf::int32 value) {
  set_has_seq();
  seq_ = value;
  // @@protoc_insertion_point(field_set:XT_HEAD_PB.seq)
}

// optional int32 sid = 5;
inline bool XT_HEAD_PB::has_sid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void XT_HEAD_PB::set_has_sid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void XT_HEAD_PB::clear_has_sid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void XT_HEAD_PB::clear_sid() {
  sid_ = 0;
  clear_has_sid();
}
inline ::google::protobuf::int32 XT_HEAD_PB::sid() const {
  // @@protoc_insertion_point(field_get:XT_HEAD_PB.sid)
  return sid_;
}
inline void XT_HEAD_PB::set_sid(::google::protobuf::int32 value) {
  set_has_sid();
  sid_ = value;
  // @@protoc_insertion_point(field_set:XT_HEAD_PB.sid)
}

// optional int32 dtype = 6;
inline bool XT_HEAD_PB::has_dtype() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void XT_HEAD_PB::set_has_dtype() {
  _has_bits_[0] |= 0x00000020u;
}
inline void XT_HEAD_PB::clear_has_dtype() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void XT_HEAD_PB::clear_dtype() {
  dtype_ = 0;
  clear_has_dtype();
}
inline ::google::protobuf::int32 XT_HEAD_PB::dtype() const {
  // @@protoc_insertion_point(field_get:XT_HEAD_PB.dtype)
  return dtype_;
}
inline void XT_HEAD_PB::set_dtype(::google::protobuf::int32 value) {
  set_has_dtype();
  dtype_ = value;
  // @@protoc_insertion_point(field_set:XT_HEAD_PB.dtype)
}

// optional int32 did = 7;
inline bool XT_HEAD_PB::has_did() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void XT_HEAD_PB::set_has_did() {
  _has_bits_[0] |= 0x00000040u;
}
inline void XT_HEAD_PB::clear_has_did() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void XT_HEAD_PB::clear_did() {
  did_ = 0;
  clear_has_did();
}
inline ::google::protobuf::int32 XT_HEAD_PB::did() const {
  // @@protoc_insertion_point(field_get:XT_HEAD_PB.did)
  return did_;
}
inline void XT_HEAD_PB::set_did(::google::protobuf::int32 value) {
  set_has_did();
  did_ = value;
  // @@protoc_insertion_point(field_set:XT_HEAD_PB.did)
}

// -------------------------------------------------------------------

// DataPacket

// required .XT_HEAD_PB head = 1;
inline bool DataPacket::has_head() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DataPacket::set_has_head() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DataPacket::clear_has_head() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DataPacket::clear_head() {
  if (head_ != NULL) head_->::XT_HEAD_PB::Clear();
  clear_has_head();
}
inline const ::XT_HEAD_PB& DataPacket::head() const {
  // @@protoc_insertion_point(field_get:DataPacket.head)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return head_ != NULL ? *head_ : *default_instance().head_;
#else
  return head_ != NULL ? *head_ : *default_instance_->head_;
#endif
}
inline ::XT_HEAD_PB* DataPacket::mutable_head() {
  set_has_head();
  if (head_ == NULL) head_ = new ::XT_HEAD_PB;
  // @@protoc_insertion_point(field_mutable:DataPacket.head)
  return head_;
}
inline ::XT_HEAD_PB* DataPacket::release_head() {
  clear_has_head();
  ::XT_HEAD_PB* temp = head_;
  head_ = NULL;
  return temp;
}
inline void DataPacket::set_allocated_head(::XT_HEAD_PB* head) {
  delete head_;
  head_ = head;
  if (head) {
    set_has_head();
  } else {
    clear_has_head();
  }
  // @@protoc_insertion_point(field_set_allocated:DataPacket.head)
}

// required bytes data = 2;
inline bool DataPacket::has_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DataPacket::set_has_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DataPacket::clear_has_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DataPacket::clear_data() {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& DataPacket::data() const {
  // @@protoc_insertion_point(field_get:DataPacket.data)
  return *data_;
}
inline void DataPacket::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(value);
  // @@protoc_insertion_point(field_set:DataPacket.data)
}
inline void DataPacket::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(value);
  // @@protoc_insertion_point(field_set_char:DataPacket.data)
}
inline void DataPacket::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DataPacket.data)
}
inline ::std::string* DataPacket::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DataPacket.data)
  return data_;
}
inline ::std::string* DataPacket::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DataPacket::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DataPacket.data)
}

// -------------------------------------------------------------------

// MsgInfo

// optional uint32 msgid = 1;
inline bool MsgInfo::has_msgid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MsgInfo::set_has_msgid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MsgInfo::clear_has_msgid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MsgInfo::clear_msgid() {
  msgid_ = 0u;
  clear_has_msgid();
}
inline ::google::protobuf::uint32 MsgInfo::msgid() const {
  // @@protoc_insertion_point(field_get:MsgInfo.msgid)
  return msgid_;
}
inline void MsgInfo::set_msgid(::google::protobuf::uint32 value) {
  set_has_msgid();
  msgid_ = value;
  // @@protoc_insertion_point(field_set:MsgInfo.msgid)
}

// optional string uuid = 2;
inline bool MsgInfo::has_uuid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MsgInfo::set_has_uuid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MsgInfo::clear_has_uuid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MsgInfo::clear_uuid() {
  if (uuid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    uuid_->clear();
  }
  clear_has_uuid();
}
inline const ::std::string& MsgInfo::uuid() const {
  // @@protoc_insertion_point(field_get:MsgInfo.uuid)
  return *uuid_;
}
inline void MsgInfo::set_uuid(const ::std::string& value) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(value);
  // @@protoc_insertion_point(field_set:MsgInfo.uuid)
}
inline void MsgInfo::set_uuid(const char* value) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(value);
  // @@protoc_insertion_point(field_set_char:MsgInfo.uuid)
}
inline void MsgInfo::set_uuid(const char* value, size_t size) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:MsgInfo.uuid)
}
inline ::std::string* MsgInfo::mutable_uuid() {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    uuid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:MsgInfo.uuid)
  return uuid_;
}
inline ::std::string* MsgInfo::release_uuid() {
  clear_has_uuid();
  if (uuid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = uuid_;
    uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MsgInfo::set_allocated_uuid(::std::string* uuid) {
  if (uuid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete uuid_;
  }
  if (uuid) {
    set_has_uuid();
    uuid_ = uuid;
  } else {
    clear_has_uuid();
    uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:MsgInfo.uuid)
}

// optional uint32 fromid = 3;
inline bool MsgInfo::has_fromid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MsgInfo::set_has_fromid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MsgInfo::clear_has_fromid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MsgInfo::clear_fromid() {
  fromid_ = 0u;
  clear_has_fromid();
}
inline ::google::protobuf::uint32 MsgInfo::fromid() const {
  // @@protoc_insertion_point(field_get:MsgInfo.fromid)
  return fromid_;
}
inline void MsgInfo::set_fromid(::google::protobuf::uint32 value) {
  set_has_fromid();
  fromid_ = value;
  // @@protoc_insertion_point(field_set:MsgInfo.fromid)
}

// optional uint32 toid = 4;
inline bool MsgInfo::has_toid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MsgInfo::set_has_toid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MsgInfo::clear_has_toid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MsgInfo::clear_toid() {
  toid_ = 0u;
  clear_has_toid();
}
inline ::google::protobuf::uint32 MsgInfo::toid() const {
  // @@protoc_insertion_point(field_get:MsgInfo.toid)
  return toid_;
}
inline void MsgInfo::set_toid(::google::protobuf::uint32 value) {
  set_has_toid();
  toid_ = value;
  // @@protoc_insertion_point(field_set:MsgInfo.toid)
}

// optional uint32 send_time = 5;
inline bool MsgInfo::has_send_time() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MsgInfo::set_has_send_time() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MsgInfo::clear_has_send_time() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MsgInfo::clear_send_time() {
  send_time_ = 0u;
  clear_has_send_time();
}
inline ::google::protobuf::uint32 MsgInfo::send_time() const {
  // @@protoc_insertion_point(field_get:MsgInfo.send_time)
  return send_time_;
}
inline void MsgInfo::set_send_time(::google::protobuf::uint32 value) {
  set_has_send_time();
  send_time_ = value;
  // @@protoc_insertion_point(field_set:MsgInfo.send_time)
}

// optional string data = 6;
inline bool MsgInfo::has_data() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MsgInfo::set_has_data() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MsgInfo::clear_has_data() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MsgInfo::clear_data() {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& MsgInfo::data() const {
  // @@protoc_insertion_point(field_get:MsgInfo.data)
  return *data_;
}
inline void MsgInfo::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(value);
  // @@protoc_insertion_point(field_set:MsgInfo.data)
}
inline void MsgInfo::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(value);
  // @@protoc_insertion_point(field_set_char:MsgInfo.data)
}
inline void MsgInfo::set_data(const char* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:MsgInfo.data)
}
inline ::std::string* MsgInfo::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:MsgInfo.data)
  return data_;
}
inline ::std::string* MsgInfo::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MsgInfo::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:MsgInfo.data)
}

// optional string fromnickname = 7;
inline bool MsgInfo::has_fromnickname() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MsgInfo::set_has_fromnickname() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MsgInfo::clear_has_fromnickname() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MsgInfo::clear_fromnickname() {
  if (fromnickname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fromnickname_->clear();
  }
  clear_has_fromnickname();
}
inline const ::std::string& MsgInfo::fromnickname() const {
  // @@protoc_insertion_point(field_get:MsgInfo.fromnickname)
  return *fromnickname_;
}
inline void MsgInfo::set_fromnickname(const ::std::string& value) {
  set_has_fromnickname();
  if (fromnickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fromnickname_ = new ::std::string;
  }
  fromnickname_->assign(value);
  // @@protoc_insertion_point(field_set:MsgInfo.fromnickname)
}
inline void MsgInfo::set_fromnickname(const char* value) {
  set_has_fromnickname();
  if (fromnickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fromnickname_ = new ::std::string;
  }
  fromnickname_->assign(value);
  // @@protoc_insertion_point(field_set_char:MsgInfo.fromnickname)
}
inline void MsgInfo::set_fromnickname(const char* value, size_t size) {
  set_has_fromnickname();
  if (fromnickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fromnickname_ = new ::std::string;
  }
  fromnickname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:MsgInfo.fromnickname)
}
inline ::std::string* MsgInfo::mutable_fromnickname() {
  set_has_fromnickname();
  if (fromnickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fromnickname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:MsgInfo.fromnickname)
  return fromnickname_;
}
inline ::std::string* MsgInfo::release_fromnickname() {
  clear_has_fromnickname();
  if (fromnickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = fromnickname_;
    fromnickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MsgInfo::set_allocated_fromnickname(::std::string* fromnickname) {
  if (fromnickname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete fromnickname_;
  }
  if (fromnickname) {
    set_has_fromnickname();
    fromnickname_ = fromnickname;
  } else {
    clear_has_fromnickname();
    fromnickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:MsgInfo.fromnickname)
}

// optional uint32 fontSize = 8;
inline bool MsgInfo::has_fontsize() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MsgInfo::set_has_fontsize() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MsgInfo::clear_has_fontsize() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MsgInfo::clear_fontsize() {
  fontsize_ = 0u;
  clear_has_fontsize();
}
inline ::google::protobuf::uint32 MsgInfo::fontsize() const {
  // @@protoc_insertion_point(field_get:MsgInfo.fontSize)
  return fontsize_;
}
inline void MsgInfo::set_fontsize(::google::protobuf::uint32 value) {
  set_has_fontsize();
  fontsize_ = value;
  // @@protoc_insertion_point(field_set:MsgInfo.fontSize)
}

// optional uint32 fontColor = 9;
inline bool MsgInfo::has_fontcolor() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void MsgInfo::set_has_fontcolor() {
  _has_bits_[0] |= 0x00000100u;
}
inline void MsgInfo::clear_has_fontcolor() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void MsgInfo::clear_fontcolor() {
  fontcolor_ = 0u;
  clear_has_fontcolor();
}
inline ::google::protobuf::uint32 MsgInfo::fontcolor() const {
  // @@protoc_insertion_point(field_get:MsgInfo.fontColor)
  return fontcolor_;
}
inline void MsgInfo::set_fontcolor(::google::protobuf::uint32 value) {
  set_has_fontcolor();
  fontcolor_ = value;
  // @@protoc_insertion_point(field_set:MsgInfo.fontColor)
}

// optional uint32 fontStyle = 10;
inline bool MsgInfo::has_fontstyle() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void MsgInfo::set_has_fontstyle() {
  _has_bits_[0] |= 0x00000200u;
}
inline void MsgInfo::clear_has_fontstyle() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void MsgInfo::clear_fontstyle() {
  fontstyle_ = 0u;
  clear_has_fontstyle();
}
inline ::google::protobuf::uint32 MsgInfo::fontstyle() const {
  // @@protoc_insertion_point(field_get:MsgInfo.fontStyle)
  return fontstyle_;
}
inline void MsgInfo::set_fontstyle(::google::protobuf::uint32 value) {
  set_has_fontstyle();
  fontstyle_ = value;
  // @@protoc_insertion_point(field_set:MsgInfo.fontStyle)
}

// optional string fontName = 11;
inline bool MsgInfo::has_fontname() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void MsgInfo::set_has_fontname() {
  _has_bits_[0] |= 0x00000400u;
}
inline void MsgInfo::clear_has_fontname() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void MsgInfo::clear_fontname() {
  if (fontname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fontname_->clear();
  }
  clear_has_fontname();
}
inline const ::std::string& MsgInfo::fontname() const {
  // @@protoc_insertion_point(field_get:MsgInfo.fontName)
  return *fontname_;
}
inline void MsgInfo::set_fontname(const ::std::string& value) {
  set_has_fontname();
  if (fontname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fontname_ = new ::std::string;
  }
  fontname_->assign(value);
  // @@protoc_insertion_point(field_set:MsgInfo.fontName)
}
inline void MsgInfo::set_fontname(const char* value) {
  set_has_fontname();
  if (fontname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fontname_ = new ::std::string;
  }
  fontname_->assign(value);
  // @@protoc_insertion_point(field_set_char:MsgInfo.fontName)
}
inline void MsgInfo::set_fontname(const char* value, size_t size) {
  set_has_fontname();
  if (fontname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fontname_ = new ::std::string;
  }
  fontname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:MsgInfo.fontName)
}
inline ::std::string* MsgInfo::mutable_fontname() {
  set_has_fontname();
  if (fontname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fontname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:MsgInfo.fontName)
  return fontname_;
}
inline ::std::string* MsgInfo::release_fontname() {
  clear_has_fontname();
  if (fontname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = fontname_;
    fontname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MsgInfo::set_allocated_fontname(::std::string* fontname) {
  if (fontname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete fontname_;
  }
  if (fontname) {
    set_has_fontname();
    fontname_ = fontname;
  } else {
    clear_has_fontname();
    fontname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:MsgInfo.fontName)
}

// -------------------------------------------------------------------

// MsgList

// optional uint32 ret = 1;
inline bool MsgList::has_ret() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MsgList::set_has_ret() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MsgList::clear_has_ret() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MsgList::clear_ret() {
  ret_ = 0u;
  clear_has_ret();
}
inline ::google::protobuf::uint32 MsgList::ret() const {
  // @@protoc_insertion_point(field_get:MsgList.ret)
  return ret_;
}
inline void MsgList::set_ret(::google::protobuf::uint32 value) {
  set_has_ret();
  ret_ = value;
  // @@protoc_insertion_point(field_set:MsgList.ret)
}

// repeated .MsgInfo msglist = 15;
inline int MsgList::msglist_size() const {
  return msglist_.size();
}
inline void MsgList::clear_msglist() {
  msglist_.Clear();
}
inline const ::MsgInfo& MsgList::msglist(int index) const {
  // @@protoc_insertion_point(field_get:MsgList.msglist)
  return msglist_.Get(index);
}
inline ::MsgInfo* MsgList::mutable_msglist(int index) {
  // @@protoc_insertion_point(field_mutable:MsgList.msglist)
  return msglist_.Mutable(index);
}
inline ::MsgInfo* MsgList::add_msglist() {
  // @@protoc_insertion_point(field_add:MsgList.msglist)
  return msglist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::MsgInfo >&
MsgList::msglist() const {
  // @@protoc_insertion_point(field_list:MsgList.msglist)
  return msglist_;
}
inline ::google::protobuf::RepeatedPtrField< ::MsgInfo >*
MsgList::mutable_msglist() {
  // @@protoc_insertion_point(field_mutable_list:MsgList.msglist)
  return &msglist_;
}

// -------------------------------------------------------------------

// UserOfflineIND

// required uint32 userid = 1;
inline bool UserOfflineIND::has_userid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserOfflineIND::set_has_userid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserOfflineIND::clear_has_userid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserOfflineIND::clear_userid() {
  userid_ = 0u;
  clear_has_userid();
}
inline ::google::protobuf::uint32 UserOfflineIND::userid() const {
  // @@protoc_insertion_point(field_get:UserOfflineIND.userid)
  return userid_;
}
inline void UserOfflineIND::set_userid(::google::protobuf::uint32 value) {
  set_has_userid();
  userid_ = value;
  // @@protoc_insertion_point(field_set:UserOfflineIND.userid)
}

// -------------------------------------------------------------------

// Buf_ServerSend

// required uint32 packetCount = 1;
inline bool Buf_ServerSend::has_packetcount() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Buf_ServerSend::set_has_packetcount() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Buf_ServerSend::clear_has_packetcount() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Buf_ServerSend::clear_packetcount() {
  packetcount_ = 0u;
  clear_has_packetcount();
}
inline ::google::protobuf::uint32 Buf_ServerSend::packetcount() const {
  // @@protoc_insertion_point(field_get:Buf_ServerSend.packetCount)
  return packetcount_;
}
inline void Buf_ServerSend::set_packetcount(::google::protobuf::uint32 value) {
  set_has_packetcount();
  packetcount_ = value;
  // @@protoc_insertion_point(field_set:Buf_ServerSend.packetCount)
}

// required uint32 idxPacket = 2;
inline bool Buf_ServerSend::has_idxpacket() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Buf_ServerSend::set_has_idxpacket() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Buf_ServerSend::clear_has_idxpacket() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Buf_ServerSend::clear_idxpacket() {
  idxpacket_ = 0u;
  clear_has_idxpacket();
}
inline ::google::protobuf::uint32 Buf_ServerSend::idxpacket() const {
  // @@protoc_insertion_point(field_get:Buf_ServerSend.idxPacket)
  return idxpacket_;
}
inline void Buf_ServerSend::set_idxpacket(::google::protobuf::uint32 value) {
  set_has_idxpacket();
  idxpacket_ = value;
  // @@protoc_insertion_point(field_set:Buf_ServerSend.idxPacket)
}

// required string bufUnitIdx = 3;
inline bool Buf_ServerSend::has_bufunitidx() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Buf_ServerSend::set_has_bufunitidx() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Buf_ServerSend::clear_has_bufunitidx() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Buf_ServerSend::clear_bufunitidx() {
  if (bufunitidx_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bufunitidx_->clear();
  }
  clear_has_bufunitidx();
}
inline const ::std::string& Buf_ServerSend::bufunitidx() const {
  // @@protoc_insertion_point(field_get:Buf_ServerSend.bufUnitIdx)
  return *bufunitidx_;
}
inline void Buf_ServerSend::set_bufunitidx(const ::std::string& value) {
  set_has_bufunitidx();
  if (bufunitidx_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bufunitidx_ = new ::std::string;
  }
  bufunitidx_->assign(value);
  // @@protoc_insertion_point(field_set:Buf_ServerSend.bufUnitIdx)
}
inline void Buf_ServerSend::set_bufunitidx(const char* value) {
  set_has_bufunitidx();
  if (bufunitidx_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bufunitidx_ = new ::std::string;
  }
  bufunitidx_->assign(value);
  // @@protoc_insertion_point(field_set_char:Buf_ServerSend.bufUnitIdx)
}
inline void Buf_ServerSend::set_bufunitidx(const char* value, size_t size) {
  set_has_bufunitidx();
  if (bufunitidx_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bufunitidx_ = new ::std::string;
  }
  bufunitidx_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Buf_ServerSend.bufUnitIdx)
}
inline ::std::string* Buf_ServerSend::mutable_bufunitidx() {
  set_has_bufunitidx();
  if (bufunitidx_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bufunitidx_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Buf_ServerSend.bufUnitIdx)
  return bufunitidx_;
}
inline ::std::string* Buf_ServerSend::release_bufunitidx() {
  clear_has_bufunitidx();
  if (bufunitidx_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = bufunitidx_;
    bufunitidx_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Buf_ServerSend::set_allocated_bufunitidx(::std::string* bufunitidx) {
  if (bufunitidx_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete bufunitidx_;
  }
  if (bufunitidx) {
    set_has_bufunitidx();
    bufunitidx_ = bufunitidx;
  } else {
    clear_has_bufunitidx();
    bufunitidx_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Buf_ServerSend.bufUnitIdx)
}

// required .EN_BUFLOCATION buflocation = 4;
inline bool Buf_ServerSend::has_buflocation() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Buf_ServerSend::set_has_buflocation() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Buf_ServerSend::clear_has_buflocation() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Buf_ServerSend::clear_buflocation() {
  buflocation_ = 0;
  clear_has_buflocation();
}
inline ::EN_BUFLOCATION Buf_ServerSend::buflocation() const {
  // @@protoc_insertion_point(field_get:Buf_ServerSend.buflocation)
  return static_cast< ::EN_BUFLOCATION >(buflocation_);
}
inline void Buf_ServerSend::set_buflocation(::EN_BUFLOCATION value) {
  assert(::EN_BUFLOCATION_IsValid(value));
  set_has_buflocation();
  buflocation_ = value;
  // @@protoc_insertion_point(field_set:Buf_ServerSend.buflocation)
}

// required bytes packetData = 5;
inline bool Buf_ServerSend::has_packetdata() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Buf_ServerSend::set_has_packetdata() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Buf_ServerSend::clear_has_packetdata() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Buf_ServerSend::clear_packetdata() {
  if (packetdata_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    packetdata_->clear();
  }
  clear_has_packetdata();
}
inline const ::std::string& Buf_ServerSend::packetdata() const {
  // @@protoc_insertion_point(field_get:Buf_ServerSend.packetData)
  return *packetdata_;
}
inline void Buf_ServerSend::set_packetdata(const ::std::string& value) {
  set_has_packetdata();
  if (packetdata_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    packetdata_ = new ::std::string;
  }
  packetdata_->assign(value);
  // @@protoc_insertion_point(field_set:Buf_ServerSend.packetData)
}
inline void Buf_ServerSend::set_packetdata(const char* value) {
  set_has_packetdata();
  if (packetdata_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    packetdata_ = new ::std::string;
  }
  packetdata_->assign(value);
  // @@protoc_insertion_point(field_set_char:Buf_ServerSend.packetData)
}
inline void Buf_ServerSend::set_packetdata(const void* value, size_t size) {
  set_has_packetdata();
  if (packetdata_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    packetdata_ = new ::std::string;
  }
  packetdata_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Buf_ServerSend.packetData)
}
inline ::std::string* Buf_ServerSend::mutable_packetdata() {
  set_has_packetdata();
  if (packetdata_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    packetdata_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Buf_ServerSend.packetData)
  return packetdata_;
}
inline ::std::string* Buf_ServerSend::release_packetdata() {
  clear_has_packetdata();
  if (packetdata_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = packetdata_;
    packetdata_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Buf_ServerSend::set_allocated_packetdata(::std::string* packetdata) {
  if (packetdata_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete packetdata_;
  }
  if (packetdata) {
    set_has_packetdata();
    packetdata_ = packetdata;
  } else {
    clear_has_packetdata();
    packetdata_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Buf_ServerSend.packetData)
}

// -------------------------------------------------------------------

// Buf_ClientSend

// required uint32 idxPacketReq = 1;
inline bool Buf_ClientSend::has_idxpacketreq() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Buf_ClientSend::set_has_idxpacketreq() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Buf_ClientSend::clear_has_idxpacketreq() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Buf_ClientSend::clear_idxpacketreq() {
  idxpacketreq_ = 0u;
  clear_has_idxpacketreq();
}
inline ::google::protobuf::uint32 Buf_ClientSend::idxpacketreq() const {
  // @@protoc_insertion_point(field_get:Buf_ClientSend.idxPacketReq)
  return idxpacketreq_;
}
inline void Buf_ClientSend::set_idxpacketreq(::google::protobuf::uint32 value) {
  set_has_idxpacketreq();
  idxpacketreq_ = value;
  // @@protoc_insertion_point(field_set:Buf_ClientSend.idxPacketReq)
}

// required string bufUnitIdx = 2;
inline bool Buf_ClientSend::has_bufunitidx() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Buf_ClientSend::set_has_bufunitidx() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Buf_ClientSend::clear_has_bufunitidx() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Buf_ClientSend::clear_bufunitidx() {
  if (bufunitidx_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bufunitidx_->clear();
  }
  clear_has_bufunitidx();
}
inline const ::std::string& Buf_ClientSend::bufunitidx() const {
  // @@protoc_insertion_point(field_get:Buf_ClientSend.bufUnitIdx)
  return *bufunitidx_;
}
inline void Buf_ClientSend::set_bufunitidx(const ::std::string& value) {
  set_has_bufunitidx();
  if (bufunitidx_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bufunitidx_ = new ::std::string;
  }
  bufunitidx_->assign(value);
  // @@protoc_insertion_point(field_set:Buf_ClientSend.bufUnitIdx)
}
inline void Buf_ClientSend::set_bufunitidx(const char* value) {
  set_has_bufunitidx();
  if (bufunitidx_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bufunitidx_ = new ::std::string;
  }
  bufunitidx_->assign(value);
  // @@protoc_insertion_point(field_set_char:Buf_ClientSend.bufUnitIdx)
}
inline void Buf_ClientSend::set_bufunitidx(const char* value, size_t size) {
  set_has_bufunitidx();
  if (bufunitidx_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bufunitidx_ = new ::std::string;
  }
  bufunitidx_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Buf_ClientSend.bufUnitIdx)
}
inline ::std::string* Buf_ClientSend::mutable_bufunitidx() {
  set_has_bufunitidx();
  if (bufunitidx_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bufunitidx_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Buf_ClientSend.bufUnitIdx)
  return bufunitidx_;
}
inline ::std::string* Buf_ClientSend::release_bufunitidx() {
  clear_has_bufunitidx();
  if (bufunitidx_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = bufunitidx_;
    bufunitidx_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Buf_ClientSend::set_allocated_bufunitidx(::std::string* bufunitidx) {
  if (bufunitidx_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete bufunitidx_;
  }
  if (bufunitidx) {
    set_has_bufunitidx();
    bufunitidx_ = bufunitidx;
  } else {
    clear_has_bufunitidx();
    bufunitidx_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Buf_ClientSend.bufUnitIdx)
}

// required .EN_BUFLOCATION buflocation = 3;
inline bool Buf_ClientSend::has_buflocation() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Buf_ClientSend::set_has_buflocation() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Buf_ClientSend::clear_has_buflocation() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Buf_ClientSend::clear_buflocation() {
  buflocation_ = 0;
  clear_has_buflocation();
}
inline ::EN_BUFLOCATION Buf_ClientSend::buflocation() const {
  // @@protoc_insertion_point(field_get:Buf_ClientSend.buflocation)
  return static_cast< ::EN_BUFLOCATION >(buflocation_);
}
inline void Buf_ClientSend::set_buflocation(::EN_BUFLOCATION value) {
  assert(::EN_BUFLOCATION_IsValid(value));
  set_has_buflocation();
  buflocation_ = value;
  // @@protoc_insertion_point(field_set:Buf_ClientSend.buflocation)
}

// -------------------------------------------------------------------

// BaseReq

// required uint32 userid = 1;
inline bool BaseReq::has_userid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BaseReq::set_has_userid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BaseReq::clear_has_userid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BaseReq::clear_userid() {
  userid_ = 0u;
  clear_has_userid();
}
inline ::google::protobuf::uint32 BaseReq::userid() const {
  // @@protoc_insertion_point(field_get:BaseReq.userid)
  return userid_;
}
inline void BaseReq::set_userid(::google::protobuf::uint32 value) {
  set_has_userid();
  userid_ = value;
  // @@protoc_insertion_point(field_set:BaseReq.userid)
}

// -------------------------------------------------------------------

// MsgRemindAck

// optional .REMIND_TYPE neworder = 1 [default = RT_RECEIVE_AND_POPMSG];
inline bool MsgRemindAck::has_neworder() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MsgRemindAck::set_has_neworder() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MsgRemindAck::clear_has_neworder() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MsgRemindAck::clear_neworder() {
  neworder_ = 1;
  clear_has_neworder();
}
inline ::REMIND_TYPE MsgRemindAck::neworder() const {
  // @@protoc_insertion_point(field_get:MsgRemindAck.neworder)
  return static_cast< ::REMIND_TYPE >(neworder_);
}
inline void MsgRemindAck::set_neworder(::REMIND_TYPE value) {
  assert(::REMIND_TYPE_IsValid(value));
  set_has_neworder();
  neworder_ = value;
  // @@protoc_insertion_point(field_set:MsgRemindAck.neworder)
}

// optional .REMIND_TYPE payorder = 2 [default = RT_RECEIVE_AND_POPMSG];
inline bool MsgRemindAck::has_payorder() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MsgRemindAck::set_has_payorder() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MsgRemindAck::clear_has_payorder() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MsgRemindAck::clear_payorder() {
  payorder_ = 1;
  clear_has_payorder();
}
inline ::REMIND_TYPE MsgRemindAck::payorder() const {
  // @@protoc_insertion_point(field_get:MsgRemindAck.payorder)
  return static_cast< ::REMIND_TYPE >(payorder_);
}
inline void MsgRemindAck::set_payorder(::REMIND_TYPE value) {
  assert(::REMIND_TYPE_IsValid(value));
  set_has_payorder();
  payorder_ = value;
  // @@protoc_insertion_point(field_set:MsgRemindAck.payorder)
}

// optional .REMIND_TYPE goodscomment = 3 [default = RT_RECEIVE_AND_POPMSG];
inline bool MsgRemindAck::has_goodscomment() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MsgRemindAck::set_has_goodscomment() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MsgRemindAck::clear_has_goodscomment() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MsgRemindAck::clear_goodscomment() {
  goodscomment_ = 1;
  clear_has_goodscomment();
}
inline ::REMIND_TYPE MsgRemindAck::goodscomment() const {
  // @@protoc_insertion_point(field_get:MsgRemindAck.goodscomment)
  return static_cast< ::REMIND_TYPE >(goodscomment_);
}
inline void MsgRemindAck::set_goodscomment(::REMIND_TYPE value) {
  assert(::REMIND_TYPE_IsValid(value));
  set_has_goodscomment();
  goodscomment_ = value;
  // @@protoc_insertion_point(field_set:MsgRemindAck.goodscomment)
}

// optional .REMIND_TYPE returnorder = 4 [default = RT_RECEIVE_AND_POPMSG];
inline bool MsgRemindAck::has_returnorder() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MsgRemindAck::set_has_returnorder() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MsgRemindAck::clear_has_returnorder() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MsgRemindAck::clear_returnorder() {
  returnorder_ = 1;
  clear_has_returnorder();
}
inline ::REMIND_TYPE MsgRemindAck::returnorder() const {
  // @@protoc_insertion_point(field_get:MsgRemindAck.returnorder)
  return static_cast< ::REMIND_TYPE >(returnorder_);
}
inline void MsgRemindAck::set_returnorder(::REMIND_TYPE value) {
  assert(::REMIND_TYPE_IsValid(value));
  set_has_returnorder();
  returnorder_ = value;
  // @@protoc_insertion_point(field_set:MsgRemindAck.returnorder)
}

// -------------------------------------------------------------------

// CsUpdateOperReq

// required .CS_UPDATE_OPER updateoper = 1;
inline bool CsUpdateOperReq::has_updateoper() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CsUpdateOperReq::set_has_updateoper() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CsUpdateOperReq::clear_has_updateoper() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CsUpdateOperReq::clear_updateoper() {
  updateoper_ = 1;
  clear_has_updateoper();
}
inline ::CS_UPDATE_OPER CsUpdateOperReq::updateoper() const {
  // @@protoc_insertion_point(field_get:CsUpdateOperReq.updateoper)
  return static_cast< ::CS_UPDATE_OPER >(updateoper_);
}
inline void CsUpdateOperReq::set_updateoper(::CS_UPDATE_OPER value) {
  assert(::CS_UPDATE_OPER_IsValid(value));
  set_has_updateoper();
  updateoper_ = value;
  // @@protoc_insertion_point(field_set:CsUpdateOperReq.updateoper)
}

// required uint32 csid = 2;
inline bool CsUpdateOperReq::has_csid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CsUpdateOperReq::set_has_csid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CsUpdateOperReq::clear_has_csid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CsUpdateOperReq::clear_csid() {
  csid_ = 0u;
  clear_has_csid();
}
inline ::google::protobuf::uint32 CsUpdateOperReq::csid() const {
  // @@protoc_insertion_point(field_get:CsUpdateOperReq.csid)
  return csid_;
}
inline void CsUpdateOperReq::set_csid(::google::protobuf::uint32 value) {
  set_has_csid();
  csid_ = value;
  // @@protoc_insertion_point(field_set:CsUpdateOperReq.csid)
}

// required uint32 custid = 3;
inline bool CsUpdateOperReq::has_custid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CsUpdateOperReq::set_has_custid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CsUpdateOperReq::clear_has_custid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CsUpdateOperReq::clear_custid() {
  custid_ = 0u;
  clear_has_custid();
}
inline ::google::protobuf::uint32 CsUpdateOperReq::custid() const {
  // @@protoc_insertion_point(field_get:CsUpdateOperReq.custid)
  return custid_;
}
inline void CsUpdateOperReq::set_custid(::google::protobuf::uint32 value) {
  set_has_custid();
  custid_ = value;
  // @@protoc_insertion_point(field_set:CsUpdateOperReq.custid)
}

// -------------------------------------------------------------------

// OrderGoodsInfo

// optional string itno = 1;
inline bool OrderGoodsInfo::has_itno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OrderGoodsInfo::set_has_itno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OrderGoodsInfo::clear_has_itno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OrderGoodsInfo::clear_itno() {
  if (itno_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    itno_->clear();
  }
  clear_has_itno();
}
inline const ::std::string& OrderGoodsInfo::itno() const {
  // @@protoc_insertion_point(field_get:OrderGoodsInfo.itno)
  return *itno_;
}
inline void OrderGoodsInfo::set_itno(const ::std::string& value) {
  set_has_itno();
  if (itno_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    itno_ = new ::std::string;
  }
  itno_->assign(value);
  // @@protoc_insertion_point(field_set:OrderGoodsInfo.itno)
}
inline void OrderGoodsInfo::set_itno(const char* value) {
  set_has_itno();
  if (itno_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    itno_ = new ::std::string;
  }
  itno_->assign(value);
  // @@protoc_insertion_point(field_set_char:OrderGoodsInfo.itno)
}
inline void OrderGoodsInfo::set_itno(const char* value, size_t size) {
  set_has_itno();
  if (itno_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    itno_ = new ::std::string;
  }
  itno_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:OrderGoodsInfo.itno)
}
inline ::std::string* OrderGoodsInfo::mutable_itno() {
  set_has_itno();
  if (itno_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    itno_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:OrderGoodsInfo.itno)
  return itno_;
}
inline ::std::string* OrderGoodsInfo::release_itno() {
  clear_has_itno();
  if (itno_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = itno_;
    itno_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void OrderGoodsInfo::set_allocated_itno(::std::string* itno) {
  if (itno_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete itno_;
  }
  if (itno) {
    set_has_itno();
    itno_ = itno;
  } else {
    clear_has_itno();
    itno_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:OrderGoodsInfo.itno)
}

// optional string productName = 2;
inline bool OrderGoodsInfo::has_productname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OrderGoodsInfo::set_has_productname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OrderGoodsInfo::clear_has_productname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OrderGoodsInfo::clear_productname() {
  if (productname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    productname_->clear();
  }
  clear_has_productname();
}
inline const ::std::string& OrderGoodsInfo::productname() const {
  // @@protoc_insertion_point(field_get:OrderGoodsInfo.productName)
  return *productname_;
}
inline void OrderGoodsInfo::set_productname(const ::std::string& value) {
  set_has_productname();
  if (productname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    productname_ = new ::std::string;
  }
  productname_->assign(value);
  // @@protoc_insertion_point(field_set:OrderGoodsInfo.productName)
}
inline void OrderGoodsInfo::set_productname(const char* value) {
  set_has_productname();
  if (productname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    productname_ = new ::std::string;
  }
  productname_->assign(value);
  // @@protoc_insertion_point(field_set_char:OrderGoodsInfo.productName)
}
inline void OrderGoodsInfo::set_productname(const char* value, size_t size) {
  set_has_productname();
  if (productname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    productname_ = new ::std::string;
  }
  productname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:OrderGoodsInfo.productName)
}
inline ::std::string* OrderGoodsInfo::mutable_productname() {
  set_has_productname();
  if (productname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    productname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:OrderGoodsInfo.productName)
  return productname_;
}
inline ::std::string* OrderGoodsInfo::release_productname() {
  clear_has_productname();
  if (productname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = productname_;
    productname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void OrderGoodsInfo::set_allocated_productname(::std::string* productname) {
  if (productname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete productname_;
  }
  if (productname) {
    set_has_productname();
    productname_ = productname;
  } else {
    clear_has_productname();
    productname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:OrderGoodsInfo.productName)
}

// optional string sourceUrl = 3;
inline bool OrderGoodsInfo::has_sourceurl() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OrderGoodsInfo::set_has_sourceurl() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OrderGoodsInfo::clear_has_sourceurl() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OrderGoodsInfo::clear_sourceurl() {
  if (sourceurl_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sourceurl_->clear();
  }
  clear_has_sourceurl();
}
inline const ::std::string& OrderGoodsInfo::sourceurl() const {
  // @@protoc_insertion_point(field_get:OrderGoodsInfo.sourceUrl)
  return *sourceurl_;
}
inline void OrderGoodsInfo::set_sourceurl(const ::std::string& value) {
  set_has_sourceurl();
  if (sourceurl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sourceurl_ = new ::std::string;
  }
  sourceurl_->assign(value);
  // @@protoc_insertion_point(field_set:OrderGoodsInfo.sourceUrl)
}
inline void OrderGoodsInfo::set_sourceurl(const char* value) {
  set_has_sourceurl();
  if (sourceurl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sourceurl_ = new ::std::string;
  }
  sourceurl_->assign(value);
  // @@protoc_insertion_point(field_set_char:OrderGoodsInfo.sourceUrl)
}
inline void OrderGoodsInfo::set_sourceurl(const char* value, size_t size) {
  set_has_sourceurl();
  if (sourceurl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sourceurl_ = new ::std::string;
  }
  sourceurl_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:OrderGoodsInfo.sourceUrl)
}
inline ::std::string* OrderGoodsInfo::mutable_sourceurl() {
  set_has_sourceurl();
  if (sourceurl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sourceurl_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:OrderGoodsInfo.sourceUrl)
  return sourceurl_;
}
inline ::std::string* OrderGoodsInfo::release_sourceurl() {
  clear_has_sourceurl();
  if (sourceurl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = sourceurl_;
    sourceurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void OrderGoodsInfo::set_allocated_sourceurl(::std::string* sourceurl) {
  if (sourceurl_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete sourceurl_;
  }
  if (sourceurl) {
    set_has_sourceurl();
    sourceurl_ = sourceurl;
  } else {
    clear_has_sourceurl();
    sourceurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:OrderGoodsInfo.sourceUrl)
}

// optional string picUrl = 4;
inline bool OrderGoodsInfo::has_picurl() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void OrderGoodsInfo::set_has_picurl() {
  _has_bits_[0] |= 0x00000008u;
}
inline void OrderGoodsInfo::clear_has_picurl() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void OrderGoodsInfo::clear_picurl() {
  if (picurl_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    picurl_->clear();
  }
  clear_has_picurl();
}
inline const ::std::string& OrderGoodsInfo::picurl() const {
  // @@protoc_insertion_point(field_get:OrderGoodsInfo.picUrl)
  return *picurl_;
}
inline void OrderGoodsInfo::set_picurl(const ::std::string& value) {
  set_has_picurl();
  if (picurl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    picurl_ = new ::std::string;
  }
  picurl_->assign(value);
  // @@protoc_insertion_point(field_set:OrderGoodsInfo.picUrl)
}
inline void OrderGoodsInfo::set_picurl(const char* value) {
  set_has_picurl();
  if (picurl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    picurl_ = new ::std::string;
  }
  picurl_->assign(value);
  // @@protoc_insertion_point(field_set_char:OrderGoodsInfo.picUrl)
}
inline void OrderGoodsInfo::set_picurl(const char* value, size_t size) {
  set_has_picurl();
  if (picurl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    picurl_ = new ::std::string;
  }
  picurl_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:OrderGoodsInfo.picUrl)
}
inline ::std::string* OrderGoodsInfo::mutable_picurl() {
  set_has_picurl();
  if (picurl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    picurl_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:OrderGoodsInfo.picUrl)
  return picurl_;
}
inline ::std::string* OrderGoodsInfo::release_picurl() {
  clear_has_picurl();
  if (picurl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = picurl_;
    picurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void OrderGoodsInfo::set_allocated_picurl(::std::string* picurl) {
  if (picurl_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete picurl_;
  }
  if (picurl) {
    set_has_picurl();
    picurl_ = picurl;
  } else {
    clear_has_picurl();
    picurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:OrderGoodsInfo.picUrl)
}

// optional uint32 qty = 5;
inline bool OrderGoodsInfo::has_qty() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void OrderGoodsInfo::set_has_qty() {
  _has_bits_[0] |= 0x00000010u;
}
inline void OrderGoodsInfo::clear_has_qty() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void OrderGoodsInfo::clear_qty() {
  qty_ = 0u;
  clear_has_qty();
}
inline ::google::protobuf::uint32 OrderGoodsInfo::qty() const {
  // @@protoc_insertion_point(field_get:OrderGoodsInfo.qty)
  return qty_;
}
inline void OrderGoodsInfo::set_qty(::google::protobuf::uint32 value) {
  set_has_qty();
  qty_ = value;
  // @@protoc_insertion_point(field_set:OrderGoodsInfo.qty)
}

// optional uint32 isMall = 6;
inline bool OrderGoodsInfo::has_ismall() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void OrderGoodsInfo::set_has_ismall() {
  _has_bits_[0] |= 0x00000020u;
}
inline void OrderGoodsInfo::clear_has_ismall() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void OrderGoodsInfo::clear_ismall() {
  ismall_ = 0u;
  clear_has_ismall();
}
inline ::google::protobuf::uint32 OrderGoodsInfo::ismall() const {
  // @@protoc_insertion_point(field_get:OrderGoodsInfo.isMall)
  return ismall_;
}
inline void OrderGoodsInfo::set_ismall(::google::protobuf::uint32 value) {
  set_has_ismall();
  ismall_ = value;
  // @@protoc_insertion_point(field_set:OrderGoodsInfo.isMall)
}

// optional string skuId = 7;
inline bool OrderGoodsInfo::has_skuid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void OrderGoodsInfo::set_has_skuid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void OrderGoodsInfo::clear_has_skuid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void OrderGoodsInfo::clear_skuid() {
  if (skuid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    skuid_->clear();
  }
  clear_has_skuid();
}
inline const ::std::string& OrderGoodsInfo::skuid() const {
  // @@protoc_insertion_point(field_get:OrderGoodsInfo.skuId)
  return *skuid_;
}
inline void OrderGoodsInfo::set_skuid(const ::std::string& value) {
  set_has_skuid();
  if (skuid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    skuid_ = new ::std::string;
  }
  skuid_->assign(value);
  // @@protoc_insertion_point(field_set:OrderGoodsInfo.skuId)
}
inline void OrderGoodsInfo::set_skuid(const char* value) {
  set_has_skuid();
  if (skuid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    skuid_ = new ::std::string;
  }
  skuid_->assign(value);
  // @@protoc_insertion_point(field_set_char:OrderGoodsInfo.skuId)
}
inline void OrderGoodsInfo::set_skuid(const char* value, size_t size) {
  set_has_skuid();
  if (skuid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    skuid_ = new ::std::string;
  }
  skuid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:OrderGoodsInfo.skuId)
}
inline ::std::string* OrderGoodsInfo::mutable_skuid() {
  set_has_skuid();
  if (skuid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    skuid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:OrderGoodsInfo.skuId)
  return skuid_;
}
inline ::std::string* OrderGoodsInfo::release_skuid() {
  clear_has_skuid();
  if (skuid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = skuid_;
    skuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void OrderGoodsInfo::set_allocated_skuid(::std::string* skuid) {
  if (skuid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete skuid_;
  }
  if (skuid) {
    set_has_skuid();
    skuid_ = skuid;
  } else {
    clear_has_skuid();
    skuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:OrderGoodsInfo.skuId)
}

// optional double price = 8;
inline bool OrderGoodsInfo::has_price() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void OrderGoodsInfo::set_has_price() {
  _has_bits_[0] |= 0x00000080u;
}
inline void OrderGoodsInfo::clear_has_price() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void OrderGoodsInfo::clear_price() {
  price_ = 0;
  clear_has_price();
}
inline double OrderGoodsInfo::price() const {
  // @@protoc_insertion_point(field_get:OrderGoodsInfo.price)
  return price_;
}
inline void OrderGoodsInfo::set_price(double value) {
  set_has_price();
  price_ = value;
  // @@protoc_insertion_point(field_set:OrderGoodsInfo.price)
}

// optional double subTotalPrice = 9;
inline bool OrderGoodsInfo::has_subtotalprice() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void OrderGoodsInfo::set_has_subtotalprice() {
  _has_bits_[0] |= 0x00000100u;
}
inline void OrderGoodsInfo::clear_has_subtotalprice() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void OrderGoodsInfo::clear_subtotalprice() {
  subtotalprice_ = 0;
  clear_has_subtotalprice();
}
inline double OrderGoodsInfo::subtotalprice() const {
  // @@protoc_insertion_point(field_get:OrderGoodsInfo.subTotalPrice)
  return subtotalprice_;
}
inline void OrderGoodsInfo::set_subtotalprice(double value) {
  set_has_subtotalprice();
  subtotalprice_ = value;
  // @@protoc_insertion_point(field_set:OrderGoodsInfo.subTotalPrice)
}

// optional double coupons = 10;
inline bool OrderGoodsInfo::has_coupons() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void OrderGoodsInfo::set_has_coupons() {
  _has_bits_[0] |= 0x00000200u;
}
inline void OrderGoodsInfo::clear_has_coupons() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void OrderGoodsInfo::clear_coupons() {
  coupons_ = 0;
  clear_has_coupons();
}
inline double OrderGoodsInfo::coupons() const {
  // @@protoc_insertion_point(field_get:OrderGoodsInfo.coupons)
  return coupons_;
}
inline void OrderGoodsInfo::set_coupons(double value) {
  set_has_coupons();
  coupons_ = value;
  // @@protoc_insertion_point(field_set:OrderGoodsInfo.coupons)
}

// optional double voucher = 11;
inline bool OrderGoodsInfo::has_voucher() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void OrderGoodsInfo::set_has_voucher() {
  _has_bits_[0] |= 0x00000400u;
}
inline void OrderGoodsInfo::clear_has_voucher() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void OrderGoodsInfo::clear_voucher() {
  voucher_ = 0;
  clear_has_voucher();
}
inline double OrderGoodsInfo::voucher() const {
  // @@protoc_insertion_point(field_get:OrderGoodsInfo.voucher)
  return voucher_;
}
inline void OrderGoodsInfo::set_voucher(double value) {
  set_has_voucher();
  voucher_ = value;
  // @@protoc_insertion_point(field_set:OrderGoodsInfo.voucher)
}

// optional double shoppingCash = 12;
inline bool OrderGoodsInfo::has_shoppingcash() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void OrderGoodsInfo::set_has_shoppingcash() {
  _has_bits_[0] |= 0x00000800u;
}
inline void OrderGoodsInfo::clear_has_shoppingcash() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void OrderGoodsInfo::clear_shoppingcash() {
  shoppingcash_ = 0;
  clear_has_shoppingcash();
}
inline double OrderGoodsInfo::shoppingcash() const {
  // @@protoc_insertion_point(field_get:OrderGoodsInfo.shoppingCash)
  return shoppingcash_;
}
inline void OrderGoodsInfo::set_shoppingcash(double value) {
  set_has_shoppingcash();
  shoppingcash_ = value;
  // @@protoc_insertion_point(field_set:OrderGoodsInfo.shoppingCash)
}

// optional double shoppingCard = 13;
inline bool OrderGoodsInfo::has_shoppingcard() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void OrderGoodsInfo::set_has_shoppingcard() {
  _has_bits_[0] |= 0x00001000u;
}
inline void OrderGoodsInfo::clear_has_shoppingcard() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void OrderGoodsInfo::clear_shoppingcard() {
  shoppingcard_ = 0;
  clear_has_shoppingcard();
}
inline double OrderGoodsInfo::shoppingcard() const {
  // @@protoc_insertion_point(field_get:OrderGoodsInfo.shoppingCard)
  return shoppingcard_;
}
inline void OrderGoodsInfo::set_shoppingcard(double value) {
  set_has_shoppingcard();
  shoppingcard_ = value;
  // @@protoc_insertion_point(field_set:OrderGoodsInfo.shoppingCard)
}

// optional double pointsPrice = 14;
inline bool OrderGoodsInfo::has_pointsprice() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void OrderGoodsInfo::set_has_pointsprice() {
  _has_bits_[0] |= 0x00002000u;
}
inline void OrderGoodsInfo::clear_has_pointsprice() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void OrderGoodsInfo::clear_pointsprice() {
  pointsprice_ = 0;
  clear_has_pointsprice();
}
inline double OrderGoodsInfo::pointsprice() const {
  // @@protoc_insertion_point(field_get:OrderGoodsInfo.pointsPrice)
  return pointsprice_;
}
inline void OrderGoodsInfo::set_pointsprice(double value) {
  set_has_pointsprice();
  pointsprice_ = value;
  // @@protoc_insertion_point(field_set:OrderGoodsInfo.pointsPrice)
}

// optional double promote = 15;
inline bool OrderGoodsInfo::has_promote() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void OrderGoodsInfo::set_has_promote() {
  _has_bits_[0] |= 0x00004000u;
}
inline void OrderGoodsInfo::clear_has_promote() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void OrderGoodsInfo::clear_promote() {
  promote_ = 0;
  clear_has_promote();
}
inline double OrderGoodsInfo::promote() const {
  // @@protoc_insertion_point(field_get:OrderGoodsInfo.promote)
  return promote_;
}
inline void OrderGoodsInfo::set_promote(double value) {
  set_has_promote();
  promote_ = value;
  // @@protoc_insertion_point(field_set:OrderGoodsInfo.promote)
}

// optional double shippingTax = 16;
inline bool OrderGoodsInfo::has_shippingtax() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void OrderGoodsInfo::set_has_shippingtax() {
  _has_bits_[0] |= 0x00008000u;
}
inline void OrderGoodsInfo::clear_has_shippingtax() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void OrderGoodsInfo::clear_shippingtax() {
  shippingtax_ = 0;
  clear_has_shippingtax();
}
inline double OrderGoodsInfo::shippingtax() const {
  // @@protoc_insertion_point(field_get:OrderGoodsInfo.shippingTax)
  return shippingtax_;
}
inline void OrderGoodsInfo::set_shippingtax(double value) {
  set_has_shippingtax();
  shippingtax_ = value;
  // @@protoc_insertion_point(field_set:OrderGoodsInfo.shippingTax)
}

// optional string freightNumber = 17;
inline bool OrderGoodsInfo::has_freightnumber() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void OrderGoodsInfo::set_has_freightnumber() {
  _has_bits_[0] |= 0x00010000u;
}
inline void OrderGoodsInfo::clear_has_freightnumber() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void OrderGoodsInfo::clear_freightnumber() {
  if (freightnumber_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    freightnumber_->clear();
  }
  clear_has_freightnumber();
}
inline const ::std::string& OrderGoodsInfo::freightnumber() const {
  // @@protoc_insertion_point(field_get:OrderGoodsInfo.freightNumber)
  return *freightnumber_;
}
inline void OrderGoodsInfo::set_freightnumber(const ::std::string& value) {
  set_has_freightnumber();
  if (freightnumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    freightnumber_ = new ::std::string;
  }
  freightnumber_->assign(value);
  // @@protoc_insertion_point(field_set:OrderGoodsInfo.freightNumber)
}
inline void OrderGoodsInfo::set_freightnumber(const char* value) {
  set_has_freightnumber();
  if (freightnumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    freightnumber_ = new ::std::string;
  }
  freightnumber_->assign(value);
  // @@protoc_insertion_point(field_set_char:OrderGoodsInfo.freightNumber)
}
inline void OrderGoodsInfo::set_freightnumber(const char* value, size_t size) {
  set_has_freightnumber();
  if (freightnumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    freightnumber_ = new ::std::string;
  }
  freightnumber_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:OrderGoodsInfo.freightNumber)
}
inline ::std::string* OrderGoodsInfo::mutable_freightnumber() {
  set_has_freightnumber();
  if (freightnumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    freightnumber_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:OrderGoodsInfo.freightNumber)
  return freightnumber_;
}
inline ::std::string* OrderGoodsInfo::release_freightnumber() {
  clear_has_freightnumber();
  if (freightnumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = freightnumber_;
    freightnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void OrderGoodsInfo::set_allocated_freightnumber(::std::string* freightnumber) {
  if (freightnumber_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete freightnumber_;
  }
  if (freightnumber) {
    set_has_freightnumber();
    freightnumber_ = freightnumber;
  } else {
    clear_has_freightnumber();
    freightnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:OrderGoodsInfo.freightNumber)
}

// optional string kind = 18;
inline bool OrderGoodsInfo::has_kind() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void OrderGoodsInfo::set_has_kind() {
  _has_bits_[0] |= 0x00020000u;
}
inline void OrderGoodsInfo::clear_has_kind() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void OrderGoodsInfo::clear_kind() {
  if (kind_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    kind_->clear();
  }
  clear_has_kind();
}
inline const ::std::string& OrderGoodsInfo::kind() const {
  // @@protoc_insertion_point(field_get:OrderGoodsInfo.kind)
  return *kind_;
}
inline void OrderGoodsInfo::set_kind(const ::std::string& value) {
  set_has_kind();
  if (kind_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    kind_ = new ::std::string;
  }
  kind_->assign(value);
  // @@protoc_insertion_point(field_set:OrderGoodsInfo.kind)
}
inline void OrderGoodsInfo::set_kind(const char* value) {
  set_has_kind();
  if (kind_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    kind_ = new ::std::string;
  }
  kind_->assign(value);
  // @@protoc_insertion_point(field_set_char:OrderGoodsInfo.kind)
}
inline void OrderGoodsInfo::set_kind(const char* value, size_t size) {
  set_has_kind();
  if (kind_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    kind_ = new ::std::string;
  }
  kind_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:OrderGoodsInfo.kind)
}
inline ::std::string* OrderGoodsInfo::mutable_kind() {
  set_has_kind();
  if (kind_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    kind_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:OrderGoodsInfo.kind)
  return kind_;
}
inline ::std::string* OrderGoodsInfo::release_kind() {
  clear_has_kind();
  if (kind_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = kind_;
    kind_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void OrderGoodsInfo::set_allocated_kind(::std::string* kind) {
  if (kind_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete kind_;
  }
  if (kind) {
    set_has_kind();
    kind_ = kind;
  } else {
    clear_has_kind();
    kind_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:OrderGoodsInfo.kind)
}

// optional string color = 19;
inline bool OrderGoodsInfo::has_color() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void OrderGoodsInfo::set_has_color() {
  _has_bits_[0] |= 0x00040000u;
}
inline void OrderGoodsInfo::clear_has_color() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void OrderGoodsInfo::clear_color() {
  if (color_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    color_->clear();
  }
  clear_has_color();
}
inline const ::std::string& OrderGoodsInfo::color() const {
  // @@protoc_insertion_point(field_get:OrderGoodsInfo.color)
  return *color_;
}
inline void OrderGoodsInfo::set_color(const ::std::string& value) {
  set_has_color();
  if (color_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    color_ = new ::std::string;
  }
  color_->assign(value);
  // @@protoc_insertion_point(field_set:OrderGoodsInfo.color)
}
inline void OrderGoodsInfo::set_color(const char* value) {
  set_has_color();
  if (color_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    color_ = new ::std::string;
  }
  color_->assign(value);
  // @@protoc_insertion_point(field_set_char:OrderGoodsInfo.color)
}
inline void OrderGoodsInfo::set_color(const char* value, size_t size) {
  set_has_color();
  if (color_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    color_ = new ::std::string;
  }
  color_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:OrderGoodsInfo.color)
}
inline ::std::string* OrderGoodsInfo::mutable_color() {
  set_has_color();
  if (color_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    color_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:OrderGoodsInfo.color)
  return color_;
}
inline ::std::string* OrderGoodsInfo::release_color() {
  clear_has_color();
  if (color_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = color_;
    color_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void OrderGoodsInfo::set_allocated_color(::std::string* color) {
  if (color_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete color_;
  }
  if (color) {
    set_has_color();
    color_ = color;
  } else {
    clear_has_color();
    color_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:OrderGoodsInfo.color)
}

// optional string size = 20;
inline bool OrderGoodsInfo::has_size() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void OrderGoodsInfo::set_has_size() {
  _has_bits_[0] |= 0x00080000u;
}
inline void OrderGoodsInfo::clear_has_size() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void OrderGoodsInfo::clear_size() {
  if (size_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    size_->clear();
  }
  clear_has_size();
}
inline const ::std::string& OrderGoodsInfo::size() const {
  // @@protoc_insertion_point(field_get:OrderGoodsInfo.size)
  return *size_;
}
inline void OrderGoodsInfo::set_size(const ::std::string& value) {
  set_has_size();
  if (size_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    size_ = new ::std::string;
  }
  size_->assign(value);
  // @@protoc_insertion_point(field_set:OrderGoodsInfo.size)
}
inline void OrderGoodsInfo::set_size(const char* value) {
  set_has_size();
  if (size_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    size_ = new ::std::string;
  }
  size_->assign(value);
  // @@protoc_insertion_point(field_set_char:OrderGoodsInfo.size)
}
inline void OrderGoodsInfo::set_size(const char* value, size_t size) {
  set_has_size();
  if (size_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    size_ = new ::std::string;
  }
  size_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:OrderGoodsInfo.size)
}
inline ::std::string* OrderGoodsInfo::mutable_size() {
  set_has_size();
  if (size_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    size_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:OrderGoodsInfo.size)
  return size_;
}
inline ::std::string* OrderGoodsInfo::release_size() {
  clear_has_size();
  if (size_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = size_;
    size_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void OrderGoodsInfo::set_allocated_size(::std::string* size) {
  if (size_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete size_;
  }
  if (size) {
    set_has_size();
    size_ = size;
  } else {
    clear_has_size();
    size_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:OrderGoodsInfo.size)
}

// -------------------------------------------------------------------

// NewOrder

// optional string ogNo = 1;
inline bool NewOrder::has_ogno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NewOrder::set_has_ogno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NewOrder::clear_has_ogno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NewOrder::clear_ogno() {
  if (ogno_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ogno_->clear();
  }
  clear_has_ogno();
}
inline const ::std::string& NewOrder::ogno() const {
  // @@protoc_insertion_point(field_get:NewOrder.ogNo)
  return *ogno_;
}
inline void NewOrder::set_ogno(const ::std::string& value) {
  set_has_ogno();
  if (ogno_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ogno_ = new ::std::string;
  }
  ogno_->assign(value);
  // @@protoc_insertion_point(field_set:NewOrder.ogNo)
}
inline void NewOrder::set_ogno(const char* value) {
  set_has_ogno();
  if (ogno_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ogno_ = new ::std::string;
  }
  ogno_->assign(value);
  // @@protoc_insertion_point(field_set_char:NewOrder.ogNo)
}
inline void NewOrder::set_ogno(const char* value, size_t size) {
  set_has_ogno();
  if (ogno_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ogno_ = new ::std::string;
  }
  ogno_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:NewOrder.ogNo)
}
inline ::std::string* NewOrder::mutable_ogno() {
  set_has_ogno();
  if (ogno_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ogno_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:NewOrder.ogNo)
  return ogno_;
}
inline ::std::string* NewOrder::release_ogno() {
  clear_has_ogno();
  if (ogno_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = ogno_;
    ogno_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void NewOrder::set_allocated_ogno(::std::string* ogno) {
  if (ogno_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete ogno_;
  }
  if (ogno) {
    set_has_ogno();
    ogno_ = ogno;
  } else {
    clear_has_ogno();
    ogno_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:NewOrder.ogNo)
}

// optional string ogSeq = 2;
inline bool NewOrder::has_ogseq() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NewOrder::set_has_ogseq() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NewOrder::clear_has_ogseq() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NewOrder::clear_ogseq() {
  if (ogseq_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ogseq_->clear();
  }
  clear_has_ogseq();
}
inline const ::std::string& NewOrder::ogseq() const {
  // @@protoc_insertion_point(field_get:NewOrder.ogSeq)
  return *ogseq_;
}
inline void NewOrder::set_ogseq(const ::std::string& value) {
  set_has_ogseq();
  if (ogseq_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ogseq_ = new ::std::string;
  }
  ogseq_->assign(value);
  // @@protoc_insertion_point(field_set:NewOrder.ogSeq)
}
inline void NewOrder::set_ogseq(const char* value) {
  set_has_ogseq();
  if (ogseq_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ogseq_ = new ::std::string;
  }
  ogseq_->assign(value);
  // @@protoc_insertion_point(field_set_char:NewOrder.ogSeq)
}
inline void NewOrder::set_ogseq(const char* value, size_t size) {
  set_has_ogseq();
  if (ogseq_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ogseq_ = new ::std::string;
  }
  ogseq_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:NewOrder.ogSeq)
}
inline ::std::string* NewOrder::mutable_ogseq() {
  set_has_ogseq();
  if (ogseq_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ogseq_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:NewOrder.ogSeq)
  return ogseq_;
}
inline ::std::string* NewOrder::release_ogseq() {
  clear_has_ogseq();
  if (ogseq_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = ogseq_;
    ogseq_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void NewOrder::set_allocated_ogseq(::std::string* ogseq) {
  if (ogseq_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete ogseq_;
  }
  if (ogseq) {
    set_has_ogseq();
    ogseq_ = ogseq;
  } else {
    clear_has_ogseq();
    ogseq_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:NewOrder.ogSeq)
}

// optional string memGuid = 3;
inline bool NewOrder::has_memguid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NewOrder::set_has_memguid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NewOrder::clear_has_memguid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NewOrder::clear_memguid() {
  if (memguid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    memguid_->clear();
  }
  clear_has_memguid();
}
inline const ::std::string& NewOrder::memguid() const {
  // @@protoc_insertion_point(field_get:NewOrder.memGuid)
  return *memguid_;
}
inline void NewOrder::set_memguid(const ::std::string& value) {
  set_has_memguid();
  if (memguid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    memguid_ = new ::std::string;
  }
  memguid_->assign(value);
  // @@protoc_insertion_point(field_set:NewOrder.memGuid)
}
inline void NewOrder::set_memguid(const char* value) {
  set_has_memguid();
  if (memguid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    memguid_ = new ::std::string;
  }
  memguid_->assign(value);
  // @@protoc_insertion_point(field_set_char:NewOrder.memGuid)
}
inline void NewOrder::set_memguid(const char* value, size_t size) {
  set_has_memguid();
  if (memguid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    memguid_ = new ::std::string;
  }
  memguid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:NewOrder.memGuid)
}
inline ::std::string* NewOrder::mutable_memguid() {
  set_has_memguid();
  if (memguid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    memguid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:NewOrder.memGuid)
  return memguid_;
}
inline ::std::string* NewOrder::release_memguid() {
  clear_has_memguid();
  if (memguid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = memguid_;
    memguid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void NewOrder::set_allocated_memguid(::std::string* memguid) {
  if (memguid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete memguid_;
  }
  if (memguid) {
    set_has_memguid();
    memguid_ = memguid;
  } else {
    clear_has_memguid();
    memguid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:NewOrder.memGuid)
}

// optional double totalPay = 4;
inline bool NewOrder::has_totalpay() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void NewOrder::set_has_totalpay() {
  _has_bits_[0] |= 0x00000008u;
}
inline void NewOrder::clear_has_totalpay() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void NewOrder::clear_totalpay() {
  totalpay_ = 0;
  clear_has_totalpay();
}
inline double NewOrder::totalpay() const {
  // @@protoc_insertion_point(field_get:NewOrder.totalPay)
  return totalpay_;
}
inline void NewOrder::set_totalpay(double value) {
  set_has_totalpay();
  totalpay_ = value;
  // @@protoc_insertion_point(field_set:NewOrder.totalPay)
}

// optional string memberName = 5;
inline bool NewOrder::has_membername() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void NewOrder::set_has_membername() {
  _has_bits_[0] |= 0x00000010u;
}
inline void NewOrder::clear_has_membername() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void NewOrder::clear_membername() {
  if (membername_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    membername_->clear();
  }
  clear_has_membername();
}
inline const ::std::string& NewOrder::membername() const {
  // @@protoc_insertion_point(field_get:NewOrder.memberName)
  return *membername_;
}
inline void NewOrder::set_membername(const ::std::string& value) {
  set_has_membername();
  if (membername_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    membername_ = new ::std::string;
  }
  membername_->assign(value);
  // @@protoc_insertion_point(field_set:NewOrder.memberName)
}
inline void NewOrder::set_membername(const char* value) {
  set_has_membername();
  if (membername_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    membername_ = new ::std::string;
  }
  membername_->assign(value);
  // @@protoc_insertion_point(field_set_char:NewOrder.memberName)
}
inline void NewOrder::set_membername(const char* value, size_t size) {
  set_has_membername();
  if (membername_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    membername_ = new ::std::string;
  }
  membername_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:NewOrder.memberName)
}
inline ::std::string* NewOrder::mutable_membername() {
  set_has_membername();
  if (membername_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    membername_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:NewOrder.memberName)
  return membername_;
}
inline ::std::string* NewOrder::release_membername() {
  clear_has_membername();
  if (membername_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = membername_;
    membername_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void NewOrder::set_allocated_membername(::std::string* membername) {
  if (membername_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete membername_;
  }
  if (membername) {
    set_has_membername();
    membername_ = membername;
  } else {
    clear_has_membername();
    membername_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:NewOrder.memberName)
}

// optional string memberCellphone = 6;
inline bool NewOrder::has_membercellphone() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void NewOrder::set_has_membercellphone() {
  _has_bits_[0] |= 0x00000020u;
}
inline void NewOrder::clear_has_membercellphone() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void NewOrder::clear_membercellphone() {
  if (membercellphone_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    membercellphone_->clear();
  }
  clear_has_membercellphone();
}
inline const ::std::string& NewOrder::membercellphone() const {
  // @@protoc_insertion_point(field_get:NewOrder.memberCellphone)
  return *membercellphone_;
}
inline void NewOrder::set_membercellphone(const ::std::string& value) {
  set_has_membercellphone();
  if (membercellphone_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    membercellphone_ = new ::std::string;
  }
  membercellphone_->assign(value);
  // @@protoc_insertion_point(field_set:NewOrder.memberCellphone)
}
inline void NewOrder::set_membercellphone(const char* value) {
  set_has_membercellphone();
  if (membercellphone_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    membercellphone_ = new ::std::string;
  }
  membercellphone_->assign(value);
  // @@protoc_insertion_point(field_set_char:NewOrder.memberCellphone)
}
inline void NewOrder::set_membercellphone(const char* value, size_t size) {
  set_has_membercellphone();
  if (membercellphone_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    membercellphone_ = new ::std::string;
  }
  membercellphone_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:NewOrder.memberCellphone)
}
inline ::std::string* NewOrder::mutable_membercellphone() {
  set_has_membercellphone();
  if (membercellphone_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    membercellphone_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:NewOrder.memberCellphone)
  return membercellphone_;
}
inline ::std::string* NewOrder::release_membercellphone() {
  clear_has_membercellphone();
  if (membercellphone_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = membercellphone_;
    membercellphone_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void NewOrder::set_allocated_membercellphone(::std::string* membercellphone) {
  if (membercellphone_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete membercellphone_;
  }
  if (membercellphone) {
    set_has_membercellphone();
    membercellphone_ = membercellphone;
  } else {
    clear_has_membercellphone();
    membercellphone_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:NewOrder.memberCellphone)
}

// optional string insertDate = 7;
inline bool NewOrder::has_insertdate() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void NewOrder::set_has_insertdate() {
  _has_bits_[0] |= 0x00000040u;
}
inline void NewOrder::clear_has_insertdate() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void NewOrder::clear_insertdate() {
  if (insertdate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    insertdate_->clear();
  }
  clear_has_insertdate();
}
inline const ::std::string& NewOrder::insertdate() const {
  // @@protoc_insertion_point(field_get:NewOrder.insertDate)
  return *insertdate_;
}
inline void NewOrder::set_insertdate(const ::std::string& value) {
  set_has_insertdate();
  if (insertdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    insertdate_ = new ::std::string;
  }
  insertdate_->assign(value);
  // @@protoc_insertion_point(field_set:NewOrder.insertDate)
}
inline void NewOrder::set_insertdate(const char* value) {
  set_has_insertdate();
  if (insertdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    insertdate_ = new ::std::string;
  }
  insertdate_->assign(value);
  // @@protoc_insertion_point(field_set_char:NewOrder.insertDate)
}
inline void NewOrder::set_insertdate(const char* value, size_t size) {
  set_has_insertdate();
  if (insertdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    insertdate_ = new ::std::string;
  }
  insertdate_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:NewOrder.insertDate)
}
inline ::std::string* NewOrder::mutable_insertdate() {
  set_has_insertdate();
  if (insertdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    insertdate_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:NewOrder.insertDate)
  return insertdate_;
}
inline ::std::string* NewOrder::release_insertdate() {
  clear_has_insertdate();
  if (insertdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = insertdate_;
    insertdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void NewOrder::set_allocated_insertdate(::std::string* insertdate) {
  if (insertdate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete insertdate_;
  }
  if (insertdate) {
    set_has_insertdate();
    insertdate_ = insertdate;
  } else {
    clear_has_insertdate();
    insertdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:NewOrder.insertDate)
}

// optional string payType = 8;
inline bool NewOrder::has_paytype() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void NewOrder::set_has_paytype() {
  _has_bits_[0] |= 0x00000080u;
}
inline void NewOrder::clear_has_paytype() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void NewOrder::clear_paytype() {
  if (paytype_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    paytype_->clear();
  }
  clear_has_paytype();
}
inline const ::std::string& NewOrder::paytype() const {
  // @@protoc_insertion_point(field_get:NewOrder.payType)
  return *paytype_;
}
inline void NewOrder::set_paytype(const ::std::string& value) {
  set_has_paytype();
  if (paytype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    paytype_ = new ::std::string;
  }
  paytype_->assign(value);
  // @@protoc_insertion_point(field_set:NewOrder.payType)
}
inline void NewOrder::set_paytype(const char* value) {
  set_has_paytype();
  if (paytype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    paytype_ = new ::std::string;
  }
  paytype_->assign(value);
  // @@protoc_insertion_point(field_set_char:NewOrder.payType)
}
inline void NewOrder::set_paytype(const char* value, size_t size) {
  set_has_paytype();
  if (paytype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    paytype_ = new ::std::string;
  }
  paytype_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:NewOrder.payType)
}
inline ::std::string* NewOrder::mutable_paytype() {
  set_has_paytype();
  if (paytype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    paytype_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:NewOrder.payType)
  return paytype_;
}
inline ::std::string* NewOrder::release_paytype() {
  clear_has_paytype();
  if (paytype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = paytype_;
    paytype_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void NewOrder::set_allocated_paytype(::std::string* paytype) {
  if (paytype_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete paytype_;
  }
  if (paytype) {
    set_has_paytype();
    paytype_ = paytype;
  } else {
    clear_has_paytype();
    paytype_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:NewOrder.payType)
}

// optional string packNo = 9;
inline bool NewOrder::has_packno() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void NewOrder::set_has_packno() {
  _has_bits_[0] |= 0x00000100u;
}
inline void NewOrder::clear_has_packno() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void NewOrder::clear_packno() {
  if (packno_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    packno_->clear();
  }
  clear_has_packno();
}
inline const ::std::string& NewOrder::packno() const {
  // @@protoc_insertion_point(field_get:NewOrder.packNo)
  return *packno_;
}
inline void NewOrder::set_packno(const ::std::string& value) {
  set_has_packno();
  if (packno_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    packno_ = new ::std::string;
  }
  packno_->assign(value);
  // @@protoc_insertion_point(field_set:NewOrder.packNo)
}
inline void NewOrder::set_packno(const char* value) {
  set_has_packno();
  if (packno_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    packno_ = new ::std::string;
  }
  packno_->assign(value);
  // @@protoc_insertion_point(field_set_char:NewOrder.packNo)
}
inline void NewOrder::set_packno(const char* value, size_t size) {
  set_has_packno();
  if (packno_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    packno_ = new ::std::string;
  }
  packno_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:NewOrder.packNo)
}
inline ::std::string* NewOrder::mutable_packno() {
  set_has_packno();
  if (packno_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    packno_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:NewOrder.packNo)
  return packno_;
}
inline ::std::string* NewOrder::release_packno() {
  clear_has_packno();
  if (packno_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = packno_;
    packno_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void NewOrder::set_allocated_packno(::std::string* packno) {
  if (packno_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete packno_;
  }
  if (packno) {
    set_has_packno();
    packno_ = packno;
  } else {
    clear_has_packno();
    packno_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:NewOrder.packNo)
}

// optional uint32 packState = 10;
inline bool NewOrder::has_packstate() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void NewOrder::set_has_packstate() {
  _has_bits_[0] |= 0x00000200u;
}
inline void NewOrder::clear_has_packstate() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void NewOrder::clear_packstate() {
  packstate_ = 0u;
  clear_has_packstate();
}
inline ::google::protobuf::uint32 NewOrder::packstate() const {
  // @@protoc_insertion_point(field_get:NewOrder.packState)
  return packstate_;
}
inline void NewOrder::set_packstate(::google::protobuf::uint32 value) {
  set_has_packstate();
  packstate_ = value;
  // @@protoc_insertion_point(field_set:NewOrder.packState)
}

// optional string packStateStr = 11;
inline bool NewOrder::has_packstatestr() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void NewOrder::set_has_packstatestr() {
  _has_bits_[0] |= 0x00000400u;
}
inline void NewOrder::clear_has_packstatestr() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void NewOrder::clear_packstatestr() {
  if (packstatestr_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    packstatestr_->clear();
  }
  clear_has_packstatestr();
}
inline const ::std::string& NewOrder::packstatestr() const {
  // @@protoc_insertion_point(field_get:NewOrder.packStateStr)
  return *packstatestr_;
}
inline void NewOrder::set_packstatestr(const ::std::string& value) {
  set_has_packstatestr();
  if (packstatestr_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    packstatestr_ = new ::std::string;
  }
  packstatestr_->assign(value);
  // @@protoc_insertion_point(field_set:NewOrder.packStateStr)
}
inline void NewOrder::set_packstatestr(const char* value) {
  set_has_packstatestr();
  if (packstatestr_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    packstatestr_ = new ::std::string;
  }
  packstatestr_->assign(value);
  // @@protoc_insertion_point(field_set_char:NewOrder.packStateStr)
}
inline void NewOrder::set_packstatestr(const char* value, size_t size) {
  set_has_packstatestr();
  if (packstatestr_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    packstatestr_ = new ::std::string;
  }
  packstatestr_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:NewOrder.packStateStr)
}
inline ::std::string* NewOrder::mutable_packstatestr() {
  set_has_packstatestr();
  if (packstatestr_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    packstatestr_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:NewOrder.packStateStr)
  return packstatestr_;
}
inline ::std::string* NewOrder::release_packstatestr() {
  clear_has_packstatestr();
  if (packstatestr_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = packstatestr_;
    packstatestr_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void NewOrder::set_allocated_packstatestr(::std::string* packstatestr) {
  if (packstatestr_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete packstatestr_;
  }
  if (packstatestr) {
    set_has_packstatestr();
    packstatestr_ = packstatestr;
  } else {
    clear_has_packstatestr();
    packstatestr_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:NewOrder.packStateStr)
}

// optional uint32 type = 12;
inline bool NewOrder::has_type() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void NewOrder::set_has_type() {
  _has_bits_[0] |= 0x00000800u;
}
inline void NewOrder::clear_has_type() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void NewOrder::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 NewOrder::type() const {
  // @@protoc_insertion_point(field_get:NewOrder.type)
  return type_;
}
inline void NewOrder::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:NewOrder.type)
}

// optional string packQueryNo = 13;
inline bool NewOrder::has_packqueryno() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void NewOrder::set_has_packqueryno() {
  _has_bits_[0] |= 0x00001000u;
}
inline void NewOrder::clear_has_packqueryno() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void NewOrder::clear_packqueryno() {
  if (packqueryno_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    packqueryno_->clear();
  }
  clear_has_packqueryno();
}
inline const ::std::string& NewOrder::packqueryno() const {
  // @@protoc_insertion_point(field_get:NewOrder.packQueryNo)
  return *packqueryno_;
}
inline void NewOrder::set_packqueryno(const ::std::string& value) {
  set_has_packqueryno();
  if (packqueryno_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    packqueryno_ = new ::std::string;
  }
  packqueryno_->assign(value);
  // @@protoc_insertion_point(field_set:NewOrder.packQueryNo)
}
inline void NewOrder::set_packqueryno(const char* value) {
  set_has_packqueryno();
  if (packqueryno_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    packqueryno_ = new ::std::string;
  }
  packqueryno_->assign(value);
  // @@protoc_insertion_point(field_set_char:NewOrder.packQueryNo)
}
inline void NewOrder::set_packqueryno(const char* value, size_t size) {
  set_has_packqueryno();
  if (packqueryno_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    packqueryno_ = new ::std::string;
  }
  packqueryno_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:NewOrder.packQueryNo)
}
inline ::std::string* NewOrder::mutable_packqueryno() {
  set_has_packqueryno();
  if (packqueryno_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    packqueryno_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:NewOrder.packQueryNo)
  return packqueryno_;
}
inline ::std::string* NewOrder::release_packqueryno() {
  clear_has_packqueryno();
  if (packqueryno_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = packqueryno_;
    packqueryno_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void NewOrder::set_allocated_packqueryno(::std::string* packqueryno) {
  if (packqueryno_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete packqueryno_;
  }
  if (packqueryno) {
    set_has_packqueryno();
    packqueryno_ = packqueryno;
  } else {
    clear_has_packqueryno();
    packqueryno_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:NewOrder.packQueryNo)
}

// optional string merchantId = 14;
inline bool NewOrder::has_merchantid() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void NewOrder::set_has_merchantid() {
  _has_bits_[0] |= 0x00002000u;
}
inline void NewOrder::clear_has_merchantid() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void NewOrder::clear_merchantid() {
  if (merchantid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    merchantid_->clear();
  }
  clear_has_merchantid();
}
inline const ::std::string& NewOrder::merchantid() const {
  // @@protoc_insertion_point(field_get:NewOrder.merchantId)
  return *merchantid_;
}
inline void NewOrder::set_merchantid(const ::std::string& value) {
  set_has_merchantid();
  if (merchantid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    merchantid_ = new ::std::string;
  }
  merchantid_->assign(value);
  // @@protoc_insertion_point(field_set:NewOrder.merchantId)
}
inline void NewOrder::set_merchantid(const char* value) {
  set_has_merchantid();
  if (merchantid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    merchantid_ = new ::std::string;
  }
  merchantid_->assign(value);
  // @@protoc_insertion_point(field_set_char:NewOrder.merchantId)
}
inline void NewOrder::set_merchantid(const char* value, size_t size) {
  set_has_merchantid();
  if (merchantid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    merchantid_ = new ::std::string;
  }
  merchantid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:NewOrder.merchantId)
}
inline ::std::string* NewOrder::mutable_merchantid() {
  set_has_merchantid();
  if (merchantid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    merchantid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:NewOrder.merchantId)
  return merchantid_;
}
inline ::std::string* NewOrder::release_merchantid() {
  clear_has_merchantid();
  if (merchantid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = merchantid_;
    merchantid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void NewOrder::set_allocated_merchantid(::std::string* merchantid) {
  if (merchantid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete merchantid_;
  }
  if (merchantid) {
    set_has_merchantid();
    merchantid_ = merchantid;
  } else {
    clear_has_merchantid();
    merchantid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:NewOrder.merchantId)
}

// optional double freight = 15;
inline bool NewOrder::has_freight() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void NewOrder::set_has_freight() {
  _has_bits_[0] |= 0x00004000u;
}
inline void NewOrder::clear_has_freight() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void NewOrder::clear_freight() {
  freight_ = 0;
  clear_has_freight();
}
inline double NewOrder::freight() const {
  // @@protoc_insertion_point(field_get:NewOrder.freight)
  return freight_;
}
inline void NewOrder::set_freight(double value) {
  set_has_freight();
  freight_ = value;
  // @@protoc_insertion_point(field_set:NewOrder.freight)
}

// optional string buyername = 16;
inline bool NewOrder::has_buyername() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void NewOrder::set_has_buyername() {
  _has_bits_[0] |= 0x00008000u;
}
inline void NewOrder::clear_has_buyername() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void NewOrder::clear_buyername() {
  if (buyername_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    buyername_->clear();
  }
  clear_has_buyername();
}
inline const ::std::string& NewOrder::buyername() const {
  // @@protoc_insertion_point(field_get:NewOrder.buyername)
  return *buyername_;
}
inline void NewOrder::set_buyername(const ::std::string& value) {
  set_has_buyername();
  if (buyername_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    buyername_ = new ::std::string;
  }
  buyername_->assign(value);
  // @@protoc_insertion_point(field_set:NewOrder.buyername)
}
inline void NewOrder::set_buyername(const char* value) {
  set_has_buyername();
  if (buyername_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    buyername_ = new ::std::string;
  }
  buyername_->assign(value);
  // @@protoc_insertion_point(field_set_char:NewOrder.buyername)
}
inline void NewOrder::set_buyername(const char* value, size_t size) {
  set_has_buyername();
  if (buyername_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    buyername_ = new ::std::string;
  }
  buyername_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:NewOrder.buyername)
}
inline ::std::string* NewOrder::mutable_buyername() {
  set_has_buyername();
  if (buyername_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    buyername_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:NewOrder.buyername)
  return buyername_;
}
inline ::std::string* NewOrder::release_buyername() {
  clear_has_buyername();
  if (buyername_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = buyername_;
    buyername_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void NewOrder::set_allocated_buyername(::std::string* buyername) {
  if (buyername_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete buyername_;
  }
  if (buyername) {
    set_has_buyername();
    buyername_ = buyername;
  } else {
    clear_has_buyername();
    buyername_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:NewOrder.buyername)
}

// repeated .OrderGoodsInfo goodslist = 25;
inline int NewOrder::goodslist_size() const {
  return goodslist_.size();
}
inline void NewOrder::clear_goodslist() {
  goodslist_.Clear();
}
inline const ::OrderGoodsInfo& NewOrder::goodslist(int index) const {
  // @@protoc_insertion_point(field_get:NewOrder.goodslist)
  return goodslist_.Get(index);
}
inline ::OrderGoodsInfo* NewOrder::mutable_goodslist(int index) {
  // @@protoc_insertion_point(field_mutable:NewOrder.goodslist)
  return goodslist_.Mutable(index);
}
inline ::OrderGoodsInfo* NewOrder::add_goodslist() {
  // @@protoc_insertion_point(field_add:NewOrder.goodslist)
  return goodslist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OrderGoodsInfo >&
NewOrder::goodslist() const {
  // @@protoc_insertion_point(field_list:NewOrder.goodslist)
  return goodslist_;
}
inline ::google::protobuf::RepeatedPtrField< ::OrderGoodsInfo >*
NewOrder::mutable_goodslist() {
  // @@protoc_insertion_point(field_mutable_list:NewOrder.goodslist)
  return &goodslist_;
}

// -------------------------------------------------------------------

// PayOrder

// optional string ogNo = 1;
inline bool PayOrder::has_ogno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PayOrder::set_has_ogno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PayOrder::clear_has_ogno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PayOrder::clear_ogno() {
  if (ogno_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ogno_->clear();
  }
  clear_has_ogno();
}
inline const ::std::string& PayOrder::ogno() const {
  // @@protoc_insertion_point(field_get:PayOrder.ogNo)
  return *ogno_;
}
inline void PayOrder::set_ogno(const ::std::string& value) {
  set_has_ogno();
  if (ogno_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ogno_ = new ::std::string;
  }
  ogno_->assign(value);
  // @@protoc_insertion_point(field_set:PayOrder.ogNo)
}
inline void PayOrder::set_ogno(const char* value) {
  set_has_ogno();
  if (ogno_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ogno_ = new ::std::string;
  }
  ogno_->assign(value);
  // @@protoc_insertion_point(field_set_char:PayOrder.ogNo)
}
inline void PayOrder::set_ogno(const char* value, size_t size) {
  set_has_ogno();
  if (ogno_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ogno_ = new ::std::string;
  }
  ogno_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:PayOrder.ogNo)
}
inline ::std::string* PayOrder::mutable_ogno() {
  set_has_ogno();
  if (ogno_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ogno_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:PayOrder.ogNo)
  return ogno_;
}
inline ::std::string* PayOrder::release_ogno() {
  clear_has_ogno();
  if (ogno_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = ogno_;
    ogno_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PayOrder::set_allocated_ogno(::std::string* ogno) {
  if (ogno_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete ogno_;
  }
  if (ogno) {
    set_has_ogno();
    ogno_ = ogno;
  } else {
    clear_has_ogno();
    ogno_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:PayOrder.ogNo)
}

// optional string ogSeq = 2;
inline bool PayOrder::has_ogseq() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PayOrder::set_has_ogseq() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PayOrder::clear_has_ogseq() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PayOrder::clear_ogseq() {
  if (ogseq_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ogseq_->clear();
  }
  clear_has_ogseq();
}
inline const ::std::string& PayOrder::ogseq() const {
  // @@protoc_insertion_point(field_get:PayOrder.ogSeq)
  return *ogseq_;
}
inline void PayOrder::set_ogseq(const ::std::string& value) {
  set_has_ogseq();
  if (ogseq_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ogseq_ = new ::std::string;
  }
  ogseq_->assign(value);
  // @@protoc_insertion_point(field_set:PayOrder.ogSeq)
}
inline void PayOrder::set_ogseq(const char* value) {
  set_has_ogseq();
  if (ogseq_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ogseq_ = new ::std::string;
  }
  ogseq_->assign(value);
  // @@protoc_insertion_point(field_set_char:PayOrder.ogSeq)
}
inline void PayOrder::set_ogseq(const char* value, size_t size) {
  set_has_ogseq();
  if (ogseq_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ogseq_ = new ::std::string;
  }
  ogseq_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:PayOrder.ogSeq)
}
inline ::std::string* PayOrder::mutable_ogseq() {
  set_has_ogseq();
  if (ogseq_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ogseq_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:PayOrder.ogSeq)
  return ogseq_;
}
inline ::std::string* PayOrder::release_ogseq() {
  clear_has_ogseq();
  if (ogseq_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = ogseq_;
    ogseq_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PayOrder::set_allocated_ogseq(::std::string* ogseq) {
  if (ogseq_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete ogseq_;
  }
  if (ogseq) {
    set_has_ogseq();
    ogseq_ = ogseq;
  } else {
    clear_has_ogseq();
    ogseq_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:PayOrder.ogSeq)
}

// optional string memGuid = 3;
inline bool PayOrder::has_memguid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PayOrder::set_has_memguid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PayOrder::clear_has_memguid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PayOrder::clear_memguid() {
  if (memguid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    memguid_->clear();
  }
  clear_has_memguid();
}
inline const ::std::string& PayOrder::memguid() const {
  // @@protoc_insertion_point(field_get:PayOrder.memGuid)
  return *memguid_;
}
inline void PayOrder::set_memguid(const ::std::string& value) {
  set_has_memguid();
  if (memguid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    memguid_ = new ::std::string;
  }
  memguid_->assign(value);
  // @@protoc_insertion_point(field_set:PayOrder.memGuid)
}
inline void PayOrder::set_memguid(const char* value) {
  set_has_memguid();
  if (memguid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    memguid_ = new ::std::string;
  }
  memguid_->assign(value);
  // @@protoc_insertion_point(field_set_char:PayOrder.memGuid)
}
inline void PayOrder::set_memguid(const char* value, size_t size) {
  set_has_memguid();
  if (memguid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    memguid_ = new ::std::string;
  }
  memguid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:PayOrder.memGuid)
}
inline ::std::string* PayOrder::mutable_memguid() {
  set_has_memguid();
  if (memguid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    memguid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:PayOrder.memGuid)
  return memguid_;
}
inline ::std::string* PayOrder::release_memguid() {
  clear_has_memguid();
  if (memguid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = memguid_;
    memguid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PayOrder::set_allocated_memguid(::std::string* memguid) {
  if (memguid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete memguid_;
  }
  if (memguid) {
    set_has_memguid();
    memguid_ = memguid;
  } else {
    clear_has_memguid();
    memguid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:PayOrder.memGuid)
}

// optional double totalPay = 4;
inline bool PayOrder::has_totalpay() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PayOrder::set_has_totalpay() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PayOrder::clear_has_totalpay() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PayOrder::clear_totalpay() {
  totalpay_ = 0;
  clear_has_totalpay();
}
inline double PayOrder::totalpay() const {
  // @@protoc_insertion_point(field_get:PayOrder.totalPay)
  return totalpay_;
}
inline void PayOrder::set_totalpay(double value) {
  set_has_totalpay();
  totalpay_ = value;
  // @@protoc_insertion_point(field_set:PayOrder.totalPay)
}

// optional string memberName = 5;
inline bool PayOrder::has_membername() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PayOrder::set_has_membername() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PayOrder::clear_has_membername() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PayOrder::clear_membername() {
  if (membername_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    membername_->clear();
  }
  clear_has_membername();
}
inline const ::std::string& PayOrder::membername() const {
  // @@protoc_insertion_point(field_get:PayOrder.memberName)
  return *membername_;
}
inline void PayOrder::set_membername(const ::std::string& value) {
  set_has_membername();
  if (membername_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    membername_ = new ::std::string;
  }
  membername_->assign(value);
  // @@protoc_insertion_point(field_set:PayOrder.memberName)
}
inline void PayOrder::set_membername(const char* value) {
  set_has_membername();
  if (membername_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    membername_ = new ::std::string;
  }
  membername_->assign(value);
  // @@protoc_insertion_point(field_set_char:PayOrder.memberName)
}
inline void PayOrder::set_membername(const char* value, size_t size) {
  set_has_membername();
  if (membername_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    membername_ = new ::std::string;
  }
  membername_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:PayOrder.memberName)
}
inline ::std::string* PayOrder::mutable_membername() {
  set_has_membername();
  if (membername_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    membername_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:PayOrder.memberName)
  return membername_;
}
inline ::std::string* PayOrder::release_membername() {
  clear_has_membername();
  if (membername_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = membername_;
    membername_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PayOrder::set_allocated_membername(::std::string* membername) {
  if (membername_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete membername_;
  }
  if (membername) {
    set_has_membername();
    membername_ = membername;
  } else {
    clear_has_membername();
    membername_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:PayOrder.memberName)
}

// optional string memberCellphone = 6;
inline bool PayOrder::has_membercellphone() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PayOrder::set_has_membercellphone() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PayOrder::clear_has_membercellphone() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PayOrder::clear_membercellphone() {
  if (membercellphone_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    membercellphone_->clear();
  }
  clear_has_membercellphone();
}
inline const ::std::string& PayOrder::membercellphone() const {
  // @@protoc_insertion_point(field_get:PayOrder.memberCellphone)
  return *membercellphone_;
}
inline void PayOrder::set_membercellphone(const ::std::string& value) {
  set_has_membercellphone();
  if (membercellphone_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    membercellphone_ = new ::std::string;
  }
  membercellphone_->assign(value);
  // @@protoc_insertion_point(field_set:PayOrder.memberCellphone)
}
inline void PayOrder::set_membercellphone(const char* value) {
  set_has_membercellphone();
  if (membercellphone_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    membercellphone_ = new ::std::string;
  }
  membercellphone_->assign(value);
  // @@protoc_insertion_point(field_set_char:PayOrder.memberCellphone)
}
inline void PayOrder::set_membercellphone(const char* value, size_t size) {
  set_has_membercellphone();
  if (membercellphone_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    membercellphone_ = new ::std::string;
  }
  membercellphone_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:PayOrder.memberCellphone)
}
inline ::std::string* PayOrder::mutable_membercellphone() {
  set_has_membercellphone();
  if (membercellphone_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    membercellphone_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:PayOrder.memberCellphone)
  return membercellphone_;
}
inline ::std::string* PayOrder::release_membercellphone() {
  clear_has_membercellphone();
  if (membercellphone_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = membercellphone_;
    membercellphone_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PayOrder::set_allocated_membercellphone(::std::string* membercellphone) {
  if (membercellphone_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete membercellphone_;
  }
  if (membercellphone) {
    set_has_membercellphone();
    membercellphone_ = membercellphone;
  } else {
    clear_has_membercellphone();
    membercellphone_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:PayOrder.memberCellphone)
}

// optional string insertDate = 7;
inline bool PayOrder::has_insertdate() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PayOrder::set_has_insertdate() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PayOrder::clear_has_insertdate() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PayOrder::clear_insertdate() {
  if (insertdate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    insertdate_->clear();
  }
  clear_has_insertdate();
}
inline const ::std::string& PayOrder::insertdate() const {
  // @@protoc_insertion_point(field_get:PayOrder.insertDate)
  return *insertdate_;
}
inline void PayOrder::set_insertdate(const ::std::string& value) {
  set_has_insertdate();
  if (insertdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    insertdate_ = new ::std::string;
  }
  insertdate_->assign(value);
  // @@protoc_insertion_point(field_set:PayOrder.insertDate)
}
inline void PayOrder::set_insertdate(const char* value) {
  set_has_insertdate();
  if (insertdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    insertdate_ = new ::std::string;
  }
  insertdate_->assign(value);
  // @@protoc_insertion_point(field_set_char:PayOrder.insertDate)
}
inline void PayOrder::set_insertdate(const char* value, size_t size) {
  set_has_insertdate();
  if (insertdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    insertdate_ = new ::std::string;
  }
  insertdate_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:PayOrder.insertDate)
}
inline ::std::string* PayOrder::mutable_insertdate() {
  set_has_insertdate();
  if (insertdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    insertdate_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:PayOrder.insertDate)
  return insertdate_;
}
inline ::std::string* PayOrder::release_insertdate() {
  clear_has_insertdate();
  if (insertdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = insertdate_;
    insertdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PayOrder::set_allocated_insertdate(::std::string* insertdate) {
  if (insertdate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete insertdate_;
  }
  if (insertdate) {
    set_has_insertdate();
    insertdate_ = insertdate;
  } else {
    clear_has_insertdate();
    insertdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:PayOrder.insertDate)
}

// optional string payType = 8;
inline bool PayOrder::has_paytype() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PayOrder::set_has_paytype() {
  _has_bits_[0] |= 0x00000080u;
}
inline void PayOrder::clear_has_paytype() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void PayOrder::clear_paytype() {
  if (paytype_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    paytype_->clear();
  }
  clear_has_paytype();
}
inline const ::std::string& PayOrder::paytype() const {
  // @@protoc_insertion_point(field_get:PayOrder.payType)
  return *paytype_;
}
inline void PayOrder::set_paytype(const ::std::string& value) {
  set_has_paytype();
  if (paytype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    paytype_ = new ::std::string;
  }
  paytype_->assign(value);
  // @@protoc_insertion_point(field_set:PayOrder.payType)
}
inline void PayOrder::set_paytype(const char* value) {
  set_has_paytype();
  if (paytype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    paytype_ = new ::std::string;
  }
  paytype_->assign(value);
  // @@protoc_insertion_point(field_set_char:PayOrder.payType)
}
inline void PayOrder::set_paytype(const char* value, size_t size) {
  set_has_paytype();
  if (paytype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    paytype_ = new ::std::string;
  }
  paytype_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:PayOrder.payType)
}
inline ::std::string* PayOrder::mutable_paytype() {
  set_has_paytype();
  if (paytype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    paytype_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:PayOrder.payType)
  return paytype_;
}
inline ::std::string* PayOrder::release_paytype() {
  clear_has_paytype();
  if (paytype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = paytype_;
    paytype_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PayOrder::set_allocated_paytype(::std::string* paytype) {
  if (paytype_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete paytype_;
  }
  if (paytype) {
    set_has_paytype();
    paytype_ = paytype;
  } else {
    clear_has_paytype();
    paytype_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:PayOrder.payType)
}

// optional string packNo = 9;
inline bool PayOrder::has_packno() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void PayOrder::set_has_packno() {
  _has_bits_[0] |= 0x00000100u;
}
inline void PayOrder::clear_has_packno() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void PayOrder::clear_packno() {
  if (packno_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    packno_->clear();
  }
  clear_has_packno();
}
inline const ::std::string& PayOrder::packno() const {
  // @@protoc_insertion_point(field_get:PayOrder.packNo)
  return *packno_;
}
inline void PayOrder::set_packno(const ::std::string& value) {
  set_has_packno();
  if (packno_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    packno_ = new ::std::string;
  }
  packno_->assign(value);
  // @@protoc_insertion_point(field_set:PayOrder.packNo)
}
inline void PayOrder::set_packno(const char* value) {
  set_has_packno();
  if (packno_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    packno_ = new ::std::string;
  }
  packno_->assign(value);
  // @@protoc_insertion_point(field_set_char:PayOrder.packNo)
}
inline void PayOrder::set_packno(const char* value, size_t size) {
  set_has_packno();
  if (packno_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    packno_ = new ::std::string;
  }
  packno_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:PayOrder.packNo)
}
inline ::std::string* PayOrder::mutable_packno() {
  set_has_packno();
  if (packno_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    packno_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:PayOrder.packNo)
  return packno_;
}
inline ::std::string* PayOrder::release_packno() {
  clear_has_packno();
  if (packno_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = packno_;
    packno_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PayOrder::set_allocated_packno(::std::string* packno) {
  if (packno_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete packno_;
  }
  if (packno) {
    set_has_packno();
    packno_ = packno;
  } else {
    clear_has_packno();
    packno_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:PayOrder.packNo)
}

// optional uint32 packState = 10;
inline bool PayOrder::has_packstate() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void PayOrder::set_has_packstate() {
  _has_bits_[0] |= 0x00000200u;
}
inline void PayOrder::clear_has_packstate() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void PayOrder::clear_packstate() {
  packstate_ = 0u;
  clear_has_packstate();
}
inline ::google::protobuf::uint32 PayOrder::packstate() const {
  // @@protoc_insertion_point(field_get:PayOrder.packState)
  return packstate_;
}
inline void PayOrder::set_packstate(::google::protobuf::uint32 value) {
  set_has_packstate();
  packstate_ = value;
  // @@protoc_insertion_point(field_set:PayOrder.packState)
}

// optional string packStateStr = 11;
inline bool PayOrder::has_packstatestr() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void PayOrder::set_has_packstatestr() {
  _has_bits_[0] |= 0x00000400u;
}
inline void PayOrder::clear_has_packstatestr() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void PayOrder::clear_packstatestr() {
  if (packstatestr_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    packstatestr_->clear();
  }
  clear_has_packstatestr();
}
inline const ::std::string& PayOrder::packstatestr() const {
  // @@protoc_insertion_point(field_get:PayOrder.packStateStr)
  return *packstatestr_;
}
inline void PayOrder::set_packstatestr(const ::std::string& value) {
  set_has_packstatestr();
  if (packstatestr_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    packstatestr_ = new ::std::string;
  }
  packstatestr_->assign(value);
  // @@protoc_insertion_point(field_set:PayOrder.packStateStr)
}
inline void PayOrder::set_packstatestr(const char* value) {
  set_has_packstatestr();
  if (packstatestr_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    packstatestr_ = new ::std::string;
  }
  packstatestr_->assign(value);
  // @@protoc_insertion_point(field_set_char:PayOrder.packStateStr)
}
inline void PayOrder::set_packstatestr(const char* value, size_t size) {
  set_has_packstatestr();
  if (packstatestr_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    packstatestr_ = new ::std::string;
  }
  packstatestr_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:PayOrder.packStateStr)
}
inline ::std::string* PayOrder::mutable_packstatestr() {
  set_has_packstatestr();
  if (packstatestr_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    packstatestr_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:PayOrder.packStateStr)
  return packstatestr_;
}
inline ::std::string* PayOrder::release_packstatestr() {
  clear_has_packstatestr();
  if (packstatestr_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = packstatestr_;
    packstatestr_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PayOrder::set_allocated_packstatestr(::std::string* packstatestr) {
  if (packstatestr_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete packstatestr_;
  }
  if (packstatestr) {
    set_has_packstatestr();
    packstatestr_ = packstatestr;
  } else {
    clear_has_packstatestr();
    packstatestr_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:PayOrder.packStateStr)
}

// optional uint32 type = 12;
inline bool PayOrder::has_type() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void PayOrder::set_has_type() {
  _has_bits_[0] |= 0x00000800u;
}
inline void PayOrder::clear_has_type() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void PayOrder::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 PayOrder::type() const {
  // @@protoc_insertion_point(field_get:PayOrder.type)
  return type_;
}
inline void PayOrder::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:PayOrder.type)
}

// optional string packQueryNo = 13;
inline bool PayOrder::has_packqueryno() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void PayOrder::set_has_packqueryno() {
  _has_bits_[0] |= 0x00001000u;
}
inline void PayOrder::clear_has_packqueryno() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void PayOrder::clear_packqueryno() {
  if (packqueryno_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    packqueryno_->clear();
  }
  clear_has_packqueryno();
}
inline const ::std::string& PayOrder::packqueryno() const {
  // @@protoc_insertion_point(field_get:PayOrder.packQueryNo)
  return *packqueryno_;
}
inline void PayOrder::set_packqueryno(const ::std::string& value) {
  set_has_packqueryno();
  if (packqueryno_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    packqueryno_ = new ::std::string;
  }
  packqueryno_->assign(value);
  // @@protoc_insertion_point(field_set:PayOrder.packQueryNo)
}
inline void PayOrder::set_packqueryno(const char* value) {
  set_has_packqueryno();
  if (packqueryno_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    packqueryno_ = new ::std::string;
  }
  packqueryno_->assign(value);
  // @@protoc_insertion_point(field_set_char:PayOrder.packQueryNo)
}
inline void PayOrder::set_packqueryno(const char* value, size_t size) {
  set_has_packqueryno();
  if (packqueryno_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    packqueryno_ = new ::std::string;
  }
  packqueryno_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:PayOrder.packQueryNo)
}
inline ::std::string* PayOrder::mutable_packqueryno() {
  set_has_packqueryno();
  if (packqueryno_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    packqueryno_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:PayOrder.packQueryNo)
  return packqueryno_;
}
inline ::std::string* PayOrder::release_packqueryno() {
  clear_has_packqueryno();
  if (packqueryno_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = packqueryno_;
    packqueryno_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PayOrder::set_allocated_packqueryno(::std::string* packqueryno) {
  if (packqueryno_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete packqueryno_;
  }
  if (packqueryno) {
    set_has_packqueryno();
    packqueryno_ = packqueryno;
  } else {
    clear_has_packqueryno();
    packqueryno_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:PayOrder.packQueryNo)
}

// optional string merchantId = 14;
inline bool PayOrder::has_merchantid() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void PayOrder::set_has_merchantid() {
  _has_bits_[0] |= 0x00002000u;
}
inline void PayOrder::clear_has_merchantid() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void PayOrder::clear_merchantid() {
  if (merchantid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    merchantid_->clear();
  }
  clear_has_merchantid();
}
inline const ::std::string& PayOrder::merchantid() const {
  // @@protoc_insertion_point(field_get:PayOrder.merchantId)
  return *merchantid_;
}
inline void PayOrder::set_merchantid(const ::std::string& value) {
  set_has_merchantid();
  if (merchantid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    merchantid_ = new ::std::string;
  }
  merchantid_->assign(value);
  // @@protoc_insertion_point(field_set:PayOrder.merchantId)
}
inline void PayOrder::set_merchantid(const char* value) {
  set_has_merchantid();
  if (merchantid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    merchantid_ = new ::std::string;
  }
  merchantid_->assign(value);
  // @@protoc_insertion_point(field_set_char:PayOrder.merchantId)
}
inline void PayOrder::set_merchantid(const char* value, size_t size) {
  set_has_merchantid();
  if (merchantid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    merchantid_ = new ::std::string;
  }
  merchantid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:PayOrder.merchantId)
}
inline ::std::string* PayOrder::mutable_merchantid() {
  set_has_merchantid();
  if (merchantid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    merchantid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:PayOrder.merchantId)
  return merchantid_;
}
inline ::std::string* PayOrder::release_merchantid() {
  clear_has_merchantid();
  if (merchantid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = merchantid_;
    merchantid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PayOrder::set_allocated_merchantid(::std::string* merchantid) {
  if (merchantid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete merchantid_;
  }
  if (merchantid) {
    set_has_merchantid();
    merchantid_ = merchantid;
  } else {
    clear_has_merchantid();
    merchantid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:PayOrder.merchantId)
}

// optional double freight = 15;
inline bool PayOrder::has_freight() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void PayOrder::set_has_freight() {
  _has_bits_[0] |= 0x00004000u;
}
inline void PayOrder::clear_has_freight() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void PayOrder::clear_freight() {
  freight_ = 0;
  clear_has_freight();
}
inline double PayOrder::freight() const {
  // @@protoc_insertion_point(field_get:PayOrder.freight)
  return freight_;
}
inline void PayOrder::set_freight(double value) {
  set_has_freight();
  freight_ = value;
  // @@protoc_insertion_point(field_set:PayOrder.freight)
}

// optional string buyername = 16;
inline bool PayOrder::has_buyername() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void PayOrder::set_has_buyername() {
  _has_bits_[0] |= 0x00008000u;
}
inline void PayOrder::clear_has_buyername() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void PayOrder::clear_buyername() {
  if (buyername_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    buyername_->clear();
  }
  clear_has_buyername();
}
inline const ::std::string& PayOrder::buyername() const {
  // @@protoc_insertion_point(field_get:PayOrder.buyername)
  return *buyername_;
}
inline void PayOrder::set_buyername(const ::std::string& value) {
  set_has_buyername();
  if (buyername_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    buyername_ = new ::std::string;
  }
  buyername_->assign(value);
  // @@protoc_insertion_point(field_set:PayOrder.buyername)
}
inline void PayOrder::set_buyername(const char* value) {
  set_has_buyername();
  if (buyername_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    buyername_ = new ::std::string;
  }
  buyername_->assign(value);
  // @@protoc_insertion_point(field_set_char:PayOrder.buyername)
}
inline void PayOrder::set_buyername(const char* value, size_t size) {
  set_has_buyername();
  if (buyername_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    buyername_ = new ::std::string;
  }
  buyername_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:PayOrder.buyername)
}
inline ::std::string* PayOrder::mutable_buyername() {
  set_has_buyername();
  if (buyername_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    buyername_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:PayOrder.buyername)
  return buyername_;
}
inline ::std::string* PayOrder::release_buyername() {
  clear_has_buyername();
  if (buyername_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = buyername_;
    buyername_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PayOrder::set_allocated_buyername(::std::string* buyername) {
  if (buyername_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete buyername_;
  }
  if (buyername) {
    set_has_buyername();
    buyername_ = buyername;
  } else {
    clear_has_buyername();
    buyername_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:PayOrder.buyername)
}

// optional string payDate = 17;
inline bool PayOrder::has_paydate() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void PayOrder::set_has_paydate() {
  _has_bits_[0] |= 0x00010000u;
}
inline void PayOrder::clear_has_paydate() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void PayOrder::clear_paydate() {
  if (paydate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    paydate_->clear();
  }
  clear_has_paydate();
}
inline const ::std::string& PayOrder::paydate() const {
  // @@protoc_insertion_point(field_get:PayOrder.payDate)
  return *paydate_;
}
inline void PayOrder::set_paydate(const ::std::string& value) {
  set_has_paydate();
  if (paydate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    paydate_ = new ::std::string;
  }
  paydate_->assign(value);
  // @@protoc_insertion_point(field_set:PayOrder.payDate)
}
inline void PayOrder::set_paydate(const char* value) {
  set_has_paydate();
  if (paydate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    paydate_ = new ::std::string;
  }
  paydate_->assign(value);
  // @@protoc_insertion_point(field_set_char:PayOrder.payDate)
}
inline void PayOrder::set_paydate(const char* value, size_t size) {
  set_has_paydate();
  if (paydate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    paydate_ = new ::std::string;
  }
  paydate_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:PayOrder.payDate)
}
inline ::std::string* PayOrder::mutable_paydate() {
  set_has_paydate();
  if (paydate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    paydate_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:PayOrder.payDate)
  return paydate_;
}
inline ::std::string* PayOrder::release_paydate() {
  clear_has_paydate();
  if (paydate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = paydate_;
    paydate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PayOrder::set_allocated_paydate(::std::string* paydate) {
  if (paydate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete paydate_;
  }
  if (paydate) {
    set_has_paydate();
    paydate_ = paydate;
  } else {
    clear_has_paydate();
    paydate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:PayOrder.payDate)
}

// repeated .OrderGoodsInfo goodslist = 25;
inline int PayOrder::goodslist_size() const {
  return goodslist_.size();
}
inline void PayOrder::clear_goodslist() {
  goodslist_.Clear();
}
inline const ::OrderGoodsInfo& PayOrder::goodslist(int index) const {
  // @@protoc_insertion_point(field_get:PayOrder.goodslist)
  return goodslist_.Get(index);
}
inline ::OrderGoodsInfo* PayOrder::mutable_goodslist(int index) {
  // @@protoc_insertion_point(field_mutable:PayOrder.goodslist)
  return goodslist_.Mutable(index);
}
inline ::OrderGoodsInfo* PayOrder::add_goodslist() {
  // @@protoc_insertion_point(field_add:PayOrder.goodslist)
  return goodslist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OrderGoodsInfo >&
PayOrder::goodslist() const {
  // @@protoc_insertion_point(field_list:PayOrder.goodslist)
  return goodslist_;
}
inline ::google::protobuf::RepeatedPtrField< ::OrderGoodsInfo >*
PayOrder::mutable_goodslist() {
  // @@protoc_insertion_point(field_mutable_list:PayOrder.goodslist)
  return &goodslist_;
}

// -------------------------------------------------------------------

// GoodsComment

// optional string ogNo = 1;
inline bool GoodsComment::has_ogno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GoodsComment::set_has_ogno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GoodsComment::clear_has_ogno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GoodsComment::clear_ogno() {
  if (ogno_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ogno_->clear();
  }
  clear_has_ogno();
}
inline const ::std::string& GoodsComment::ogno() const {
  // @@protoc_insertion_point(field_get:GoodsComment.ogNo)
  return *ogno_;
}
inline void GoodsComment::set_ogno(const ::std::string& value) {
  set_has_ogno();
  if (ogno_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ogno_ = new ::std::string;
  }
  ogno_->assign(value);
  // @@protoc_insertion_point(field_set:GoodsComment.ogNo)
}
inline void GoodsComment::set_ogno(const char* value) {
  set_has_ogno();
  if (ogno_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ogno_ = new ::std::string;
  }
  ogno_->assign(value);
  // @@protoc_insertion_point(field_set_char:GoodsComment.ogNo)
}
inline void GoodsComment::set_ogno(const char* value, size_t size) {
  set_has_ogno();
  if (ogno_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ogno_ = new ::std::string;
  }
  ogno_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:GoodsComment.ogNo)
}
inline ::std::string* GoodsComment::mutable_ogno() {
  set_has_ogno();
  if (ogno_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ogno_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:GoodsComment.ogNo)
  return ogno_;
}
inline ::std::string* GoodsComment::release_ogno() {
  clear_has_ogno();
  if (ogno_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = ogno_;
    ogno_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GoodsComment::set_allocated_ogno(::std::string* ogno) {
  if (ogno_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete ogno_;
  }
  if (ogno) {
    set_has_ogno();
    ogno_ = ogno;
  } else {
    clear_has_ogno();
    ogno_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:GoodsComment.ogNo)
}

// optional string ogSeq = 2;
inline bool GoodsComment::has_ogseq() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GoodsComment::set_has_ogseq() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GoodsComment::clear_has_ogseq() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GoodsComment::clear_ogseq() {
  if (ogseq_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ogseq_->clear();
  }
  clear_has_ogseq();
}
inline const ::std::string& GoodsComment::ogseq() const {
  // @@protoc_insertion_point(field_get:GoodsComment.ogSeq)
  return *ogseq_;
}
inline void GoodsComment::set_ogseq(const ::std::string& value) {
  set_has_ogseq();
  if (ogseq_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ogseq_ = new ::std::string;
  }
  ogseq_->assign(value);
  // @@protoc_insertion_point(field_set:GoodsComment.ogSeq)
}
inline void GoodsComment::set_ogseq(const char* value) {
  set_has_ogseq();
  if (ogseq_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ogseq_ = new ::std::string;
  }
  ogseq_->assign(value);
  // @@protoc_insertion_point(field_set_char:GoodsComment.ogSeq)
}
inline void GoodsComment::set_ogseq(const char* value, size_t size) {
  set_has_ogseq();
  if (ogseq_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ogseq_ = new ::std::string;
  }
  ogseq_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:GoodsComment.ogSeq)
}
inline ::std::string* GoodsComment::mutable_ogseq() {
  set_has_ogseq();
  if (ogseq_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ogseq_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:GoodsComment.ogSeq)
  return ogseq_;
}
inline ::std::string* GoodsComment::release_ogseq() {
  clear_has_ogseq();
  if (ogseq_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = ogseq_;
    ogseq_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GoodsComment::set_allocated_ogseq(::std::string* ogseq) {
  if (ogseq_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete ogseq_;
  }
  if (ogseq) {
    set_has_ogseq();
    ogseq_ = ogseq;
  } else {
    clear_has_ogseq();
    ogseq_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:GoodsComment.ogSeq)
}

// optional string memGuid = 3;
inline bool GoodsComment::has_memguid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GoodsComment::set_has_memguid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GoodsComment::clear_has_memguid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GoodsComment::clear_memguid() {
  if (memguid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    memguid_->clear();
  }
  clear_has_memguid();
}
inline const ::std::string& GoodsComment::memguid() const {
  // @@protoc_insertion_point(field_get:GoodsComment.memGuid)
  return *memguid_;
}
inline void GoodsComment::set_memguid(const ::std::string& value) {
  set_has_memguid();
  if (memguid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    memguid_ = new ::std::string;
  }
  memguid_->assign(value);
  // @@protoc_insertion_point(field_set:GoodsComment.memGuid)
}
inline void GoodsComment::set_memguid(const char* value) {
  set_has_memguid();
  if (memguid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    memguid_ = new ::std::string;
  }
  memguid_->assign(value);
  // @@protoc_insertion_point(field_set_char:GoodsComment.memGuid)
}
inline void GoodsComment::set_memguid(const char* value, size_t size) {
  set_has_memguid();
  if (memguid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    memguid_ = new ::std::string;
  }
  memguid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:GoodsComment.memGuid)
}
inline ::std::string* GoodsComment::mutable_memguid() {
  set_has_memguid();
  if (memguid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    memguid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:GoodsComment.memGuid)
  return memguid_;
}
inline ::std::string* GoodsComment::release_memguid() {
  clear_has_memguid();
  if (memguid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = memguid_;
    memguid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GoodsComment::set_allocated_memguid(::std::string* memguid) {
  if (memguid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete memguid_;
  }
  if (memguid) {
    set_has_memguid();
    memguid_ = memguid;
  } else {
    clear_has_memguid();
    memguid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:GoodsComment.memGuid)
}

// optional string memberName = 4;
inline bool GoodsComment::has_membername() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GoodsComment::set_has_membername() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GoodsComment::clear_has_membername() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GoodsComment::clear_membername() {
  if (membername_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    membername_->clear();
  }
  clear_has_membername();
}
inline const ::std::string& GoodsComment::membername() const {
  // @@protoc_insertion_point(field_get:GoodsComment.memberName)
  return *membername_;
}
inline void GoodsComment::set_membername(const ::std::string& value) {
  set_has_membername();
  if (membername_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    membername_ = new ::std::string;
  }
  membername_->assign(value);
  // @@protoc_insertion_point(field_set:GoodsComment.memberName)
}
inline void GoodsComment::set_membername(const char* value) {
  set_has_membername();
  if (membername_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    membername_ = new ::std::string;
  }
  membername_->assign(value);
  // @@protoc_insertion_point(field_set_char:GoodsComment.memberName)
}
inline void GoodsComment::set_membername(const char* value, size_t size) {
  set_has_membername();
  if (membername_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    membername_ = new ::std::string;
  }
  membername_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:GoodsComment.memberName)
}
inline ::std::string* GoodsComment::mutable_membername() {
  set_has_membername();
  if (membername_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    membername_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:GoodsComment.memberName)
  return membername_;
}
inline ::std::string* GoodsComment::release_membername() {
  clear_has_membername();
  if (membername_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = membername_;
    membername_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GoodsComment::set_allocated_membername(::std::string* membername) {
  if (membername_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete membername_;
  }
  if (membername) {
    set_has_membername();
    membername_ = membername;
  } else {
    clear_has_membername();
    membername_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:GoodsComment.memberName)
}

// optional string memberCellphone = 5;
inline bool GoodsComment::has_membercellphone() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GoodsComment::set_has_membercellphone() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GoodsComment::clear_has_membercellphone() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GoodsComment::clear_membercellphone() {
  if (membercellphone_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    membercellphone_->clear();
  }
  clear_has_membercellphone();
}
inline const ::std::string& GoodsComment::membercellphone() const {
  // @@protoc_insertion_point(field_get:GoodsComment.memberCellphone)
  return *membercellphone_;
}
inline void GoodsComment::set_membercellphone(const ::std::string& value) {
  set_has_membercellphone();
  if (membercellphone_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    membercellphone_ = new ::std::string;
  }
  membercellphone_->assign(value);
  // @@protoc_insertion_point(field_set:GoodsComment.memberCellphone)
}
inline void GoodsComment::set_membercellphone(const char* value) {
  set_has_membercellphone();
  if (membercellphone_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    membercellphone_ = new ::std::string;
  }
  membercellphone_->assign(value);
  // @@protoc_insertion_point(field_set_char:GoodsComment.memberCellphone)
}
inline void GoodsComment::set_membercellphone(const char* value, size_t size) {
  set_has_membercellphone();
  if (membercellphone_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    membercellphone_ = new ::std::string;
  }
  membercellphone_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:GoodsComment.memberCellphone)
}
inline ::std::string* GoodsComment::mutable_membercellphone() {
  set_has_membercellphone();
  if (membercellphone_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    membercellphone_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:GoodsComment.memberCellphone)
  return membercellphone_;
}
inline ::std::string* GoodsComment::release_membercellphone() {
  clear_has_membercellphone();
  if (membercellphone_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = membercellphone_;
    membercellphone_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GoodsComment::set_allocated_membercellphone(::std::string* membercellphone) {
  if (membercellphone_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete membercellphone_;
  }
  if (membercellphone) {
    set_has_membercellphone();
    membercellphone_ = membercellphone;
  } else {
    clear_has_membercellphone();
    membercellphone_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:GoodsComment.memberCellphone)
}

// optional string insertDate = 6;
inline bool GoodsComment::has_insertdate() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GoodsComment::set_has_insertdate() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GoodsComment::clear_has_insertdate() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GoodsComment::clear_insertdate() {
  if (insertdate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    insertdate_->clear();
  }
  clear_has_insertdate();
}
inline const ::std::string& GoodsComment::insertdate() const {
  // @@protoc_insertion_point(field_get:GoodsComment.insertDate)
  return *insertdate_;
}
inline void GoodsComment::set_insertdate(const ::std::string& value) {
  set_has_insertdate();
  if (insertdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    insertdate_ = new ::std::string;
  }
  insertdate_->assign(value);
  // @@protoc_insertion_point(field_set:GoodsComment.insertDate)
}
inline void GoodsComment::set_insertdate(const char* value) {
  set_has_insertdate();
  if (insertdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    insertdate_ = new ::std::string;
  }
  insertdate_->assign(value);
  // @@protoc_insertion_point(field_set_char:GoodsComment.insertDate)
}
inline void GoodsComment::set_insertdate(const char* value, size_t size) {
  set_has_insertdate();
  if (insertdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    insertdate_ = new ::std::string;
  }
  insertdate_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:GoodsComment.insertDate)
}
inline ::std::string* GoodsComment::mutable_insertdate() {
  set_has_insertdate();
  if (insertdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    insertdate_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:GoodsComment.insertDate)
  return insertdate_;
}
inline ::std::string* GoodsComment::release_insertdate() {
  clear_has_insertdate();
  if (insertdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = insertdate_;
    insertdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GoodsComment::set_allocated_insertdate(::std::string* insertdate) {
  if (insertdate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete insertdate_;
  }
  if (insertdate) {
    set_has_insertdate();
    insertdate_ = insertdate;
  } else {
    clear_has_insertdate();
    insertdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:GoodsComment.insertDate)
}

// optional string payType = 7;
inline bool GoodsComment::has_paytype() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GoodsComment::set_has_paytype() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GoodsComment::clear_has_paytype() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GoodsComment::clear_paytype() {
  if (paytype_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    paytype_->clear();
  }
  clear_has_paytype();
}
inline const ::std::string& GoodsComment::paytype() const {
  // @@protoc_insertion_point(field_get:GoodsComment.payType)
  return *paytype_;
}
inline void GoodsComment::set_paytype(const ::std::string& value) {
  set_has_paytype();
  if (paytype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    paytype_ = new ::std::string;
  }
  paytype_->assign(value);
  // @@protoc_insertion_point(field_set:GoodsComment.payType)
}
inline void GoodsComment::set_paytype(const char* value) {
  set_has_paytype();
  if (paytype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    paytype_ = new ::std::string;
  }
  paytype_->assign(value);
  // @@protoc_insertion_point(field_set_char:GoodsComment.payType)
}
inline void GoodsComment::set_paytype(const char* value, size_t size) {
  set_has_paytype();
  if (paytype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    paytype_ = new ::std::string;
  }
  paytype_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:GoodsComment.payType)
}
inline ::std::string* GoodsComment::mutable_paytype() {
  set_has_paytype();
  if (paytype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    paytype_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:GoodsComment.payType)
  return paytype_;
}
inline ::std::string* GoodsComment::release_paytype() {
  clear_has_paytype();
  if (paytype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = paytype_;
    paytype_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GoodsComment::set_allocated_paytype(::std::string* paytype) {
  if (paytype_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete paytype_;
  }
  if (paytype) {
    set_has_paytype();
    paytype_ = paytype;
  } else {
    clear_has_paytype();
    paytype_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:GoodsComment.payType)
}

// optional string merchantId = 8;
inline bool GoodsComment::has_merchantid() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void GoodsComment::set_has_merchantid() {
  _has_bits_[0] |= 0x00000080u;
}
inline void GoodsComment::clear_has_merchantid() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void GoodsComment::clear_merchantid() {
  if (merchantid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    merchantid_->clear();
  }
  clear_has_merchantid();
}
inline const ::std::string& GoodsComment::merchantid() const {
  // @@protoc_insertion_point(field_get:GoodsComment.merchantId)
  return *merchantid_;
}
inline void GoodsComment::set_merchantid(const ::std::string& value) {
  set_has_merchantid();
  if (merchantid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    merchantid_ = new ::std::string;
  }
  merchantid_->assign(value);
  // @@protoc_insertion_point(field_set:GoodsComment.merchantId)
}
inline void GoodsComment::set_merchantid(const char* value) {
  set_has_merchantid();
  if (merchantid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    merchantid_ = new ::std::string;
  }
  merchantid_->assign(value);
  // @@protoc_insertion_point(field_set_char:GoodsComment.merchantId)
}
inline void GoodsComment::set_merchantid(const char* value, size_t size) {
  set_has_merchantid();
  if (merchantid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    merchantid_ = new ::std::string;
  }
  merchantid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:GoodsComment.merchantId)
}
inline ::std::string* GoodsComment::mutable_merchantid() {
  set_has_merchantid();
  if (merchantid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    merchantid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:GoodsComment.merchantId)
  return merchantid_;
}
inline ::std::string* GoodsComment::release_merchantid() {
  clear_has_merchantid();
  if (merchantid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = merchantid_;
    merchantid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GoodsComment::set_allocated_merchantid(::std::string* merchantid) {
  if (merchantid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete merchantid_;
  }
  if (merchantid) {
    set_has_merchantid();
    merchantid_ = merchantid;
  } else {
    clear_has_merchantid();
    merchantid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:GoodsComment.merchantId)
}

// optional string bugername = 9;
inline bool GoodsComment::has_bugername() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void GoodsComment::set_has_bugername() {
  _has_bits_[0] |= 0x00000100u;
}
inline void GoodsComment::clear_has_bugername() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void GoodsComment::clear_bugername() {
  if (bugername_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bugername_->clear();
  }
  clear_has_bugername();
}
inline const ::std::string& GoodsComment::bugername() const {
  // @@protoc_insertion_point(field_get:GoodsComment.bugername)
  return *bugername_;
}
inline void GoodsComment::set_bugername(const ::std::string& value) {
  set_has_bugername();
  if (bugername_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bugername_ = new ::std::string;
  }
  bugername_->assign(value);
  // @@protoc_insertion_point(field_set:GoodsComment.bugername)
}
inline void GoodsComment::set_bugername(const char* value) {
  set_has_bugername();
  if (bugername_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bugername_ = new ::std::string;
  }
  bugername_->assign(value);
  // @@protoc_insertion_point(field_set_char:GoodsComment.bugername)
}
inline void GoodsComment::set_bugername(const char* value, size_t size) {
  set_has_bugername();
  if (bugername_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bugername_ = new ::std::string;
  }
  bugername_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:GoodsComment.bugername)
}
inline ::std::string* GoodsComment::mutable_bugername() {
  set_has_bugername();
  if (bugername_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bugername_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:GoodsComment.bugername)
  return bugername_;
}
inline ::std::string* GoodsComment::release_bugername() {
  clear_has_bugername();
  if (bugername_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = bugername_;
    bugername_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GoodsComment::set_allocated_bugername(::std::string* bugername) {
  if (bugername_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete bugername_;
  }
  if (bugername) {
    set_has_bugername();
    bugername_ = bugername;
  } else {
    clear_has_bugername();
    bugername_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:GoodsComment.bugername)
}

// optional double evaluatelevel = 10;
inline bool GoodsComment::has_evaluatelevel() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void GoodsComment::set_has_evaluatelevel() {
  _has_bits_[0] |= 0x00000200u;
}
inline void GoodsComment::clear_has_evaluatelevel() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void GoodsComment::clear_evaluatelevel() {
  evaluatelevel_ = 0;
  clear_has_evaluatelevel();
}
inline double GoodsComment::evaluatelevel() const {
  // @@protoc_insertion_point(field_get:GoodsComment.evaluatelevel)
  return evaluatelevel_;
}
inline void GoodsComment::set_evaluatelevel(double value) {
  set_has_evaluatelevel();
  evaluatelevel_ = value;
  // @@protoc_insertion_point(field_set:GoodsComment.evaluatelevel)
}

// optional string evaluatecontext = 11;
inline bool GoodsComment::has_evaluatecontext() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void GoodsComment::set_has_evaluatecontext() {
  _has_bits_[0] |= 0x00000400u;
}
inline void GoodsComment::clear_has_evaluatecontext() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void GoodsComment::clear_evaluatecontext() {
  if (evaluatecontext_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    evaluatecontext_->clear();
  }
  clear_has_evaluatecontext();
}
inline const ::std::string& GoodsComment::evaluatecontext() const {
  // @@protoc_insertion_point(field_get:GoodsComment.evaluatecontext)
  return *evaluatecontext_;
}
inline void GoodsComment::set_evaluatecontext(const ::std::string& value) {
  set_has_evaluatecontext();
  if (evaluatecontext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    evaluatecontext_ = new ::std::string;
  }
  evaluatecontext_->assign(value);
  // @@protoc_insertion_point(field_set:GoodsComment.evaluatecontext)
}
inline void GoodsComment::set_evaluatecontext(const char* value) {
  set_has_evaluatecontext();
  if (evaluatecontext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    evaluatecontext_ = new ::std::string;
  }
  evaluatecontext_->assign(value);
  // @@protoc_insertion_point(field_set_char:GoodsComment.evaluatecontext)
}
inline void GoodsComment::set_evaluatecontext(const char* value, size_t size) {
  set_has_evaluatecontext();
  if (evaluatecontext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    evaluatecontext_ = new ::std::string;
  }
  evaluatecontext_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:GoodsComment.evaluatecontext)
}
inline ::std::string* GoodsComment::mutable_evaluatecontext() {
  set_has_evaluatecontext();
  if (evaluatecontext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    evaluatecontext_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:GoodsComment.evaluatecontext)
  return evaluatecontext_;
}
inline ::std::string* GoodsComment::release_evaluatecontext() {
  clear_has_evaluatecontext();
  if (evaluatecontext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = evaluatecontext_;
    evaluatecontext_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GoodsComment::set_allocated_evaluatecontext(::std::string* evaluatecontext) {
  if (evaluatecontext_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete evaluatecontext_;
  }
  if (evaluatecontext) {
    set_has_evaluatecontext();
    evaluatecontext_ = evaluatecontext;
  } else {
    clear_has_evaluatecontext();
    evaluatecontext_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:GoodsComment.evaluatecontext)
}

// optional string commentDate = 17;
inline bool GoodsComment::has_commentdate() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void GoodsComment::set_has_commentdate() {
  _has_bits_[0] |= 0x00000800u;
}
inline void GoodsComment::clear_has_commentdate() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void GoodsComment::clear_commentdate() {
  if (commentdate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    commentdate_->clear();
  }
  clear_has_commentdate();
}
inline const ::std::string& GoodsComment::commentdate() const {
  // @@protoc_insertion_point(field_get:GoodsComment.commentDate)
  return *commentdate_;
}
inline void GoodsComment::set_commentdate(const ::std::string& value) {
  set_has_commentdate();
  if (commentdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    commentdate_ = new ::std::string;
  }
  commentdate_->assign(value);
  // @@protoc_insertion_point(field_set:GoodsComment.commentDate)
}
inline void GoodsComment::set_commentdate(const char* value) {
  set_has_commentdate();
  if (commentdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    commentdate_ = new ::std::string;
  }
  commentdate_->assign(value);
  // @@protoc_insertion_point(field_set_char:GoodsComment.commentDate)
}
inline void GoodsComment::set_commentdate(const char* value, size_t size) {
  set_has_commentdate();
  if (commentdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    commentdate_ = new ::std::string;
  }
  commentdate_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:GoodsComment.commentDate)
}
inline ::std::string* GoodsComment::mutable_commentdate() {
  set_has_commentdate();
  if (commentdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    commentdate_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:GoodsComment.commentDate)
  return commentdate_;
}
inline ::std::string* GoodsComment::release_commentdate() {
  clear_has_commentdate();
  if (commentdate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = commentdate_;
    commentdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GoodsComment::set_allocated_commentdate(::std::string* commentdate) {
  if (commentdate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete commentdate_;
  }
  if (commentdate) {
    set_has_commentdate();
    commentdate_ = commentdate;
  } else {
    clear_has_commentdate();
    commentdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:GoodsComment.commentDate)
}

// optional .OrderGoodsInfo goods = 15;
inline bool GoodsComment::has_goods() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void GoodsComment::set_has_goods() {
  _has_bits_[0] |= 0x00001000u;
}
inline void GoodsComment::clear_has_goods() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void GoodsComment::clear_goods() {
  if (goods_ != NULL) goods_->::OrderGoodsInfo::Clear();
  clear_has_goods();
}
inline const ::OrderGoodsInfo& GoodsComment::goods() const {
  // @@protoc_insertion_point(field_get:GoodsComment.goods)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return goods_ != NULL ? *goods_ : *default_instance().goods_;
#else
  return goods_ != NULL ? *goods_ : *default_instance_->goods_;
#endif
}
inline ::OrderGoodsInfo* GoodsComment::mutable_goods() {
  set_has_goods();
  if (goods_ == NULL) goods_ = new ::OrderGoodsInfo;
  // @@protoc_insertion_point(field_mutable:GoodsComment.goods)
  return goods_;
}
inline ::OrderGoodsInfo* GoodsComment::release_goods() {
  clear_has_goods();
  ::OrderGoodsInfo* temp = goods_;
  goods_ = NULL;
  return temp;
}
inline void GoodsComment::set_allocated_goods(::OrderGoodsInfo* goods) {
  delete goods_;
  goods_ = goods;
  if (goods) {
    set_has_goods();
  } else {
    clear_has_goods();
  }
  // @@protoc_insertion_point(field_set_allocated:GoodsComment.goods)
}

// -------------------------------------------------------------------

// ReturnGoodsInfo

// optional string skuId = 1;
inline bool ReturnGoodsInfo::has_skuid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReturnGoodsInfo::set_has_skuid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReturnGoodsInfo::clear_has_skuid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReturnGoodsInfo::clear_skuid() {
  if (skuid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    skuid_->clear();
  }
  clear_has_skuid();
}
inline const ::std::string& ReturnGoodsInfo::skuid() const {
  // @@protoc_insertion_point(field_get:ReturnGoodsInfo.skuId)
  return *skuid_;
}
inline void ReturnGoodsInfo::set_skuid(const ::std::string& value) {
  set_has_skuid();
  if (skuid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    skuid_ = new ::std::string;
  }
  skuid_->assign(value);
  // @@protoc_insertion_point(field_set:ReturnGoodsInfo.skuId)
}
inline void ReturnGoodsInfo::set_skuid(const char* value) {
  set_has_skuid();
  if (skuid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    skuid_ = new ::std::string;
  }
  skuid_->assign(value);
  // @@protoc_insertion_point(field_set_char:ReturnGoodsInfo.skuId)
}
inline void ReturnGoodsInfo::set_skuid(const char* value, size_t size) {
  set_has_skuid();
  if (skuid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    skuid_ = new ::std::string;
  }
  skuid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ReturnGoodsInfo.skuId)
}
inline ::std::string* ReturnGoodsInfo::mutable_skuid() {
  set_has_skuid();
  if (skuid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    skuid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ReturnGoodsInfo.skuId)
  return skuid_;
}
inline ::std::string* ReturnGoodsInfo::release_skuid() {
  clear_has_skuid();
  if (skuid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = skuid_;
    skuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ReturnGoodsInfo::set_allocated_skuid(::std::string* skuid) {
  if (skuid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete skuid_;
  }
  if (skuid) {
    set_has_skuid();
    skuid_ = skuid;
  } else {
    clear_has_skuid();
    skuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ReturnGoodsInfo.skuId)
}

// optional double productPrice = 2;
inline bool ReturnGoodsInfo::has_productprice() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReturnGoodsInfo::set_has_productprice() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReturnGoodsInfo::clear_has_productprice() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReturnGoodsInfo::clear_productprice() {
  productprice_ = 0;
  clear_has_productprice();
}
inline double ReturnGoodsInfo::productprice() const {
  // @@protoc_insertion_point(field_get:ReturnGoodsInfo.productPrice)
  return productprice_;
}
inline void ReturnGoodsInfo::set_productprice(double value) {
  set_has_productprice();
  productprice_ = value;
  // @@protoc_insertion_point(field_set:ReturnGoodsInfo.productPrice)
}

// optional int32 productQty = 3;
inline bool ReturnGoodsInfo::has_productqty() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ReturnGoodsInfo::set_has_productqty() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ReturnGoodsInfo::clear_has_productqty() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ReturnGoodsInfo::clear_productqty() {
  productqty_ = 0;
  clear_has_productqty();
}
inline ::google::protobuf::int32 ReturnGoodsInfo::productqty() const {
  // @@protoc_insertion_point(field_get:ReturnGoodsInfo.productQty)
  return productqty_;
}
inline void ReturnGoodsInfo::set_productqty(::google::protobuf::int32 value) {
  set_has_productqty();
  productqty_ = value;
  // @@protoc_insertion_point(field_set:ReturnGoodsInfo.productQty)
}

// optional int32 returnQty = 4;
inline bool ReturnGoodsInfo::has_returnqty() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ReturnGoodsInfo::set_has_returnqty() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ReturnGoodsInfo::clear_has_returnqty() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ReturnGoodsInfo::clear_returnqty() {
  returnqty_ = 0;
  clear_has_returnqty();
}
inline ::google::protobuf::int32 ReturnGoodsInfo::returnqty() const {
  // @@protoc_insertion_point(field_get:ReturnGoodsInfo.returnQty)
  return returnqty_;
}
inline void ReturnGoodsInfo::set_returnqty(::google::protobuf::int32 value) {
  set_has_returnqty();
  returnqty_ = value;
  // @@protoc_insertion_point(field_set:ReturnGoodsInfo.returnQty)
}

// optional string productMainUrl = 5;
inline bool ReturnGoodsInfo::has_productmainurl() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ReturnGoodsInfo::set_has_productmainurl() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ReturnGoodsInfo::clear_has_productmainurl() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ReturnGoodsInfo::clear_productmainurl() {
  if (productmainurl_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    productmainurl_->clear();
  }
  clear_has_productmainurl();
}
inline const ::std::string& ReturnGoodsInfo::productmainurl() const {
  // @@protoc_insertion_point(field_get:ReturnGoodsInfo.productMainUrl)
  return *productmainurl_;
}
inline void ReturnGoodsInfo::set_productmainurl(const ::std::string& value) {
  set_has_productmainurl();
  if (productmainurl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    productmainurl_ = new ::std::string;
  }
  productmainurl_->assign(value);
  // @@protoc_insertion_point(field_set:ReturnGoodsInfo.productMainUrl)
}
inline void ReturnGoodsInfo::set_productmainurl(const char* value) {
  set_has_productmainurl();
  if (productmainurl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    productmainurl_ = new ::std::string;
  }
  productmainurl_->assign(value);
  // @@protoc_insertion_point(field_set_char:ReturnGoodsInfo.productMainUrl)
}
inline void ReturnGoodsInfo::set_productmainurl(const char* value, size_t size) {
  set_has_productmainurl();
  if (productmainurl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    productmainurl_ = new ::std::string;
  }
  productmainurl_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ReturnGoodsInfo.productMainUrl)
}
inline ::std::string* ReturnGoodsInfo::mutable_productmainurl() {
  set_has_productmainurl();
  if (productmainurl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    productmainurl_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ReturnGoodsInfo.productMainUrl)
  return productmainurl_;
}
inline ::std::string* ReturnGoodsInfo::release_productmainurl() {
  clear_has_productmainurl();
  if (productmainurl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = productmainurl_;
    productmainurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ReturnGoodsInfo::set_allocated_productmainurl(::std::string* productmainurl) {
  if (productmainurl_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete productmainurl_;
  }
  if (productmainurl) {
    set_has_productmainurl();
    productmainurl_ = productmainurl;
  } else {
    clear_has_productmainurl();
    productmainurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ReturnGoodsInfo.productMainUrl)
}

// optional string sourceUrl = 6;
inline bool ReturnGoodsInfo::has_sourceurl() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ReturnGoodsInfo::set_has_sourceurl() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ReturnGoodsInfo::clear_has_sourceurl() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ReturnGoodsInfo::clear_sourceurl() {
  if (sourceurl_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sourceurl_->clear();
  }
  clear_has_sourceurl();
}
inline const ::std::string& ReturnGoodsInfo::sourceurl() const {
  // @@protoc_insertion_point(field_get:ReturnGoodsInfo.sourceUrl)
  return *sourceurl_;
}
inline void ReturnGoodsInfo::set_sourceurl(const ::std::string& value) {
  set_has_sourceurl();
  if (sourceurl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sourceurl_ = new ::std::string;
  }
  sourceurl_->assign(value);
  // @@protoc_insertion_point(field_set:ReturnGoodsInfo.sourceUrl)
}
inline void ReturnGoodsInfo::set_sourceurl(const char* value) {
  set_has_sourceurl();
  if (sourceurl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sourceurl_ = new ::std::string;
  }
  sourceurl_->assign(value);
  // @@protoc_insertion_point(field_set_char:ReturnGoodsInfo.sourceUrl)
}
inline void ReturnGoodsInfo::set_sourceurl(const char* value, size_t size) {
  set_has_sourceurl();
  if (sourceurl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sourceurl_ = new ::std::string;
  }
  sourceurl_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ReturnGoodsInfo.sourceUrl)
}
inline ::std::string* ReturnGoodsInfo::mutable_sourceurl() {
  set_has_sourceurl();
  if (sourceurl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sourceurl_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ReturnGoodsInfo.sourceUrl)
  return sourceurl_;
}
inline ::std::string* ReturnGoodsInfo::release_sourceurl() {
  clear_has_sourceurl();
  if (sourceurl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = sourceurl_;
    sourceurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ReturnGoodsInfo::set_allocated_sourceurl(::std::string* sourceurl) {
  if (sourceurl_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete sourceurl_;
  }
  if (sourceurl) {
    set_has_sourceurl();
    sourceurl_ = sourceurl;
  } else {
    clear_has_sourceurl();
    sourceurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ReturnGoodsInfo.sourceUrl)
}

// optional string color = 7;
inline bool ReturnGoodsInfo::has_color() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ReturnGoodsInfo::set_has_color() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ReturnGoodsInfo::clear_has_color() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ReturnGoodsInfo::clear_color() {
  if (color_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    color_->clear();
  }
  clear_has_color();
}
inline const ::std::string& ReturnGoodsInfo::color() const {
  // @@protoc_insertion_point(field_get:ReturnGoodsInfo.color)
  return *color_;
}
inline void ReturnGoodsInfo::set_color(const ::std::string& value) {
  set_has_color();
  if (color_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    color_ = new ::std::string;
  }
  color_->assign(value);
  // @@protoc_insertion_point(field_set:ReturnGoodsInfo.color)
}
inline void ReturnGoodsInfo::set_color(const char* value) {
  set_has_color();
  if (color_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    color_ = new ::std::string;
  }
  color_->assign(value);
  // @@protoc_insertion_point(field_set_char:ReturnGoodsInfo.color)
}
inline void ReturnGoodsInfo::set_color(const char* value, size_t size) {
  set_has_color();
  if (color_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    color_ = new ::std::string;
  }
  color_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ReturnGoodsInfo.color)
}
inline ::std::string* ReturnGoodsInfo::mutable_color() {
  set_has_color();
  if (color_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    color_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ReturnGoodsInfo.color)
  return color_;
}
inline ::std::string* ReturnGoodsInfo::release_color() {
  clear_has_color();
  if (color_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = color_;
    color_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ReturnGoodsInfo::set_allocated_color(::std::string* color) {
  if (color_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete color_;
  }
  if (color) {
    set_has_color();
    color_ = color;
  } else {
    clear_has_color();
    color_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ReturnGoodsInfo.color)
}

// optional string size = 8;
inline bool ReturnGoodsInfo::has_size() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ReturnGoodsInfo::set_has_size() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ReturnGoodsInfo::clear_has_size() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ReturnGoodsInfo::clear_size() {
  if (size_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    size_->clear();
  }
  clear_has_size();
}
inline const ::std::string& ReturnGoodsInfo::size() const {
  // @@protoc_insertion_point(field_get:ReturnGoodsInfo.size)
  return *size_;
}
inline void ReturnGoodsInfo::set_size(const ::std::string& value) {
  set_has_size();
  if (size_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    size_ = new ::std::string;
  }
  size_->assign(value);
  // @@protoc_insertion_point(field_set:ReturnGoodsInfo.size)
}
inline void ReturnGoodsInfo::set_size(const char* value) {
  set_has_size();
  if (size_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    size_ = new ::std::string;
  }
  size_->assign(value);
  // @@protoc_insertion_point(field_set_char:ReturnGoodsInfo.size)
}
inline void ReturnGoodsInfo::set_size(const char* value, size_t size) {
  set_has_size();
  if (size_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    size_ = new ::std::string;
  }
  size_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ReturnGoodsInfo.size)
}
inline ::std::string* ReturnGoodsInfo::mutable_size() {
  set_has_size();
  if (size_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    size_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ReturnGoodsInfo.size)
  return size_;
}
inline ::std::string* ReturnGoodsInfo::release_size() {
  clear_has_size();
  if (size_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = size_;
    size_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ReturnGoodsInfo::set_allocated_size(::std::string* size) {
  if (size_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete size_;
  }
  if (size) {
    set_has_size();
    size_ = size;
  } else {
    clear_has_size();
    size_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ReturnGoodsInfo.size)
}

// optional string reason = 9;
inline bool ReturnGoodsInfo::has_reason() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ReturnGoodsInfo::set_has_reason() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ReturnGoodsInfo::clear_has_reason() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ReturnGoodsInfo::clear_reason() {
  if (reason_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    reason_->clear();
  }
  clear_has_reason();
}
inline const ::std::string& ReturnGoodsInfo::reason() const {
  // @@protoc_insertion_point(field_get:ReturnGoodsInfo.reason)
  return *reason_;
}
inline void ReturnGoodsInfo::set_reason(const ::std::string& value) {
  set_has_reason();
  if (reason_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    reason_ = new ::std::string;
  }
  reason_->assign(value);
  // @@protoc_insertion_point(field_set:ReturnGoodsInfo.reason)
}
inline void ReturnGoodsInfo::set_reason(const char* value) {
  set_has_reason();
  if (reason_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    reason_ = new ::std::string;
  }
  reason_->assign(value);
  // @@protoc_insertion_point(field_set_char:ReturnGoodsInfo.reason)
}
inline void ReturnGoodsInfo::set_reason(const char* value, size_t size) {
  set_has_reason();
  if (reason_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    reason_ = new ::std::string;
  }
  reason_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ReturnGoodsInfo.reason)
}
inline ::std::string* ReturnGoodsInfo::mutable_reason() {
  set_has_reason();
  if (reason_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    reason_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ReturnGoodsInfo.reason)
  return reason_;
}
inline ::std::string* ReturnGoodsInfo::release_reason() {
  clear_has_reason();
  if (reason_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = reason_;
    reason_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ReturnGoodsInfo::set_allocated_reason(::std::string* reason) {
  if (reason_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete reason_;
  }
  if (reason) {
    set_has_reason();
    reason_ = reason;
  } else {
    clear_has_reason();
    reason_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ReturnGoodsInfo.reason)
}

// optional double aprnPromote = 10;
inline bool ReturnGoodsInfo::has_aprnpromote() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ReturnGoodsInfo::set_has_aprnpromote() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ReturnGoodsInfo::clear_has_aprnpromote() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ReturnGoodsInfo::clear_aprnpromote() {
  aprnpromote_ = 0;
  clear_has_aprnpromote();
}
inline double ReturnGoodsInfo::aprnpromote() const {
  // @@protoc_insertion_point(field_get:ReturnGoodsInfo.aprnPromote)
  return aprnpromote_;
}
inline void ReturnGoodsInfo::set_aprnpromote(double value) {
  set_has_aprnpromote();
  aprnpromote_ = value;
  // @@protoc_insertion_point(field_set:ReturnGoodsInfo.aprnPromote)
}

// optional double aprnVoucher = 11;
inline bool ReturnGoodsInfo::has_aprnvoucher() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ReturnGoodsInfo::set_has_aprnvoucher() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ReturnGoodsInfo::clear_has_aprnvoucher() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ReturnGoodsInfo::clear_aprnvoucher() {
  aprnvoucher_ = 0;
  clear_has_aprnvoucher();
}
inline double ReturnGoodsInfo::aprnvoucher() const {
  // @@protoc_insertion_point(field_get:ReturnGoodsInfo.aprnVoucher)
  return aprnvoucher_;
}
inline void ReturnGoodsInfo::set_aprnvoucher(double value) {
  set_has_aprnvoucher();
  aprnvoucher_ = value;
  // @@protoc_insertion_point(field_set:ReturnGoodsInfo.aprnVoucher)
}

// optional double shippingTax = 12;
inline bool ReturnGoodsInfo::has_shippingtax() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void ReturnGoodsInfo::set_has_shippingtax() {
  _has_bits_[0] |= 0x00000800u;
}
inline void ReturnGoodsInfo::clear_has_shippingtax() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void ReturnGoodsInfo::clear_shippingtax() {
  shippingtax_ = 0;
  clear_has_shippingtax();
}
inline double ReturnGoodsInfo::shippingtax() const {
  // @@protoc_insertion_point(field_get:ReturnGoodsInfo.shippingTax)
  return shippingtax_;
}
inline void ReturnGoodsInfo::set_shippingtax(double value) {
  set_has_shippingtax();
  shippingtax_ = value;
  // @@protoc_insertion_point(field_set:ReturnGoodsInfo.shippingTax)
}

// optional double origPrice = 13;
inline bool ReturnGoodsInfo::has_origprice() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void ReturnGoodsInfo::set_has_origprice() {
  _has_bits_[0] |= 0x00001000u;
}
inline void ReturnGoodsInfo::clear_has_origprice() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void ReturnGoodsInfo::clear_origprice() {
  origprice_ = 0;
  clear_has_origprice();
}
inline double ReturnGoodsInfo::origprice() const {
  // @@protoc_insertion_point(field_get:ReturnGoodsInfo.origPrice)
  return origprice_;
}
inline void ReturnGoodsInfo::set_origprice(double value) {
  set_has_origprice();
  origprice_ = value;
  // @@protoc_insertion_point(field_set:ReturnGoodsInfo.origPrice)
}

// optional double aprnPoint = 14;
inline bool ReturnGoodsInfo::has_aprnpoint() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void ReturnGoodsInfo::set_has_aprnpoint() {
  _has_bits_[0] |= 0x00002000u;
}
inline void ReturnGoodsInfo::clear_has_aprnpoint() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void ReturnGoodsInfo::clear_aprnpoint() {
  aprnpoint_ = 0;
  clear_has_aprnpoint();
}
inline double ReturnGoodsInfo::aprnpoint() const {
  // @@protoc_insertion_point(field_get:ReturnGoodsInfo.aprnPoint)
  return aprnpoint_;
}
inline void ReturnGoodsInfo::set_aprnpoint(double value) {
  set_has_aprnpoint();
  aprnpoint_ = value;
  // @@protoc_insertion_point(field_set:ReturnGoodsInfo.aprnPoint)
}

// optional double aprnPointPrice = 15;
inline bool ReturnGoodsInfo::has_aprnpointprice() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void ReturnGoodsInfo::set_has_aprnpointprice() {
  _has_bits_[0] |= 0x00004000u;
}
inline void ReturnGoodsInfo::clear_has_aprnpointprice() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void ReturnGoodsInfo::clear_aprnpointprice() {
  aprnpointprice_ = 0;
  clear_has_aprnpointprice();
}
inline double ReturnGoodsInfo::aprnpointprice() const {
  // @@protoc_insertion_point(field_get:ReturnGoodsInfo.aprnPointPrice)
  return aprnpointprice_;
}
inline void ReturnGoodsInfo::set_aprnpointprice(double value) {
  set_has_aprnpointprice();
  aprnpointprice_ = value;
  // @@protoc_insertion_point(field_set:ReturnGoodsInfo.aprnPointPrice)
}

// optional double aprnCash = 16;
inline bool ReturnGoodsInfo::has_aprncash() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void ReturnGoodsInfo::set_has_aprncash() {
  _has_bits_[0] |= 0x00008000u;
}
inline void ReturnGoodsInfo::clear_has_aprncash() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void ReturnGoodsInfo::clear_aprncash() {
  aprncash_ = 0;
  clear_has_aprncash();
}
inline double ReturnGoodsInfo::aprncash() const {
  // @@protoc_insertion_point(field_get:ReturnGoodsInfo.aprnCash)
  return aprncash_;
}
inline void ReturnGoodsInfo::set_aprncash(double value) {
  set_has_aprncash();
  aprncash_ = value;
  // @@protoc_insertion_point(field_set:ReturnGoodsInfo.aprnCash)
}

// optional double refundablePrice = 17;
inline bool ReturnGoodsInfo::has_refundableprice() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void ReturnGoodsInfo::set_has_refundableprice() {
  _has_bits_[0] |= 0x00010000u;
}
inline void ReturnGoodsInfo::clear_has_refundableprice() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void ReturnGoodsInfo::clear_refundableprice() {
  refundableprice_ = 0;
  clear_has_refundableprice();
}
inline double ReturnGoodsInfo::refundableprice() const {
  // @@protoc_insertion_point(field_get:ReturnGoodsInfo.refundablePrice)
  return refundableprice_;
}
inline void ReturnGoodsInfo::set_refundableprice(double value) {
  set_has_refundableprice();
  refundableprice_ = value;
  // @@protoc_insertion_point(field_set:ReturnGoodsInfo.refundablePrice)
}

// optional string productName = 18;
inline bool ReturnGoodsInfo::has_productname() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void ReturnGoodsInfo::set_has_productname() {
  _has_bits_[0] |= 0x00020000u;
}
inline void ReturnGoodsInfo::clear_has_productname() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void ReturnGoodsInfo::clear_productname() {
  if (productname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    productname_->clear();
  }
  clear_has_productname();
}
inline const ::std::string& ReturnGoodsInfo::productname() const {
  // @@protoc_insertion_point(field_get:ReturnGoodsInfo.productName)
  return *productname_;
}
inline void ReturnGoodsInfo::set_productname(const ::std::string& value) {
  set_has_productname();
  if (productname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    productname_ = new ::std::string;
  }
  productname_->assign(value);
  // @@protoc_insertion_point(field_set:ReturnGoodsInfo.productName)
}
inline void ReturnGoodsInfo::set_productname(const char* value) {
  set_has_productname();
  if (productname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    productname_ = new ::std::string;
  }
  productname_->assign(value);
  // @@protoc_insertion_point(field_set_char:ReturnGoodsInfo.productName)
}
inline void ReturnGoodsInfo::set_productname(const char* value, size_t size) {
  set_has_productname();
  if (productname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    productname_ = new ::std::string;
  }
  productname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ReturnGoodsInfo.productName)
}
inline ::std::string* ReturnGoodsInfo::mutable_productname() {
  set_has_productname();
  if (productname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    productname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ReturnGoodsInfo.productName)
  return productname_;
}
inline ::std::string* ReturnGoodsInfo::release_productname() {
  clear_has_productname();
  if (productname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = productname_;
    productname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ReturnGoodsInfo::set_allocated_productname(::std::string* productname) {
  if (productname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete productname_;
  }
  if (productname) {
    set_has_productname();
    productname_ = productname;
  } else {
    clear_has_productname();
    productname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ReturnGoodsInfo.productName)
}

// optional string rssSeq = 19;
inline bool ReturnGoodsInfo::has_rssseq() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void ReturnGoodsInfo::set_has_rssseq() {
  _has_bits_[0] |= 0x00040000u;
}
inline void ReturnGoodsInfo::clear_has_rssseq() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void ReturnGoodsInfo::clear_rssseq() {
  if (rssseq_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rssseq_->clear();
  }
  clear_has_rssseq();
}
inline const ::std::string& ReturnGoodsInfo::rssseq() const {
  // @@protoc_insertion_point(field_get:ReturnGoodsInfo.rssSeq)
  return *rssseq_;
}
inline void ReturnGoodsInfo::set_rssseq(const ::std::string& value) {
  set_has_rssseq();
  if (rssseq_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rssseq_ = new ::std::string;
  }
  rssseq_->assign(value);
  // @@protoc_insertion_point(field_set:ReturnGoodsInfo.rssSeq)
}
inline void ReturnGoodsInfo::set_rssseq(const char* value) {
  set_has_rssseq();
  if (rssseq_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rssseq_ = new ::std::string;
  }
  rssseq_->assign(value);
  // @@protoc_insertion_point(field_set_char:ReturnGoodsInfo.rssSeq)
}
inline void ReturnGoodsInfo::set_rssseq(const char* value, size_t size) {
  set_has_rssseq();
  if (rssseq_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rssseq_ = new ::std::string;
  }
  rssseq_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ReturnGoodsInfo.rssSeq)
}
inline ::std::string* ReturnGoodsInfo::mutable_rssseq() {
  set_has_rssseq();
  if (rssseq_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rssseq_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ReturnGoodsInfo.rssSeq)
  return rssseq_;
}
inline ::std::string* ReturnGoodsInfo::release_rssseq() {
  clear_has_rssseq();
  if (rssseq_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = rssseq_;
    rssseq_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ReturnGoodsInfo::set_allocated_rssseq(::std::string* rssseq) {
  if (rssseq_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete rssseq_;
  }
  if (rssseq) {
    set_has_rssseq();
    rssseq_ = rssseq;
  } else {
    clear_has_rssseq();
    rssseq_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ReturnGoodsInfo.rssSeq)
}

// -------------------------------------------------------------------

// ReturnOrder

// optional string rsSeq = 1;
inline bool ReturnOrder::has_rsseq() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReturnOrder::set_has_rsseq() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReturnOrder::clear_has_rsseq() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReturnOrder::clear_rsseq() {
  if (rsseq_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rsseq_->clear();
  }
  clear_has_rsseq();
}
inline const ::std::string& ReturnOrder::rsseq() const {
  // @@protoc_insertion_point(field_get:ReturnOrder.rsSeq)
  return *rsseq_;
}
inline void ReturnOrder::set_rsseq(const ::std::string& value) {
  set_has_rsseq();
  if (rsseq_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rsseq_ = new ::std::string;
  }
  rsseq_->assign(value);
  // @@protoc_insertion_point(field_set:ReturnOrder.rsSeq)
}
inline void ReturnOrder::set_rsseq(const char* value) {
  set_has_rsseq();
  if (rsseq_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rsseq_ = new ::std::string;
  }
  rsseq_->assign(value);
  // @@protoc_insertion_point(field_set_char:ReturnOrder.rsSeq)
}
inline void ReturnOrder::set_rsseq(const char* value, size_t size) {
  set_has_rsseq();
  if (rsseq_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rsseq_ = new ::std::string;
  }
  rsseq_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ReturnOrder.rsSeq)
}
inline ::std::string* ReturnOrder::mutable_rsseq() {
  set_has_rsseq();
  if (rsseq_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rsseq_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ReturnOrder.rsSeq)
  return rsseq_;
}
inline ::std::string* ReturnOrder::release_rsseq() {
  clear_has_rsseq();
  if (rsseq_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = rsseq_;
    rsseq_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ReturnOrder::set_allocated_rsseq(::std::string* rsseq) {
  if (rsseq_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete rsseq_;
  }
  if (rsseq) {
    set_has_rsseq();
    rsseq_ = rsseq;
  } else {
    clear_has_rsseq();
    rsseq_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ReturnOrder.rsSeq)
}

// optional string ogNo = 2;
inline bool ReturnOrder::has_ogno() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReturnOrder::set_has_ogno() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReturnOrder::clear_has_ogno() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReturnOrder::clear_ogno() {
  if (ogno_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ogno_->clear();
  }
  clear_has_ogno();
}
inline const ::std::string& ReturnOrder::ogno() const {
  // @@protoc_insertion_point(field_get:ReturnOrder.ogNo)
  return *ogno_;
}
inline void ReturnOrder::set_ogno(const ::std::string& value) {
  set_has_ogno();
  if (ogno_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ogno_ = new ::std::string;
  }
  ogno_->assign(value);
  // @@protoc_insertion_point(field_set:ReturnOrder.ogNo)
}
inline void ReturnOrder::set_ogno(const char* value) {
  set_has_ogno();
  if (ogno_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ogno_ = new ::std::string;
  }
  ogno_->assign(value);
  // @@protoc_insertion_point(field_set_char:ReturnOrder.ogNo)
}
inline void ReturnOrder::set_ogno(const char* value, size_t size) {
  set_has_ogno();
  if (ogno_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ogno_ = new ::std::string;
  }
  ogno_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ReturnOrder.ogNo)
}
inline ::std::string* ReturnOrder::mutable_ogno() {
  set_has_ogno();
  if (ogno_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ogno_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ReturnOrder.ogNo)
  return ogno_;
}
inline ::std::string* ReturnOrder::release_ogno() {
  clear_has_ogno();
  if (ogno_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = ogno_;
    ogno_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ReturnOrder::set_allocated_ogno(::std::string* ogno) {
  if (ogno_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete ogno_;
  }
  if (ogno) {
    set_has_ogno();
    ogno_ = ogno;
  } else {
    clear_has_ogno();
    ogno_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ReturnOrder.ogNo)
}

// optional string ogsSeq = 3;
inline bool ReturnOrder::has_ogsseq() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ReturnOrder::set_has_ogsseq() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ReturnOrder::clear_has_ogsseq() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ReturnOrder::clear_ogsseq() {
  if (ogsseq_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ogsseq_->clear();
  }
  clear_has_ogsseq();
}
inline const ::std::string& ReturnOrder::ogsseq() const {
  // @@protoc_insertion_point(field_get:ReturnOrder.ogsSeq)
  return *ogsseq_;
}
inline void ReturnOrder::set_ogsseq(const ::std::string& value) {
  set_has_ogsseq();
  if (ogsseq_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ogsseq_ = new ::std::string;
  }
  ogsseq_->assign(value);
  // @@protoc_insertion_point(field_set:ReturnOrder.ogsSeq)
}
inline void ReturnOrder::set_ogsseq(const char* value) {
  set_has_ogsseq();
  if (ogsseq_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ogsseq_ = new ::std::string;
  }
  ogsseq_->assign(value);
  // @@protoc_insertion_point(field_set_char:ReturnOrder.ogsSeq)
}
inline void ReturnOrder::set_ogsseq(const char* value, size_t size) {
  set_has_ogsseq();
  if (ogsseq_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ogsseq_ = new ::std::string;
  }
  ogsseq_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ReturnOrder.ogsSeq)
}
inline ::std::string* ReturnOrder::mutable_ogsseq() {
  set_has_ogsseq();
  if (ogsseq_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ogsseq_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ReturnOrder.ogsSeq)
  return ogsseq_;
}
inline ::std::string* ReturnOrder::release_ogsseq() {
  clear_has_ogsseq();
  if (ogsseq_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = ogsseq_;
    ogsseq_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ReturnOrder::set_allocated_ogsseq(::std::string* ogsseq) {
  if (ogsseq_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete ogsseq_;
  }
  if (ogsseq) {
    set_has_ogsseq();
    ogsseq_ = ogsseq;
  } else {
    clear_has_ogsseq();
    ogsseq_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ReturnOrder.ogsSeq)
}

// optional string applyDate = 4;
inline bool ReturnOrder::has_applydate() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ReturnOrder::set_has_applydate() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ReturnOrder::clear_has_applydate() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ReturnOrder::clear_applydate() {
  if (applydate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    applydate_->clear();
  }
  clear_has_applydate();
}
inline const ::std::string& ReturnOrder::applydate() const {
  // @@protoc_insertion_point(field_get:ReturnOrder.applyDate)
  return *applydate_;
}
inline void ReturnOrder::set_applydate(const ::std::string& value) {
  set_has_applydate();
  if (applydate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    applydate_ = new ::std::string;
  }
  applydate_->assign(value);
  // @@protoc_insertion_point(field_set:ReturnOrder.applyDate)
}
inline void ReturnOrder::set_applydate(const char* value) {
  set_has_applydate();
  if (applydate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    applydate_ = new ::std::string;
  }
  applydate_->assign(value);
  // @@protoc_insertion_point(field_set_char:ReturnOrder.applyDate)
}
inline void ReturnOrder::set_applydate(const char* value, size_t size) {
  set_has_applydate();
  if (applydate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    applydate_ = new ::std::string;
  }
  applydate_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ReturnOrder.applyDate)
}
inline ::std::string* ReturnOrder::mutable_applydate() {
  set_has_applydate();
  if (applydate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    applydate_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ReturnOrder.applyDate)
  return applydate_;
}
inline ::std::string* ReturnOrder::release_applydate() {
  clear_has_applydate();
  if (applydate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = applydate_;
    applydate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ReturnOrder::set_allocated_applydate(::std::string* applydate) {
  if (applydate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete applydate_;
  }
  if (applydate) {
    set_has_applydate();
    applydate_ = applydate;
  } else {
    clear_has_applydate();
    applydate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ReturnOrder.applyDate)
}

// optional double applyPrice = 5;
inline bool ReturnOrder::has_applyprice() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ReturnOrder::set_has_applyprice() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ReturnOrder::clear_has_applyprice() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ReturnOrder::clear_applyprice() {
  applyprice_ = 0;
  clear_has_applyprice();
}
inline double ReturnOrder::applyprice() const {
  // @@protoc_insertion_point(field_get:ReturnOrder.applyPrice)
  return applyprice_;
}
inline void ReturnOrder::set_applyprice(double value) {
  set_has_applyprice();
  applyprice_ = value;
  // @@protoc_insertion_point(field_set:ReturnOrder.applyPrice)
}

// optional string merchantId = 6;
inline bool ReturnOrder::has_merchantid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ReturnOrder::set_has_merchantid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ReturnOrder::clear_has_merchantid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ReturnOrder::clear_merchantid() {
  if (merchantid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    merchantid_->clear();
  }
  clear_has_merchantid();
}
inline const ::std::string& ReturnOrder::merchantid() const {
  // @@protoc_insertion_point(field_get:ReturnOrder.merchantId)
  return *merchantid_;
}
inline void ReturnOrder::set_merchantid(const ::std::string& value) {
  set_has_merchantid();
  if (merchantid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    merchantid_ = new ::std::string;
  }
  merchantid_->assign(value);
  // @@protoc_insertion_point(field_set:ReturnOrder.merchantId)
}
inline void ReturnOrder::set_merchantid(const char* value) {
  set_has_merchantid();
  if (merchantid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    merchantid_ = new ::std::string;
  }
  merchantid_->assign(value);
  // @@protoc_insertion_point(field_set_char:ReturnOrder.merchantId)
}
inline void ReturnOrder::set_merchantid(const char* value, size_t size) {
  set_has_merchantid();
  if (merchantid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    merchantid_ = new ::std::string;
  }
  merchantid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ReturnOrder.merchantId)
}
inline ::std::string* ReturnOrder::mutable_merchantid() {
  set_has_merchantid();
  if (merchantid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    merchantid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ReturnOrder.merchantId)
  return merchantid_;
}
inline ::std::string* ReturnOrder::release_merchantid() {
  clear_has_merchantid();
  if (merchantid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = merchantid_;
    merchantid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ReturnOrder::set_allocated_merchantid(::std::string* merchantid) {
  if (merchantid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete merchantid_;
  }
  if (merchantid) {
    set_has_merchantid();
    merchantid_ = merchantid;
  } else {
    clear_has_merchantid();
    merchantid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ReturnOrder.merchantId)
}

// optional string memGuid = 7;
inline bool ReturnOrder::has_memguid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ReturnOrder::set_has_memguid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ReturnOrder::clear_has_memguid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ReturnOrder::clear_memguid() {
  if (memguid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    memguid_->clear();
  }
  clear_has_memguid();
}
inline const ::std::string& ReturnOrder::memguid() const {
  // @@protoc_insertion_point(field_get:ReturnOrder.memGuid)
  return *memguid_;
}
inline void ReturnOrder::set_memguid(const ::std::string& value) {
  set_has_memguid();
  if (memguid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    memguid_ = new ::std::string;
  }
  memguid_->assign(value);
  // @@protoc_insertion_point(field_set:ReturnOrder.memGuid)
}
inline void ReturnOrder::set_memguid(const char* value) {
  set_has_memguid();
  if (memguid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    memguid_ = new ::std::string;
  }
  memguid_->assign(value);
  // @@protoc_insertion_point(field_set_char:ReturnOrder.memGuid)
}
inline void ReturnOrder::set_memguid(const char* value, size_t size) {
  set_has_memguid();
  if (memguid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    memguid_ = new ::std::string;
  }
  memguid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ReturnOrder.memGuid)
}
inline ::std::string* ReturnOrder::mutable_memguid() {
  set_has_memguid();
  if (memguid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    memguid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ReturnOrder.memGuid)
  return memguid_;
}
inline ::std::string* ReturnOrder::release_memguid() {
  clear_has_memguid();
  if (memguid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = memguid_;
    memguid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ReturnOrder::set_allocated_memguid(::std::string* memguid) {
  if (memguid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete memguid_;
  }
  if (memguid) {
    set_has_memguid();
    memguid_ = memguid;
  } else {
    clear_has_memguid();
    memguid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ReturnOrder.memGuid)
}

// optional string buyername = 8;
inline bool ReturnOrder::has_buyername() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ReturnOrder::set_has_buyername() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ReturnOrder::clear_has_buyername() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ReturnOrder::clear_buyername() {
  if (buyername_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    buyername_->clear();
  }
  clear_has_buyername();
}
inline const ::std::string& ReturnOrder::buyername() const {
  // @@protoc_insertion_point(field_get:ReturnOrder.buyername)
  return *buyername_;
}
inline void ReturnOrder::set_buyername(const ::std::string& value) {
  set_has_buyername();
  if (buyername_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    buyername_ = new ::std::string;
  }
  buyername_->assign(value);
  // @@protoc_insertion_point(field_set:ReturnOrder.buyername)
}
inline void ReturnOrder::set_buyername(const char* value) {
  set_has_buyername();
  if (buyername_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    buyername_ = new ::std::string;
  }
  buyername_->assign(value);
  // @@protoc_insertion_point(field_set_char:ReturnOrder.buyername)
}
inline void ReturnOrder::set_buyername(const char* value, size_t size) {
  set_has_buyername();
  if (buyername_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    buyername_ = new ::std::string;
  }
  buyername_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ReturnOrder.buyername)
}
inline ::std::string* ReturnOrder::mutable_buyername() {
  set_has_buyername();
  if (buyername_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    buyername_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ReturnOrder.buyername)
  return buyername_;
}
inline ::std::string* ReturnOrder::release_buyername() {
  clear_has_buyername();
  if (buyername_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = buyername_;
    buyername_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ReturnOrder::set_allocated_buyername(::std::string* buyername) {
  if (buyername_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete buyername_;
  }
  if (buyername) {
    set_has_buyername();
    buyername_ = buyername;
  } else {
    clear_has_buyername();
    buyername_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ReturnOrder.buyername)
}

// repeated .ReturnGoodsInfo goodslist = 25;
inline int ReturnOrder::goodslist_size() const {
  return goodslist_.size();
}
inline void ReturnOrder::clear_goodslist() {
  goodslist_.Clear();
}
inline const ::ReturnGoodsInfo& ReturnOrder::goodslist(int index) const {
  // @@protoc_insertion_point(field_get:ReturnOrder.goodslist)
  return goodslist_.Get(index);
}
inline ::ReturnGoodsInfo* ReturnOrder::mutable_goodslist(int index) {
  // @@protoc_insertion_point(field_mutable:ReturnOrder.goodslist)
  return goodslist_.Mutable(index);
}
inline ::ReturnGoodsInfo* ReturnOrder::add_goodslist() {
  // @@protoc_insertion_point(field_add:ReturnOrder.goodslist)
  return goodslist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ReturnGoodsInfo >&
ReturnOrder::goodslist() const {
  // @@protoc_insertion_point(field_list:ReturnOrder.goodslist)
  return goodslist_;
}
inline ::google::protobuf::RepeatedPtrField< ::ReturnGoodsInfo >*
ReturnOrder::mutable_goodslist() {
  // @@protoc_insertion_point(field_mutable_list:ReturnOrder.goodslist)
  return &goodslist_;
}

// -------------------------------------------------------------------

// MsgPushInd

// required .EuMsgPush mpType = 1;
inline bool MsgPushInd::has_mptype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MsgPushInd::set_has_mptype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MsgPushInd::clear_has_mptype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MsgPushInd::clear_mptype() {
  mptype_ = 1;
  clear_has_mptype();
}
inline ::EuMsgPush MsgPushInd::mptype() const {
  // @@protoc_insertion_point(field_get:MsgPushInd.mpType)
  return static_cast< ::EuMsgPush >(mptype_);
}
inline void MsgPushInd::set_mptype(::EuMsgPush value) {
  assert(::EuMsgPush_IsValid(value));
  set_has_mptype();
  mptype_ = value;
  // @@protoc_insertion_point(field_set:MsgPushInd.mpType)
}

// required bytes mpData = 2;
inline bool MsgPushInd::has_mpdata() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MsgPushInd::set_has_mpdata() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MsgPushInd::clear_has_mpdata() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MsgPushInd::clear_mpdata() {
  if (mpdata_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mpdata_->clear();
  }
  clear_has_mpdata();
}
inline const ::std::string& MsgPushInd::mpdata() const {
  // @@protoc_insertion_point(field_get:MsgPushInd.mpData)
  return *mpdata_;
}
inline void MsgPushInd::set_mpdata(const ::std::string& value) {
  set_has_mpdata();
  if (mpdata_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mpdata_ = new ::std::string;
  }
  mpdata_->assign(value);
  // @@protoc_insertion_point(field_set:MsgPushInd.mpData)
}
inline void MsgPushInd::set_mpdata(const char* value) {
  set_has_mpdata();
  if (mpdata_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mpdata_ = new ::std::string;
  }
  mpdata_->assign(value);
  // @@protoc_insertion_point(field_set_char:MsgPushInd.mpData)
}
inline void MsgPushInd::set_mpdata(const void* value, size_t size) {
  set_has_mpdata();
  if (mpdata_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mpdata_ = new ::std::string;
  }
  mpdata_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:MsgPushInd.mpData)
}
inline ::std::string* MsgPushInd::mutable_mpdata() {
  set_has_mpdata();
  if (mpdata_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mpdata_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:MsgPushInd.mpData)
  return mpdata_;
}
inline ::std::string* MsgPushInd::release_mpdata() {
  clear_has_mpdata();
  if (mpdata_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = mpdata_;
    mpdata_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MsgPushInd::set_allocated_mpdata(::std::string* mpdata) {
  if (mpdata_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete mpdata_;
  }
  if (mpdata) {
    set_has_mpdata();
    mpdata_ = mpdata;
  } else {
    clear_has_mpdata();
    mpdata_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:MsgPushInd.mpData)
}

// -------------------------------------------------------------------

// csTeamInfoReq

// required int32 csId = 1;
inline bool csTeamInfoReq::has_csid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void csTeamInfoReq::set_has_csid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void csTeamInfoReq::clear_has_csid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void csTeamInfoReq::clear_csid() {
  csid_ = 0;
  clear_has_csid();
}
inline ::google::protobuf::int32 csTeamInfoReq::csid() const {
  // @@protoc_insertion_point(field_get:csTeamInfoReq.csId)
  return csid_;
}
inline void csTeamInfoReq::set_csid(::google::protobuf::int32 value) {
  set_has_csid();
  csid_ = value;
  // @@protoc_insertion_point(field_set:csTeamInfoReq.csId)
}

// -------------------------------------------------------------------

// csTeamInfo

// required int32 csTeamid = 1;
inline bool csTeamInfo::has_csteamid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void csTeamInfo::set_has_csteamid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void csTeamInfo::clear_has_csteamid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void csTeamInfo::clear_csteamid() {
  csteamid_ = 0;
  clear_has_csteamid();
}
inline ::google::protobuf::int32 csTeamInfo::csteamid() const {
  // @@protoc_insertion_point(field_get:csTeamInfo.csTeamid)
  return csteamid_;
}
inline void csTeamInfo::set_csteamid(::google::protobuf::int32 value) {
  set_has_csteamid();
  csteamid_ = value;
  // @@protoc_insertion_point(field_set:csTeamInfo.csTeamid)
}

// required int32 csQueueLength = 2;
inline bool csTeamInfo::has_csqueuelength() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void csTeamInfo::set_has_csqueuelength() {
  _has_bits_[0] |= 0x00000002u;
}
inline void csTeamInfo::clear_has_csqueuelength() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void csTeamInfo::clear_csqueuelength() {
  csqueuelength_ = 0;
  clear_has_csqueuelength();
}
inline ::google::protobuf::int32 csTeamInfo::csqueuelength() const {
  // @@protoc_insertion_point(field_get:csTeamInfo.csQueueLength)
  return csqueuelength_;
}
inline void csTeamInfo::set_csqueuelength(::google::protobuf::int32 value) {
  set_has_csqueuelength();
  csqueuelength_ = value;
  // @@protoc_insertion_point(field_set:csTeamInfo.csQueueLength)
}

// -------------------------------------------------------------------

// csTeamInfoAck

// required int32 ret = 1;
inline bool csTeamInfoAck::has_ret() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void csTeamInfoAck::set_has_ret() {
  _has_bits_[0] |= 0x00000001u;
}
inline void csTeamInfoAck::clear_has_ret() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void csTeamInfoAck::clear_ret() {
  ret_ = 0;
  clear_has_ret();
}
inline ::google::protobuf::int32 csTeamInfoAck::ret() const {
  // @@protoc_insertion_point(field_get:csTeamInfoAck.ret)
  return ret_;
}
inline void csTeamInfoAck::set_ret(::google::protobuf::int32 value) {
  set_has_ret();
  ret_ = value;
  // @@protoc_insertion_point(field_set:csTeamInfoAck.ret)
}

// required int32 csId = 2;
inline bool csTeamInfoAck::has_csid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void csTeamInfoAck::set_has_csid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void csTeamInfoAck::clear_has_csid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void csTeamInfoAck::clear_csid() {
  csid_ = 0;
  clear_has_csid();
}
inline ::google::protobuf::int32 csTeamInfoAck::csid() const {
  // @@protoc_insertion_point(field_get:csTeamInfoAck.csId)
  return csid_;
}
inline void csTeamInfoAck::set_csid(::google::protobuf::int32 value) {
  set_has_csid();
  csid_ = value;
  // @@protoc_insertion_point(field_set:csTeamInfoAck.csId)
}

// repeated .csTeamInfo teaminfo = 3;
inline int csTeamInfoAck::teaminfo_size() const {
  return teaminfo_.size();
}
inline void csTeamInfoAck::clear_teaminfo() {
  teaminfo_.Clear();
}
inline const ::csTeamInfo& csTeamInfoAck::teaminfo(int index) const {
  // @@protoc_insertion_point(field_get:csTeamInfoAck.teaminfo)
  return teaminfo_.Get(index);
}
inline ::csTeamInfo* csTeamInfoAck::mutable_teaminfo(int index) {
  // @@protoc_insertion_point(field_mutable:csTeamInfoAck.teaminfo)
  return teaminfo_.Mutable(index);
}
inline ::csTeamInfo* csTeamInfoAck::add_teaminfo() {
  // @@protoc_insertion_point(field_add:csTeamInfoAck.teaminfo)
  return teaminfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::csTeamInfo >&
csTeamInfoAck::teaminfo() const {
  // @@protoc_insertion_point(field_list:csTeamInfoAck.teaminfo)
  return teaminfo_;
}
inline ::google::protobuf::RepeatedPtrField< ::csTeamInfo >*
csTeamInfoAck::mutable_teaminfo() {
  // @@protoc_insertion_point(field_mutable_list:csTeamInfoAck.teaminfo)
  return &teaminfo_;
}

// -------------------------------------------------------------------

// csTeamQueueInfo

// required int32 ret = 1;
inline bool csTeamQueueInfo::has_ret() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void csTeamQueueInfo::set_has_ret() {
  _has_bits_[0] |= 0x00000001u;
}
inline void csTeamQueueInfo::clear_has_ret() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void csTeamQueueInfo::clear_ret() {
  ret_ = 0;
  clear_has_ret();
}
inline ::google::protobuf::int32 csTeamQueueInfo::ret() const {
  // @@protoc_insertion_point(field_get:csTeamQueueInfo.ret)
  return ret_;
}
inline void csTeamQueueInfo::set_ret(::google::protobuf::int32 value) {
  set_has_ret();
  ret_ = value;
  // @@protoc_insertion_point(field_set:csTeamQueueInfo.ret)
}

// required int32 csTeamId = 2;
inline bool csTeamQueueInfo::has_csteamid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void csTeamQueueInfo::set_has_csteamid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void csTeamQueueInfo::clear_has_csteamid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void csTeamQueueInfo::clear_csteamid() {
  csteamid_ = 0;
  clear_has_csteamid();
}
inline ::google::protobuf::int32 csTeamQueueInfo::csteamid() const {
  // @@protoc_insertion_point(field_get:csTeamQueueInfo.csTeamId)
  return csteamid_;
}
inline void csTeamQueueInfo::set_csteamid(::google::protobuf::int32 value) {
  set_has_csteamid();
  csteamid_ = value;
  // @@protoc_insertion_point(field_set:csTeamQueueInfo.csTeamId)
}

// required int32 csQueueLength = 3;
inline bool csTeamQueueInfo::has_csqueuelength() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void csTeamQueueInfo::set_has_csqueuelength() {
  _has_bits_[0] |= 0x00000004u;
}
inline void csTeamQueueInfo::clear_has_csqueuelength() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void csTeamQueueInfo::clear_csqueuelength() {
  csqueuelength_ = 0;
  clear_has_csqueuelength();
}
inline ::google::protobuf::int32 csTeamQueueInfo::csqueuelength() const {
  // @@protoc_insertion_point(field_get:csTeamQueueInfo.csQueueLength)
  return csqueuelength_;
}
inline void csTeamQueueInfo::set_csqueuelength(::google::protobuf::int32 value) {
  set_has_csqueuelength();
  csqueuelength_ = value;
  // @@protoc_insertion_point(field_set:csTeamQueueInfo.csQueueLength)
}


// @@protoc_insertion_point(namespace_scope)

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_improtocol_2eproto__INCLUDED
