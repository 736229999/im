// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: improtocol.proto

#ifndef PROTOBUF_improtocol_2eproto__INCLUDED
#define PROTOBUF_improtocol_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_improtocol_2eproto();
void protobuf_AssignDesc_improtocol_2eproto();
void protobuf_ShutdownFile_improtocol_2eproto();

class MsgInfo;
class MsgListReq;
class MsgList;
class UserOfflineIND;

// ===================================================================

class MsgInfo : public ::google::protobuf::MessageLite {
 public:
  MsgInfo();
  virtual ~MsgInfo();

  MsgInfo(const MsgInfo& from);

  inline MsgInfo& operator=(const MsgInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const MsgInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const MsgInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(MsgInfo* other);

  // implements Message ----------------------------------------------

  MsgInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MsgInfo& from);
  void MergeFrom(const MsgInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 msgid = 1;
  inline bool has_msgid() const;
  inline void clear_msgid();
  static const int kMsgidFieldNumber = 1;
  inline ::google::protobuf::uint32 msgid() const;
  inline void set_msgid(::google::protobuf::uint32 value);

  // optional string uuid = 2;
  inline bool has_uuid() const;
  inline void clear_uuid();
  static const int kUuidFieldNumber = 2;
  inline const ::std::string& uuid() const;
  inline void set_uuid(const ::std::string& value);
  inline void set_uuid(const char* value);
  inline void set_uuid(const char* value, size_t size);
  inline ::std::string* mutable_uuid();
  inline ::std::string* release_uuid();
  inline void set_allocated_uuid(::std::string* uuid);

  // optional uint32 fromid = 3;
  inline bool has_fromid() const;
  inline void clear_fromid();
  static const int kFromidFieldNumber = 3;
  inline ::google::protobuf::uint32 fromid() const;
  inline void set_fromid(::google::protobuf::uint32 value);

  // optional uint32 toid = 4;
  inline bool has_toid() const;
  inline void clear_toid();
  static const int kToidFieldNumber = 4;
  inline ::google::protobuf::uint32 toid() const;
  inline void set_toid(::google::protobuf::uint32 value);

  // optional uint32 send_time = 5;
  inline bool has_send_time() const;
  inline void clear_send_time();
  static const int kSendTimeFieldNumber = 5;
  inline ::google::protobuf::uint32 send_time() const;
  inline void set_send_time(::google::protobuf::uint32 value);

  // optional string data = 6;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 6;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const char* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // optional string fromnickname = 7;
  inline bool has_fromnickname() const;
  inline void clear_fromnickname();
  static const int kFromnicknameFieldNumber = 7;
  inline const ::std::string& fromnickname() const;
  inline void set_fromnickname(const ::std::string& value);
  inline void set_fromnickname(const char* value);
  inline void set_fromnickname(const char* value, size_t size);
  inline ::std::string* mutable_fromnickname();
  inline ::std::string* release_fromnickname();
  inline void set_allocated_fromnickname(::std::string* fromnickname);

  // optional uint32 fontSize = 8;
  inline bool has_fontsize() const;
  inline void clear_fontsize();
  static const int kFontSizeFieldNumber = 8;
  inline ::google::protobuf::uint32 fontsize() const;
  inline void set_fontsize(::google::protobuf::uint32 value);

  // optional uint32 fontColor = 9;
  inline bool has_fontcolor() const;
  inline void clear_fontcolor();
  static const int kFontColorFieldNumber = 9;
  inline ::google::protobuf::uint32 fontcolor() const;
  inline void set_fontcolor(::google::protobuf::uint32 value);

  // optional uint32 fontStyle = 10;
  inline bool has_fontstyle() const;
  inline void clear_fontstyle();
  static const int kFontStyleFieldNumber = 10;
  inline ::google::protobuf::uint32 fontstyle() const;
  inline void set_fontstyle(::google::protobuf::uint32 value);

  // optional string fontName = 11;
  inline bool has_fontname() const;
  inline void clear_fontname();
  static const int kFontNameFieldNumber = 11;
  inline const ::std::string& fontname() const;
  inline void set_fontname(const ::std::string& value);
  inline void set_fontname(const char* value);
  inline void set_fontname(const char* value, size_t size);
  inline ::std::string* mutable_fontname();
  inline ::std::string* release_fontname();
  inline void set_allocated_fontname(::std::string* fontname);

  // optional uint32 datatype = 12;
  inline bool has_datatype() const;
  inline void clear_datatype();
  static const int kDatatypeFieldNumber = 12;
  inline ::google::protobuf::uint32 datatype() const;
  inline void set_datatype(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:MsgInfo)
 private:
  inline void set_has_msgid();
  inline void clear_has_msgid();
  inline void set_has_uuid();
  inline void clear_has_uuid();
  inline void set_has_fromid();
  inline void clear_has_fromid();
  inline void set_has_toid();
  inline void clear_has_toid();
  inline void set_has_send_time();
  inline void clear_has_send_time();
  inline void set_has_data();
  inline void clear_has_data();
  inline void set_has_fromnickname();
  inline void clear_has_fromnickname();
  inline void set_has_fontsize();
  inline void clear_has_fontsize();
  inline void set_has_fontcolor();
  inline void clear_has_fontcolor();
  inline void set_has_fontstyle();
  inline void clear_has_fontstyle();
  inline void set_has_fontname();
  inline void clear_has_fontname();
  inline void set_has_datatype();
  inline void clear_has_datatype();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* uuid_;
  ::google::protobuf::uint32 msgid_;
  ::google::protobuf::uint32 fromid_;
  ::google::protobuf::uint32 toid_;
  ::google::protobuf::uint32 send_time_;
  ::std::string* data_;
  ::std::string* fromnickname_;
  ::google::protobuf::uint32 fontsize_;
  ::google::protobuf::uint32 fontcolor_;
  ::std::string* fontname_;
  ::google::protobuf::uint32 fontstyle_;
  ::google::protobuf::uint32 datatype_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_improtocol_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_improtocol_2eproto();
  #endif
  friend void protobuf_AssignDesc_improtocol_2eproto();
  friend void protobuf_ShutdownFile_improtocol_2eproto();

  void InitAsDefaultInstance();
  static MsgInfo* default_instance_;
};
// -------------------------------------------------------------------

class MsgListReq : public ::google::protobuf::MessageLite {
 public:
  MsgListReq();
  virtual ~MsgListReq();

  MsgListReq(const MsgListReq& from);

  inline MsgListReq& operator=(const MsgListReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const MsgListReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const MsgListReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(MsgListReq* other);

  // implements Message ----------------------------------------------

  MsgListReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MsgListReq& from);
  void MergeFrom(const MsgListReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 fromid = 1;
  inline bool has_fromid() const;
  inline void clear_fromid();
  static const int kFromidFieldNumber = 1;
  inline ::google::protobuf::uint32 fromid() const;
  inline void set_fromid(::google::protobuf::uint32 value);

  // required uint32 toid = 2;
  inline bool has_toid() const;
  inline void clear_toid();
  static const int kToidFieldNumber = 2;
  inline ::google::protobuf::uint32 toid() const;
  inline void set_toid(::google::protobuf::uint32 value);

  // required uint32 bgntime = 3;
  inline bool has_bgntime() const;
  inline void clear_bgntime();
  static const int kBgntimeFieldNumber = 3;
  inline ::google::protobuf::uint32 bgntime() const;
  inline void set_bgntime(::google::protobuf::uint32 value);

  // optional uint32 endtime = 4;
  inline bool has_endtime() const;
  inline void clear_endtime();
  static const int kEndtimeFieldNumber = 4;
  inline ::google::protobuf::uint32 endtime() const;
  inline void set_endtime(::google::protobuf::uint32 value);

  // optional uint32 maxmsg = 5;
  inline bool has_maxmsg() const;
  inline void clear_maxmsg();
  static const int kMaxmsgFieldNumber = 5;
  inline ::google::protobuf::uint32 maxmsg() const;
  inline void set_maxmsg(::google::protobuf::uint32 value);

  // optional uint32 bgnmsgid = 6;
  inline bool has_bgnmsgid() const;
  inline void clear_bgnmsgid();
  static const int kBgnmsgidFieldNumber = 6;
  inline ::google::protobuf::uint32 bgnmsgid() const;
  inline void set_bgnmsgid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:MsgListReq)
 private:
  inline void set_has_fromid();
  inline void clear_has_fromid();
  inline void set_has_toid();
  inline void clear_has_toid();
  inline void set_has_bgntime();
  inline void clear_has_bgntime();
  inline void set_has_endtime();
  inline void clear_has_endtime();
  inline void set_has_maxmsg();
  inline void clear_has_maxmsg();
  inline void set_has_bgnmsgid();
  inline void clear_has_bgnmsgid();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 fromid_;
  ::google::protobuf::uint32 toid_;
  ::google::protobuf::uint32 bgntime_;
  ::google::protobuf::uint32 endtime_;
  ::google::protobuf::uint32 maxmsg_;
  ::google::protobuf::uint32 bgnmsgid_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_improtocol_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_improtocol_2eproto();
  #endif
  friend void protobuf_AssignDesc_improtocol_2eproto();
  friend void protobuf_ShutdownFile_improtocol_2eproto();

  void InitAsDefaultInstance();
  static MsgListReq* default_instance_;
};
// -------------------------------------------------------------------

class MsgList : public ::google::protobuf::MessageLite {
 public:
  MsgList();
  virtual ~MsgList();

  MsgList(const MsgList& from);

  inline MsgList& operator=(const MsgList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const MsgList& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const MsgList* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(MsgList* other);

  // implements Message ----------------------------------------------

  MsgList* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MsgList& from);
  void MergeFrom(const MsgList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 ret = 1;
  inline bool has_ret() const;
  inline void clear_ret();
  static const int kRetFieldNumber = 1;
  inline ::google::protobuf::uint32 ret() const;
  inline void set_ret(::google::protobuf::uint32 value);

  // required uint32 isend = 2;
  inline bool has_isend() const;
  inline void clear_isend();
  static const int kIsendFieldNumber = 2;
  inline ::google::protobuf::uint32 isend() const;
  inline void set_isend(::google::protobuf::uint32 value);

  // optional uint32 lastmsgid = 3;
  inline bool has_lastmsgid() const;
  inline void clear_lastmsgid();
  static const int kLastmsgidFieldNumber = 3;
  inline ::google::protobuf::uint32 lastmsgid() const;
  inline void set_lastmsgid(::google::protobuf::uint32 value);

  // optional uint32 userid = 4;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUseridFieldNumber = 4;
  inline ::google::protobuf::uint32 userid() const;
  inline void set_userid(::google::protobuf::uint32 value);

  // repeated .MsgInfo msglist = 15;
  inline int msglist_size() const;
  inline void clear_msglist();
  static const int kMsglistFieldNumber = 15;
  inline const ::MsgInfo& msglist(int index) const;
  inline ::MsgInfo* mutable_msglist(int index);
  inline ::MsgInfo* add_msglist();
  inline const ::google::protobuf::RepeatedPtrField< ::MsgInfo >&
      msglist() const;
  inline ::google::protobuf::RepeatedPtrField< ::MsgInfo >*
      mutable_msglist();

  // @@protoc_insertion_point(class_scope:MsgList)
 private:
  inline void set_has_ret();
  inline void clear_has_ret();
  inline void set_has_isend();
  inline void clear_has_isend();
  inline void set_has_lastmsgid();
  inline void clear_has_lastmsgid();
  inline void set_has_userid();
  inline void clear_has_userid();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 ret_;
  ::google::protobuf::uint32 isend_;
  ::google::protobuf::uint32 lastmsgid_;
  ::google::protobuf::uint32 userid_;
  ::google::protobuf::RepeatedPtrField< ::MsgInfo > msglist_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_improtocol_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_improtocol_2eproto();
  #endif
  friend void protobuf_AssignDesc_improtocol_2eproto();
  friend void protobuf_ShutdownFile_improtocol_2eproto();

  void InitAsDefaultInstance();
  static MsgList* default_instance_;
};
// -------------------------------------------------------------------

class UserOfflineIND : public ::google::protobuf::MessageLite {
 public:
  UserOfflineIND();
  virtual ~UserOfflineIND();

  UserOfflineIND(const UserOfflineIND& from);

  inline UserOfflineIND& operator=(const UserOfflineIND& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const UserOfflineIND& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UserOfflineIND* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UserOfflineIND* other);

  // implements Message ----------------------------------------------

  UserOfflineIND* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UserOfflineIND& from);
  void MergeFrom(const UserOfflineIND& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 userid = 1;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUseridFieldNumber = 1;
  inline ::google::protobuf::uint32 userid() const;
  inline void set_userid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:UserOfflineIND)
 private:
  inline void set_has_userid();
  inline void clear_has_userid();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 userid_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_improtocol_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_improtocol_2eproto();
  #endif
  friend void protobuf_AssignDesc_improtocol_2eproto();
  friend void protobuf_ShutdownFile_improtocol_2eproto();

  void InitAsDefaultInstance();
  static UserOfflineIND* default_instance_;
};
// ===================================================================


// ===================================================================

// MsgInfo

// optional uint32 msgid = 1;
inline bool MsgInfo::has_msgid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MsgInfo::set_has_msgid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MsgInfo::clear_has_msgid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MsgInfo::clear_msgid() {
  msgid_ = 0u;
  clear_has_msgid();
}
inline ::google::protobuf::uint32 MsgInfo::msgid() const {
  // @@protoc_insertion_point(field_get:MsgInfo.msgid)
  return msgid_;
}
inline void MsgInfo::set_msgid(::google::protobuf::uint32 value) {
  set_has_msgid();
  msgid_ = value;
  // @@protoc_insertion_point(field_set:MsgInfo.msgid)
}

// optional string uuid = 2;
inline bool MsgInfo::has_uuid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MsgInfo::set_has_uuid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MsgInfo::clear_has_uuid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MsgInfo::clear_uuid() {
  if (uuid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    uuid_->clear();
  }
  clear_has_uuid();
}
inline const ::std::string& MsgInfo::uuid() const {
  // @@protoc_insertion_point(field_get:MsgInfo.uuid)
  return *uuid_;
}
inline void MsgInfo::set_uuid(const ::std::string& value) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(value);
  // @@protoc_insertion_point(field_set:MsgInfo.uuid)
}
inline void MsgInfo::set_uuid(const char* value) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(value);
  // @@protoc_insertion_point(field_set_char:MsgInfo.uuid)
}
inline void MsgInfo::set_uuid(const char* value, size_t size) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:MsgInfo.uuid)
}
inline ::std::string* MsgInfo::mutable_uuid() {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    uuid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:MsgInfo.uuid)
  return uuid_;
}
inline ::std::string* MsgInfo::release_uuid() {
  clear_has_uuid();
  if (uuid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = uuid_;
    uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MsgInfo::set_allocated_uuid(::std::string* uuid) {
  if (uuid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete uuid_;
  }
  if (uuid) {
    set_has_uuid();
    uuid_ = uuid;
  } else {
    clear_has_uuid();
    uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:MsgInfo.uuid)
}

// optional uint32 fromid = 3;
inline bool MsgInfo::has_fromid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MsgInfo::set_has_fromid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MsgInfo::clear_has_fromid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MsgInfo::clear_fromid() {
  fromid_ = 0u;
  clear_has_fromid();
}
inline ::google::protobuf::uint32 MsgInfo::fromid() const {
  // @@protoc_insertion_point(field_get:MsgInfo.fromid)
  return fromid_;
}
inline void MsgInfo::set_fromid(::google::protobuf::uint32 value) {
  set_has_fromid();
  fromid_ = value;
  // @@protoc_insertion_point(field_set:MsgInfo.fromid)
}

// optional uint32 toid = 4;
inline bool MsgInfo::has_toid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MsgInfo::set_has_toid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MsgInfo::clear_has_toid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MsgInfo::clear_toid() {
  toid_ = 0u;
  clear_has_toid();
}
inline ::google::protobuf::uint32 MsgInfo::toid() const {
  // @@protoc_insertion_point(field_get:MsgInfo.toid)
  return toid_;
}
inline void MsgInfo::set_toid(::google::protobuf::uint32 value) {
  set_has_toid();
  toid_ = value;
  // @@protoc_insertion_point(field_set:MsgInfo.toid)
}

// optional uint32 send_time = 5;
inline bool MsgInfo::has_send_time() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MsgInfo::set_has_send_time() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MsgInfo::clear_has_send_time() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MsgInfo::clear_send_time() {
  send_time_ = 0u;
  clear_has_send_time();
}
inline ::google::protobuf::uint32 MsgInfo::send_time() const {
  // @@protoc_insertion_point(field_get:MsgInfo.send_time)
  return send_time_;
}
inline void MsgInfo::set_send_time(::google::protobuf::uint32 value) {
  set_has_send_time();
  send_time_ = value;
  // @@protoc_insertion_point(field_set:MsgInfo.send_time)
}

// optional string data = 6;
inline bool MsgInfo::has_data() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MsgInfo::set_has_data() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MsgInfo::clear_has_data() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MsgInfo::clear_data() {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& MsgInfo::data() const {
  // @@protoc_insertion_point(field_get:MsgInfo.data)
  return *data_;
}
inline void MsgInfo::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(value);
  // @@protoc_insertion_point(field_set:MsgInfo.data)
}
inline void MsgInfo::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(value);
  // @@protoc_insertion_point(field_set_char:MsgInfo.data)
}
inline void MsgInfo::set_data(const char* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:MsgInfo.data)
}
inline ::std::string* MsgInfo::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:MsgInfo.data)
  return data_;
}
inline ::std::string* MsgInfo::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MsgInfo::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:MsgInfo.data)
}

// optional string fromnickname = 7;
inline bool MsgInfo::has_fromnickname() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MsgInfo::set_has_fromnickname() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MsgInfo::clear_has_fromnickname() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MsgInfo::clear_fromnickname() {
  if (fromnickname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fromnickname_->clear();
  }
  clear_has_fromnickname();
}
inline const ::std::string& MsgInfo::fromnickname() const {
  // @@protoc_insertion_point(field_get:MsgInfo.fromnickname)
  return *fromnickname_;
}
inline void MsgInfo::set_fromnickname(const ::std::string& value) {
  set_has_fromnickname();
  if (fromnickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fromnickname_ = new ::std::string;
  }
  fromnickname_->assign(value);
  // @@protoc_insertion_point(field_set:MsgInfo.fromnickname)
}
inline void MsgInfo::set_fromnickname(const char* value) {
  set_has_fromnickname();
  if (fromnickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fromnickname_ = new ::std::string;
  }
  fromnickname_->assign(value);
  // @@protoc_insertion_point(field_set_char:MsgInfo.fromnickname)
}
inline void MsgInfo::set_fromnickname(const char* value, size_t size) {
  set_has_fromnickname();
  if (fromnickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fromnickname_ = new ::std::string;
  }
  fromnickname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:MsgInfo.fromnickname)
}
inline ::std::string* MsgInfo::mutable_fromnickname() {
  set_has_fromnickname();
  if (fromnickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fromnickname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:MsgInfo.fromnickname)
  return fromnickname_;
}
inline ::std::string* MsgInfo::release_fromnickname() {
  clear_has_fromnickname();
  if (fromnickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = fromnickname_;
    fromnickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MsgInfo::set_allocated_fromnickname(::std::string* fromnickname) {
  if (fromnickname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete fromnickname_;
  }
  if (fromnickname) {
    set_has_fromnickname();
    fromnickname_ = fromnickname;
  } else {
    clear_has_fromnickname();
    fromnickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:MsgInfo.fromnickname)
}

// optional uint32 fontSize = 8;
inline bool MsgInfo::has_fontsize() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MsgInfo::set_has_fontsize() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MsgInfo::clear_has_fontsize() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MsgInfo::clear_fontsize() {
  fontsize_ = 0u;
  clear_has_fontsize();
}
inline ::google::protobuf::uint32 MsgInfo::fontsize() const {
  // @@protoc_insertion_point(field_get:MsgInfo.fontSize)
  return fontsize_;
}
inline void MsgInfo::set_fontsize(::google::protobuf::uint32 value) {
  set_has_fontsize();
  fontsize_ = value;
  // @@protoc_insertion_point(field_set:MsgInfo.fontSize)
}

// optional uint32 fontColor = 9;
inline bool MsgInfo::has_fontcolor() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void MsgInfo::set_has_fontcolor() {
  _has_bits_[0] |= 0x00000100u;
}
inline void MsgInfo::clear_has_fontcolor() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void MsgInfo::clear_fontcolor() {
  fontcolor_ = 0u;
  clear_has_fontcolor();
}
inline ::google::protobuf::uint32 MsgInfo::fontcolor() const {
  // @@protoc_insertion_point(field_get:MsgInfo.fontColor)
  return fontcolor_;
}
inline void MsgInfo::set_fontcolor(::google::protobuf::uint32 value) {
  set_has_fontcolor();
  fontcolor_ = value;
  // @@protoc_insertion_point(field_set:MsgInfo.fontColor)
}

// optional uint32 fontStyle = 10;
inline bool MsgInfo::has_fontstyle() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void MsgInfo::set_has_fontstyle() {
  _has_bits_[0] |= 0x00000200u;
}
inline void MsgInfo::clear_has_fontstyle() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void MsgInfo::clear_fontstyle() {
  fontstyle_ = 0u;
  clear_has_fontstyle();
}
inline ::google::protobuf::uint32 MsgInfo::fontstyle() const {
  // @@protoc_insertion_point(field_get:MsgInfo.fontStyle)
  return fontstyle_;
}
inline void MsgInfo::set_fontstyle(::google::protobuf::uint32 value) {
  set_has_fontstyle();
  fontstyle_ = value;
  // @@protoc_insertion_point(field_set:MsgInfo.fontStyle)
}

// optional string fontName = 11;
inline bool MsgInfo::has_fontname() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void MsgInfo::set_has_fontname() {
  _has_bits_[0] |= 0x00000400u;
}
inline void MsgInfo::clear_has_fontname() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void MsgInfo::clear_fontname() {
  if (fontname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fontname_->clear();
  }
  clear_has_fontname();
}
inline const ::std::string& MsgInfo::fontname() const {
  // @@protoc_insertion_point(field_get:MsgInfo.fontName)
  return *fontname_;
}
inline void MsgInfo::set_fontname(const ::std::string& value) {
  set_has_fontname();
  if (fontname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fontname_ = new ::std::string;
  }
  fontname_->assign(value);
  // @@protoc_insertion_point(field_set:MsgInfo.fontName)
}
inline void MsgInfo::set_fontname(const char* value) {
  set_has_fontname();
  if (fontname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fontname_ = new ::std::string;
  }
  fontname_->assign(value);
  // @@protoc_insertion_point(field_set_char:MsgInfo.fontName)
}
inline void MsgInfo::set_fontname(const char* value, size_t size) {
  set_has_fontname();
  if (fontname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fontname_ = new ::std::string;
  }
  fontname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:MsgInfo.fontName)
}
inline ::std::string* MsgInfo::mutable_fontname() {
  set_has_fontname();
  if (fontname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fontname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:MsgInfo.fontName)
  return fontname_;
}
inline ::std::string* MsgInfo::release_fontname() {
  clear_has_fontname();
  if (fontname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = fontname_;
    fontname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MsgInfo::set_allocated_fontname(::std::string* fontname) {
  if (fontname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete fontname_;
  }
  if (fontname) {
    set_has_fontname();
    fontname_ = fontname;
  } else {
    clear_has_fontname();
    fontname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:MsgInfo.fontName)
}

// optional uint32 datatype = 12;
inline bool MsgInfo::has_datatype() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void MsgInfo::set_has_datatype() {
  _has_bits_[0] |= 0x00000800u;
}
inline void MsgInfo::clear_has_datatype() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void MsgInfo::clear_datatype() {
  datatype_ = 0u;
  clear_has_datatype();
}
inline ::google::protobuf::uint32 MsgInfo::datatype() const {
  // @@protoc_insertion_point(field_get:MsgInfo.datatype)
  return datatype_;
}
inline void MsgInfo::set_datatype(::google::protobuf::uint32 value) {
  set_has_datatype();
  datatype_ = value;
  // @@protoc_insertion_point(field_set:MsgInfo.datatype)
}

// -------------------------------------------------------------------

// MsgListReq

// required uint32 fromid = 1;
inline bool MsgListReq::has_fromid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MsgListReq::set_has_fromid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MsgListReq::clear_has_fromid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MsgListReq::clear_fromid() {
  fromid_ = 0u;
  clear_has_fromid();
}
inline ::google::protobuf::uint32 MsgListReq::fromid() const {
  // @@protoc_insertion_point(field_get:MsgListReq.fromid)
  return fromid_;
}
inline void MsgListReq::set_fromid(::google::protobuf::uint32 value) {
  set_has_fromid();
  fromid_ = value;
  // @@protoc_insertion_point(field_set:MsgListReq.fromid)
}

// required uint32 toid = 2;
inline bool MsgListReq::has_toid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MsgListReq::set_has_toid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MsgListReq::clear_has_toid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MsgListReq::clear_toid() {
  toid_ = 0u;
  clear_has_toid();
}
inline ::google::protobuf::uint32 MsgListReq::toid() const {
  // @@protoc_insertion_point(field_get:MsgListReq.toid)
  return toid_;
}
inline void MsgListReq::set_toid(::google::protobuf::uint32 value) {
  set_has_toid();
  toid_ = value;
  // @@protoc_insertion_point(field_set:MsgListReq.toid)
}

// required uint32 bgntime = 3;
inline bool MsgListReq::has_bgntime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MsgListReq::set_has_bgntime() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MsgListReq::clear_has_bgntime() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MsgListReq::clear_bgntime() {
  bgntime_ = 0u;
  clear_has_bgntime();
}
inline ::google::protobuf::uint32 MsgListReq::bgntime() const {
  // @@protoc_insertion_point(field_get:MsgListReq.bgntime)
  return bgntime_;
}
inline void MsgListReq::set_bgntime(::google::protobuf::uint32 value) {
  set_has_bgntime();
  bgntime_ = value;
  // @@protoc_insertion_point(field_set:MsgListReq.bgntime)
}

// optional uint32 endtime = 4;
inline bool MsgListReq::has_endtime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MsgListReq::set_has_endtime() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MsgListReq::clear_has_endtime() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MsgListReq::clear_endtime() {
  endtime_ = 0u;
  clear_has_endtime();
}
inline ::google::protobuf::uint32 MsgListReq::endtime() const {
  // @@protoc_insertion_point(field_get:MsgListReq.endtime)
  return endtime_;
}
inline void MsgListReq::set_endtime(::google::protobuf::uint32 value) {
  set_has_endtime();
  endtime_ = value;
  // @@protoc_insertion_point(field_set:MsgListReq.endtime)
}

// optional uint32 maxmsg = 5;
inline bool MsgListReq::has_maxmsg() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MsgListReq::set_has_maxmsg() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MsgListReq::clear_has_maxmsg() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MsgListReq::clear_maxmsg() {
  maxmsg_ = 0u;
  clear_has_maxmsg();
}
inline ::google::protobuf::uint32 MsgListReq::maxmsg() const {
  // @@protoc_insertion_point(field_get:MsgListReq.maxmsg)
  return maxmsg_;
}
inline void MsgListReq::set_maxmsg(::google::protobuf::uint32 value) {
  set_has_maxmsg();
  maxmsg_ = value;
  // @@protoc_insertion_point(field_set:MsgListReq.maxmsg)
}

// optional uint32 bgnmsgid = 6;
inline bool MsgListReq::has_bgnmsgid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MsgListReq::set_has_bgnmsgid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MsgListReq::clear_has_bgnmsgid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MsgListReq::clear_bgnmsgid() {
  bgnmsgid_ = 0u;
  clear_has_bgnmsgid();
}
inline ::google::protobuf::uint32 MsgListReq::bgnmsgid() const {
  // @@protoc_insertion_point(field_get:MsgListReq.bgnmsgid)
  return bgnmsgid_;
}
inline void MsgListReq::set_bgnmsgid(::google::protobuf::uint32 value) {
  set_has_bgnmsgid();
  bgnmsgid_ = value;
  // @@protoc_insertion_point(field_set:MsgListReq.bgnmsgid)
}

// -------------------------------------------------------------------

// MsgList

// optional uint32 ret = 1;
inline bool MsgList::has_ret() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MsgList::set_has_ret() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MsgList::clear_has_ret() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MsgList::clear_ret() {
  ret_ = 0u;
  clear_has_ret();
}
inline ::google::protobuf::uint32 MsgList::ret() const {
  // @@protoc_insertion_point(field_get:MsgList.ret)
  return ret_;
}
inline void MsgList::set_ret(::google::protobuf::uint32 value) {
  set_has_ret();
  ret_ = value;
  // @@protoc_insertion_point(field_set:MsgList.ret)
}

// required uint32 isend = 2;
inline bool MsgList::has_isend() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MsgList::set_has_isend() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MsgList::clear_has_isend() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MsgList::clear_isend() {
  isend_ = 0u;
  clear_has_isend();
}
inline ::google::protobuf::uint32 MsgList::isend() const {
  // @@protoc_insertion_point(field_get:MsgList.isend)
  return isend_;
}
inline void MsgList::set_isend(::google::protobuf::uint32 value) {
  set_has_isend();
  isend_ = value;
  // @@protoc_insertion_point(field_set:MsgList.isend)
}

// optional uint32 lastmsgid = 3;
inline bool MsgList::has_lastmsgid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MsgList::set_has_lastmsgid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MsgList::clear_has_lastmsgid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MsgList::clear_lastmsgid() {
  lastmsgid_ = 0u;
  clear_has_lastmsgid();
}
inline ::google::protobuf::uint32 MsgList::lastmsgid() const {
  // @@protoc_insertion_point(field_get:MsgList.lastmsgid)
  return lastmsgid_;
}
inline void MsgList::set_lastmsgid(::google::protobuf::uint32 value) {
  set_has_lastmsgid();
  lastmsgid_ = value;
  // @@protoc_insertion_point(field_set:MsgList.lastmsgid)
}

// optional uint32 userid = 4;
inline bool MsgList::has_userid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MsgList::set_has_userid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MsgList::clear_has_userid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MsgList::clear_userid() {
  userid_ = 0u;
  clear_has_userid();
}
inline ::google::protobuf::uint32 MsgList::userid() const {
  // @@protoc_insertion_point(field_get:MsgList.userid)
  return userid_;
}
inline void MsgList::set_userid(::google::protobuf::uint32 value) {
  set_has_userid();
  userid_ = value;
  // @@protoc_insertion_point(field_set:MsgList.userid)
}

// repeated .MsgInfo msglist = 15;
inline int MsgList::msglist_size() const {
  return msglist_.size();
}
inline void MsgList::clear_msglist() {
  msglist_.Clear();
}
inline const ::MsgInfo& MsgList::msglist(int index) const {
  // @@protoc_insertion_point(field_get:MsgList.msglist)
  return msglist_.Get(index);
}
inline ::MsgInfo* MsgList::mutable_msglist(int index) {
  // @@protoc_insertion_point(field_mutable:MsgList.msglist)
  return msglist_.Mutable(index);
}
inline ::MsgInfo* MsgList::add_msglist() {
  // @@protoc_insertion_point(field_add:MsgList.msglist)
  return msglist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::MsgInfo >&
MsgList::msglist() const {
  // @@protoc_insertion_point(field_list:MsgList.msglist)
  return msglist_;
}
inline ::google::protobuf::RepeatedPtrField< ::MsgInfo >*
MsgList::mutable_msglist() {
  // @@protoc_insertion_point(field_mutable_list:MsgList.msglist)
  return &msglist_;
}

// -------------------------------------------------------------------

// UserOfflineIND

// required uint32 userid = 1;
inline bool UserOfflineIND::has_userid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserOfflineIND::set_has_userid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserOfflineIND::clear_has_userid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserOfflineIND::clear_userid() {
  userid_ = 0u;
  clear_has_userid();
}
inline ::google::protobuf::uint32 UserOfflineIND::userid() const {
  // @@protoc_insertion_point(field_get:UserOfflineIND.userid)
  return userid_;
}
inline void UserOfflineIND::set_userid(::google::protobuf::uint32 value) {
  set_has_userid();
  userid_ = value;
  // @@protoc_insertion_point(field_set:UserOfflineIND.userid)
}


// @@protoc_insertion_point(namespace_scope)

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_improtocol_2eproto__INCLUDED
