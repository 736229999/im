#include "stdafx.h"
#define SQLCA_NONE
#define ORACA_NONE
#include <sqlcpr.h>
// extern struct sqlca sqlca;
// extern struct oraca oraca;

/*#include <oci.h>*/
/*使用到的连接名与上下文
    strncpy((char*)db_link_name.arr, m_Connect,32);
    db_link_name.len = (short)strlen(m_Connect);
    EXEC SQL CONTEXT USE :m_ctx[m_nMyContextid];
*/

#include <stdio.h>
#include <sqlca.h>

#include "DatabaseMini.h"
#include <oci.h>

using namespace std;

EXEC SQL INCLUDE SQLCA;
EXEC SQL INCLUDE ORACA;

EXEC ORACLE OPTION (RELEASE_CURSOR = YES);
EXEC ORACLE OPTION (ORACA=YES);

extern struct oraca oraca;
extern void sqlgls(char*,size_t*,size_t *);

typedef struct long_varraw
{
    unsigned int len;
    char buf[1];
} long_varraw;
EXEC SQL TYPE long_varraw IS LONG VARRAW REFERENCE;

//线程运行上下文
EXEC SQL BEGIN DECLARE SECTION;
    extern sql_context m_ctx[ 200 ];
EXEC SQL END DECLARE SECTION;


CDatabaseMini::CDatabaseMini(void)
{

}

CDatabaseMini::~CDatabaseMini(void)
{

}

void CDatabaseMini::SetConnectDB(char* uid, char* pwd, char* sid)
{
    strncpy(miniuid, uid,32);
    strncpy(minipwd,pwd,32);
    strncpy(minisid, sid,32);
}

bool CDatabaseMini::ConnectDB()
{
    return ConnectMini();
}

/*================================================================
*
* 函 数 名：Get_User_GroupInfo
** 根据用户名分组信息
* 参 数：
* const uint32 [[IN]] : 用户ID
* XT_GROUPINFO_GET_ACK::tagGroupInfo* pGroupInfo [IN,OUT]: 用户分组信息
* int &nGroupNum [IN,OUT] : 所要获取的分组数和返回的分组数，如果输入为0，则输出存在的数目。
* 返 回 值：int -   SUCCESS: DB_SUCCESS; 数据库错误:DB_ERROR;
*
================================================================*/
int CDatabaseMini::Get_User_GroupInfo(const uint32 c_iUserID, XT_GROUPINFO_GET_ACK::tagGroupInfo* pGroupInfo, uint8 &nGroupNum, uint8 flag)
{
    DEF_ORASET;
    EXEC SQL BEGIN DECLARE SECTION;
        VARCHAR var_groupname[21];
        unsigned int     i_UserId,i_flag;
        int             g_pid,g_id,ret_count;
        VARCHAR db_link_name[32];
        int      retcode;
        SQL_CURSOR cur_group;
    EXEC SQL END DECLARE SECTION;


    strncpy((char*)db_link_name.arr, m_Connect,32);
    db_link_name.len = (short)strlen(m_Connect);

    SET_INIT_NULL(var_groupname);
    i_UserId = c_iUserID ;
    i_flag = flag;

    ret_count = 0;
    int db_ret;
    int iReconnTimes;
    bool bReconn;

    EXEC SQL CONTEXT USE :m_ctx[m_nMyContextid];
    EXEC SQL ALLOCATE :cur_group;

start:

    EXEC SQL AT :db_link_name EXECUTE
       begin
        Mini_Local_Pkg.GetGroupInfo(:i_UserId,:cur_group,:retcode,:i_flag);
    end;
    END-EXEC;

    db_ret = sqlca.sqlcode;
    if (conn_error(db_ret))
    {
        EXEC SQL CLOSE :cur_group;
        iReconnTimes=0;
        bReconn=ConnectDB();
        while(!bReconn)
        {
            iReconnTimes++;
            sleep(iReconnTimes%10);
            bReconn=ConnectDB();
        }
        goto start;
    }

    if( db_ret < 0 )
    {
        sql_error(sqlca, oraca);
        nGroupNum = 0;
        EXEC SQL CLOSE :cur_group;
        EXEC SQL FREE  :cur_group;
        return DB_ERROR;
    }

    for(;;)
    {

        EXEC SQL FETCH :cur_group INTO :g_pid,:g_id,:var_groupname;
        db_ret = sqlca.sqlcode;
        if (db_ret == 1403 )
        {
            nGroupNum = ret_count;
            break;
        }

        if( ret_count >= nGroupNum )//指定获取的数目
        {
            break;
        }

        if( db_ret < 0 )
        {
            nGroupNum = ret_count;
            break;
        }
        SET_END_NULL(var_groupname);

        pGroupInfo[ret_count].nGroupPid = g_pid;
        pGroupInfo[ret_count].nGroupID = g_id;
        strncpy(pGroupInfo[ret_count].szGroupName, (char*)var_groupname.arr, MAX_GROUPNAME_LEN);

        ++ret_count;
    }

    EXEC SQL CLOSE :cur_group;
    EXEC SQL FREE  :cur_group;

    return  DB_SUCCESS;

}
#ifdef XMPP_BUILD
int CDatabaseMini::WebMsgSave(XT_TALK* msg,uint32 logintime)
{
	DEF_ORASET;
	EXEC SQL BEGIN DECLARE SECTION;
		unsigned int from_id,to_id,data_type,version,send_time,recv_flag,fontSize,fontColor,fontStyle,recv_logintime,retcode;
		VARCHAR var_fontName[50],var_nickname[41],var_msg[1315],db_link_name[32],var_uuid[80];
	EXEC SQL END DECLARE SECTION;

	from_id = msg->from_id;
	to_id = msg->to_id;
	data_type = msg->data_type;
	version = msg->ver;
	send_time = msg->send_time;
	recv_flag = msg->recv_flag;
	fontSize = msg->fontSize;
	fontColor = msg->fontColor;
	fontStyle = msg->fontStyle;
	recv_logintime =logintime;
	
	SET_INIT_NULL(var_fontName);
	SET_INIT_NULL(var_nickname);
	SET_INIT_NULL(var_msg);
	SET_INIT_NULL(var_uuid);
	
	strncpy((char*)db_link_name.arr, m_Connect,32);
	db_link_name.len = (short)strlen((char*)db_link_name.arr);

	strncpy((char*)var_nickname.arr,msg->from_nickname,MAX_NICKNAME_LEN+1);/*4*/
	var_nickname.len = (short)strlen((char *)var_nickname.arr);

	strncpy((char*)var_fontName.arr,msg->fontName,50);
	var_fontName.len = (short)strlen((char *)var_fontName.arr);
	
	strncpy((char*)var_msg.arr,msg->data,1315);
	var_msg.len = (short)strlen((char *)var_msg.arr);

	strncpy((char*)var_uuid.arr,msg->uuid,MAX_UUID_LEN);
	var_uuid.len = (short)strlen((char *)var_uuid.arr);

	int db_ret;
	EXEC SQL CONTEXT USE :m_ctx[m_nMyContextid];
	int iReconnTimes;
	bool bReconn;

	start:	
	EXEC SQL AT :db_link_name EXECUTE
		begin
			Mini_User_Pkg.WebIMMsgSave_20151222(:from_id,:to_id,:data_type,:version,:send_time,:recv_flag,:fontSize,:fontColor,:fontStyle,:recv_logintime,:var_fontName,:var_nickname,:var_msg,:var_uuid,:retcode);
			end;
	END-EXEC;
	
	db_ret = sqlca.sqlcode;
	if (conn_error(db_ret))
	{
		iReconnTimes=0;
		bReconn=ConnectDB();
		while(!bReconn)
		{
			iReconnTimes++;
			sleep(iReconnTimes%10);
			bReconn=ConnectDB();
		}
		goto start;				
	}
		
	if (retcode == 1)
	{
		return DB_ERROR;
	}
	
	return DB_SUCCESS;	
}
#else
int CDatabaseMini::WebMsgSave(XT_TALK* msg,uint32 logintime)
{
    DEF_ORASET;
    EXEC SQL BEGIN DECLARE SECTION;
        unsigned int from_id,to_id,data_type,version,send_time,recv_flag,fontSize,fontColor,fontStyle,recv_logintime,retcode;
        VARCHAR var_fontName[50],var_nickname[41],var_msg[1315],db_link_name[32];
    EXEC SQL END DECLARE SECTION;

    from_id = msg->from_id;
    to_id = msg->to_id;
    data_type = msg->data_type;
    version = msg->ver;
    send_time = msg->send_time;
    recv_flag = msg->recv_flag;
    fontSize = msg->fontSize;
    fontColor = msg->fontColor;
    fontStyle = msg->fontStyle;
    recv_logintime =logintime;

    SET_INIT_NULL(var_fontName);
    SET_INIT_NULL(var_nickname);
    SET_INIT_NULL(var_msg);

    strncpy((char*)db_link_name.arr, m_Connect,32);
    db_link_name.len = (short)strlen((char*)db_link_name.arr);

    strncpy((char*)var_nickname.arr,msg->from_nickname,MAX_NICKNAME_LEN+1);/*4*/
    var_nickname.len = (short)strlen((char *)var_nickname.arr);

    strncpy((char*)var_fontName.arr,msg->fontName,50);
    var_fontName.len = (short)strlen((char *)var_fontName.arr);

    strncpy((char*)var_msg.arr,msg->data,1315);
    var_msg.len = (short)strlen((char *)var_msg.arr);

    int db_ret;
    EXEC SQL CONTEXT USE :m_ctx[m_nMyContextid];
    int iReconnTimes;
    bool bReconn;

start:
    EXEC SQL AT :db_link_name EXECUTE
       begin
        Mini_User_Pkg.WebIMMsgSave_20150708(:from_id,:to_id,:data_type,:version,:send_time,:recv_flag,:fontSize,:fontColor,:fontStyle,:recv_logintime,:var_fontName,:var_nickname,:var_msg,:retcode);
    end;
    END-EXEC;

    db_ret = sqlca.sqlcode;
    if (conn_error(db_ret))
    {
        iReconnTimes=0;
        bReconn=ConnectDB();
        while(!bReconn)
        {
            iReconnTimes++;
            sleep(iReconnTimes%10);
            bReconn=ConnectDB();
        }
        goto start;
    }

    if (retcode == 1)
    {
        return DB_ERROR;
    }

    return DB_SUCCESS;
}
#endif
int CDatabaseMini::WebRecommSave(uint32 fid,uint32 did,uint16 recomm,uint32 time,uint32 logintime,char* msg)
{
    DEF_ORASET;
    EXEC SQL BEGIN DECLARE SECTION;
        unsigned int from_id,to_id,recomment,send_time,login_time;
        VARCHAR var_msgs[1315];
        int retcode;
        VARCHAR db_link_name[32];
    EXEC SQL END DECLARE SECTION;

    from_id = fid;
    to_id = did;
    recomment = recomm;
    send_time = time;
    login_time = logintime;
    strncpy((char*)db_link_name.arr, m_Connect,32);
    db_link_name.len = (short)strlen((char*)db_link_name.arr);
    SET_INIT_NULL(var_msgs);

    strncpy((char*)var_msgs.arr, msg,1315);
    var_msgs.len = (short)strlen((char*)var_msgs.arr);

    int db_ret;
    EXEC SQL CONTEXT USE :m_ctx[m_nMyContextid];
    int iReconnTimes;
    bool bReconn;

start:
    EXEC SQL AT :db_link_name EXECUTE
       begin
        Mini_User_Pkg.WebRecommSave(:from_id,:to_id,:recomment,:send_time,:login_time,:var_msgs,:retcode);
    end;
    END-EXEC;

    db_ret = sqlca.sqlcode;
    if (conn_error(db_ret))
    {
        iReconnTimes=0;
        bReconn=ConnectDB();
        while(!bReconn)
        {
            iReconnTimes++;
            sleep(iReconnTimes%10);
            bReconn=ConnectDB();
        }
        goto start;
    }

    if (retcode == 1 || retcode == 1403)
    {
        return DB_ERROR;
    }

    return DB_SUCCESS;
}

int CDatabaseMini::WebServiceSave(uint32 fid,uint32 did,uint16 recomm,uint32 time)
{
    DEF_ORASET;
    EXEC SQL BEGIN DECLARE SECTION;
        unsigned int from_id,to_id,recomment,send_time;
        int retcode;
        VARCHAR db_link_name[32];
    EXEC SQL END DECLARE SECTION;

    from_id = fid;
    to_id = did;
    recomment = recomm;
    send_time = time;

    strncpy((char*)db_link_name.arr, m_Connect,32);
    db_link_name.len = (short)strlen((char*)db_link_name.arr);

    int db_ret;
    EXEC SQL CONTEXT USE :m_ctx[m_nMyContextid];
    int iReconnTimes;
    bool bReconn;

start:
    EXEC SQL AT :db_link_name EXECUTE
       begin
        Mini_User_Pkg.WebServiceSave(:from_id,:to_id,:recomment,:send_time,:retcode);
    end;
    END-EXEC;

    db_ret = sqlca.sqlcode;
    if (conn_error(db_ret))
    {
        iReconnTimes=0;
        bReconn=ConnectDB();
        while(!bReconn)
        {
            iReconnTimes++;
            sleep(iReconnTimes%10);
            bReconn=ConnectDB();
        }
        goto start;
    }

    if (retcode == 1)
    {
        return DB_ERROR;
    }

    return DB_SUCCESS;
}

int CDatabaseMini::WebBusiListReq(XT_WEB_BUSI_LIST_REQ* BusiListReq,XT_WEB_BUSI_LIST_ACK::BusiList* pListInfo,uint32& nRetCount)
{
    DEF_ORASET;
    EXEC SQL BEGIN DECLARE SECTION;
        VARCHAR db_link_name[32],var_nickname[41],var_headImg[101],var_usersign[250];
        unsigned int id,msgnum,list_id,c_time;
        int retcode;
        SQL_CURSOR cur_listInfo;
    EXEC SQL END DECLARE SECTION;

    strncpy((char*)db_link_name.arr, m_Connect,32);
    db_link_name.len = (short)strlen(m_Connect);

    id=BusiListReq->id;
    msgnum=BusiListReq->msgnum;

    SET_INIT_NULL(var_nickname);
    SET_INIT_NULL(var_headImg);
    SET_INIT_NULL(var_usersign);

    int db_ret, iReconnTimes;
    uint32 iNum = 0;
    bool bReconn;

    EXEC SQL CONTEXT USE :m_ctx[m_nMyContextid];

start:
    EXEC SQL ALLOCATE :cur_listInfo;
    EXEC SQL AT :db_link_name EXECUTE
    begin
      Mini_User_Pkg.WebListReq_20151020(:id,:msgnum,:cur_listInfo,:retcode);
    end;
    END-EXEC;

    db_ret = sqlca.sqlcode;
    if (conn_error(db_ret))
    {
        EXEC SQL CLOSE :cur_listInfo;
        iReconnTimes=0;
        bReconn=ConnectDB();
        while(!bReconn)
        {
            iReconnTimes++;
            sleep(iReconnTimes%10);
            bReconn=ConnectDB();
        }
        goto start;
    }

    if(db_ret < 0 && db_ret != -1405)
    {
        sql_error(sqlca, oraca);
        EXEC SQL CLOSE :cur_listInfo;
        EXEC SQL FREE  :cur_listInfo;
        return DB_ERROR;
    }

    for(;;)
    {
        EXEC SQL FETCH :cur_listInfo INTO :list_id,:c_time,:var_nickname,:var_headImg,:var_usersign;
        db_ret = sqlca.sqlcode;
        if (db_ret == 1403 )
        {
            nRetCount = iNum;
            break;
        }
        if (iNum >= nRetCount)
        {
            break;
        }
        if( db_ret < 0 && db_ret != -1405 )
        {
            sql_error(sqlca, oraca);
            nRetCount = iNum;
            break;
        }
        pListInfo[iNum].id = list_id;
        pListInfo[iNum].time = c_time;

        SET_END_NULL(var_nickname);
        SET_END_NULL(var_headImg);
        SET_END_NULL(var_usersign);
        strncpy(pListInfo[iNum].nickname,(char*)var_nickname.arr,MAX_NICKNAME_LEN+1);
        strncpy(pListInfo[iNum].headImgUrl,(char*)var_headImg.arr,MAX_HEADURL_LEN+1);
        strncpy(pListInfo[iNum].usersign,(char*)var_usersign.arr,MAX_USERSIGN_LEN+1);

        ++iNum;
    }
    EXEC SQL CLOSE :cur_listInfo;
    EXEC SQL FREE  :cur_listInfo;
    return DB_SUCCESS;
}

int CDatabaseMini::XmppBusiListReq(XT_XMPP_BUSI_LIST_REQ* BusiListReq,XT_XMPP_BUSI_LIST_ACK::BusiList* pListInfo,uint32& nRetCount)
{
	DEF_ORASET;
	EXEC SQL BEGIN DECLARE SECTION;
		VARCHAR	db_link_name[32],var_nickname[41],var_headImg[101],var_usersign[250];
		unsigned int id,msgnum,list_id,c_time;
		int	retcode;
		SQL_CURSOR cur_listInfo;
	EXEC SQL END DECLARE SECTION;

	strncpy((char*)db_link_name.arr, m_Connect,32);
	db_link_name.len = (short)strlen(m_Connect);
	
	id=BusiListReq->id;
	msgnum=BusiListReq->msgnum;
	
	SET_INIT_NULL(var_nickname);
	SET_INIT_NULL(var_headImg);
	SET_INIT_NULL(var_usersign);
  
	int db_ret, iReconnTimes;
	uint32 iNum = 0;	
	bool bReconn;	
	
	EXEC SQL CONTEXT USE :m_ctx[m_nMyContextid];  

start:  
		EXEC SQL ALLOCATE :cur_listInfo;
		EXEC SQL AT :db_link_name EXECUTE
			begin
				Mini_User_Pkg.WebListReq_20151020(:id,:msgnum,:cur_listInfo,:retcode);
			end;
		END-EXEC;

		db_ret = sqlca.sqlcode;
		if (conn_error(db_ret))
		{
			EXEC SQL CLOSE :cur_listInfo;
			iReconnTimes=0;
			bReconn=ConnectDB();
			while(!bReconn)
			{
				iReconnTimes++;
				sleep(iReconnTimes%10);
				bReconn=ConnectDB();
			}
			goto start;				
		}
		
		if(db_ret < 0 && db_ret != -1405) 
		{
			sql_error(sqlca, oraca);		
			EXEC SQL CLOSE :cur_listInfo;
			EXEC SQL FREE  :cur_listInfo;
			return DB_ERROR;
		}

		for(;;)
		{  
			EXEC SQL FETCH :cur_listInfo INTO :list_id,:c_time,:var_nickname,:var_headImg,:var_usersign;
			db_ret = sqlca.sqlcode;
			if (db_ret == 1403 )
			{
				nRetCount = iNum;
				break;
			}
			if (iNum >= nRetCount)
			{
				break;
			}	
			if( db_ret < 0 && db_ret != -1405 )
			{
				sql_error(sqlca, oraca);
				nRetCount = iNum;
				break;
			}		
			pListInfo[iNum].id = list_id;
			pListInfo[iNum].time = c_time;
			
			SET_END_NULL(var_nickname);
			SET_END_NULL(var_headImg);
			SET_END_NULL(var_usersign);
			strncpy(pListInfo[iNum].nickname,(char*)var_nickname.arr,MAX_NICKNAME_LEN+1);	
			strncpy(pListInfo[iNum].headImgUrl,(char*)var_headImg.arr,MAX_HEADURL_LEN+1);
			strncpy(pListInfo[iNum].usersign,(char*)var_usersign.arr,MAX_USERSIGN_LEN+1);

			++iNum;
		}
		EXEC SQL CLOSE :cur_listInfo;
		EXEC SQL FREE  :cur_listInfo;
		return DB_SUCCESS;		
}


int CDatabaseMini::WebMsgReq(XT_WEB_MORE_MSG_REQ* msgReq,XT_WEB_MORE_MSG_ACK::MsgInfo* msgInfo,uint32& nRetCount)
{
    DEF_ORASET;
    EXEC SQL BEGIN DECLARE SECTION;
        VARCHAR db_link_name[32],var_fontName[50],var_nickName[41],var_data[1315];
        unsigned int sid,did,msgtime,msgnum,msgid;
        unsigned int id,send_time,fontSize,fontColor,fontStyle;
        int retcode;
        SQL_CURSOR cur_msgInfo;
    EXEC SQL END DECLARE SECTION;

    strncpy((char*)db_link_name.arr, m_Connect,32);
    db_link_name.len = (short)strlen(m_Connect);

    sid=msgReq->sid;
    did=msgReq->did;
    msgtime=msgReq->msgtime;
    msgnum=msgReq->msgnum;
    msgid=msgReq->msgid;

    SET_INIT_NULL(var_fontName);
    SET_INIT_NULL(var_nickName);
    SET_INIT_NULL(var_data);


    int db_ret, iReconnTimes;
    uint32 iNum = 0;
    bool bReconn;

    EXEC SQL CONTEXT USE :m_ctx[m_nMyContextid];

start:
    EXEC SQL ALLOCATE :cur_msgInfo;
    EXEC SQL AT :db_link_name EXECUTE
    begin
      Mini_User_Pkg.WebMsgReq(:sid,:did,:msgtime,:msgid,:msgnum,:cur_msgInfo,:retcode);
    end;
    END-EXEC;

    db_ret = sqlca.sqlcode;
    if (conn_error(db_ret))
    {
        EXEC SQL CLOSE :cur_msgInfo;
        iReconnTimes=0;
        bReconn=ConnectDB();
        while(!bReconn)
        {
            iReconnTimes++;
            sleep(iReconnTimes%10);
            bReconn=ConnectDB();
        }
        goto start;
    }

    if(db_ret < 0 && db_ret != -1405)
    {
        sql_error(sqlca, oraca);
        EXEC SQL CLOSE :cur_msgInfo;
        EXEC SQL FREE  :cur_msgInfo;
        return DB_ERROR;
    }

    for(;;)
    {
        EXEC SQL FETCH :cur_msgInfo INTO :id,:send_time,:fontSize,:fontColor,:fontStyle,:var_fontName,:var_nickName,:var_data,:msgid;
        db_ret = sqlca.sqlcode;
        if (db_ret == 1403 )
        {
            nRetCount = iNum;
            break;
        }
        if (iNum >= nRetCount)
        {
            break;
        }
        if( db_ret < 0 && db_ret != -1405 )
        {
            sql_error(sqlca, oraca);
            nRetCount = iNum;
            break;
        }
        msgInfo[iNum].id = id;
        msgInfo[iNum].send_time = send_time;
        msgInfo[iNum].fontSize = fontSize;
        msgInfo[iNum].fontColor = fontColor;
        msgInfo[iNum].fontStyle = fontStyle;
        msgInfo[iNum].msgid = msgid;

        SET_END_NULL(var_fontName);
        SET_END_NULL(var_nickName);
        SET_END_NULL(var_data);


        strncpy(msgInfo[iNum].fontName,(char*)var_fontName.arr,50);
        strncpy(msgInfo[iNum].nickName,(char*)var_nickName.arr,MAX_NICKNAME_LEN+1);
        strncpy(msgInfo[iNum].data,(char*)var_data.arr,1315);



        ++iNum;
    }
    EXEC SQL CLOSE :cur_msgInfo;
    EXEC SQL FREE  :cur_msgInfo;
    return DB_SUCCESS;
}

int CDatabaseMini::WebMsgMoreReq(XT_WEB_MORE_MSG_REQ* msgReq,XT_WEB_MORE_MSG_ACK::MsgInfo* msgInfo,std::vector<uint32_t> &ids, uint32& nRetCount)
{
    DEF_ORASET;
    EXEC SQL BEGIN DECLARE SECTION;
        VARCHAR db_link_name[32],var_fontName[50],var_nickName[41],var_data[1315];
        VARCHAR merchant_ids[1024];
        unsigned int sid,msgtime,msgnum,msgid;
        unsigned int id,send_time,fontSize,fontColor,fontStyle;
        int retcode;
        SQL_CURSOR cur_msgInfo;
    EXEC SQL END DECLARE SECTION;

    SET_INIT_NULL(merchant_ids);
    for(unsigned int i = 0; i < ids.size(); i++)
    {
        char buffer[64] = {0};
        strcat((char *)merchant_ids.arr,itoa(ids[i],buffer,10));
        strcat((char *)merchant_ids.arr,",");
    }
    merchant_ids.arr[(short)strlen((char*)merchant_ids.arr)-1] = '\0';
    merchant_ids.len = (short)strlen((char*)merchant_ids.arr);

    strncpy((char*)db_link_name.arr, m_Connect,32);
    db_link_name.len = (short)strlen(m_Connect);

    sid=msgReq->sid;
//  did=msgReq->did;
    msgtime=msgReq->msgtime;
    msgnum=msgReq->msgnum;
    msgid=msgReq->msgid;

    SET_INIT_NULL(var_fontName);
    SET_INIT_NULL(var_nickName);
    SET_INIT_NULL(var_data);


    int db_ret, iReconnTimes;
    uint32 iNum = 0;
    bool bReconn;

    EXEC SQL CONTEXT USE :m_ctx[m_nMyContextid];

start:
    EXEC SQL ALLOCATE :cur_msgInfo;
    EXEC SQL AT :db_link_name EXECUTE
    begin
      Mini_User_Pkg.WebMsgMoreReq(:sid,:msgtime,:msgid,:msgnum,:merchant_ids,:cur_msgInfo,:retcode);
    end;
    END-EXEC;

    db_ret = sqlca.sqlcode;
    if (conn_error(db_ret))
    {
        EXEC SQL CLOSE :cur_msgInfo;
        iReconnTimes=0;
        bReconn=ConnectDB();
        while(!bReconn)
        {
            iReconnTimes++;
            sleep(iReconnTimes%10);
            bReconn=ConnectDB();
        }
        goto start;
    }

    if(db_ret < 0 && db_ret != -1405)
    {
        sql_error(sqlca, oraca);
        EXEC SQL CLOSE :cur_msgInfo;
        EXEC SQL FREE  :cur_msgInfo;
        return DB_ERROR;
    }

    for(;;)
    {
        EXEC SQL FETCH :cur_msgInfo INTO :id,:send_time,:fontSize,:fontColor,:fontStyle,:var_fontName,:var_nickName,:var_data,:msgid;
        db_ret = sqlca.sqlcode;
        if (db_ret == 1403 )
        {
            nRetCount = iNum;
            break;
        }
        if (iNum >= nRetCount)
        {
            break;
        }
        if( db_ret < 0 && db_ret != -1405 )
        {
            sql_error(sqlca, oraca);
            nRetCount = iNum;
            break;
        }
        msgInfo[iNum].id = id;
        msgInfo[iNum].send_time = send_time;
        msgInfo[iNum].fontSize = fontSize;
        msgInfo[iNum].fontColor = fontColor;
        msgInfo[iNum].fontStyle = fontStyle;
        msgInfo[iNum].msgid = msgid;

        SET_END_NULL(var_fontName);
        SET_END_NULL(var_nickName);
        SET_END_NULL(var_data);


        strncpy(msgInfo[iNum].fontName,(char*)var_fontName.arr,50);
        strncpy(msgInfo[iNum].nickName,(char*)var_nickName.arr,MAX_NICKNAME_LEN+1);
        strncpy(msgInfo[iNum].data,(char*)var_data.arr,1315);



        ++iNum;
    }
    EXEC SQL CLOSE :cur_msgInfo;
    EXEC SQL FREE  :cur_msgInfo;
    return DB_SUCCESS;
}

/*================================================================
*
* 函 数 名：Get_Family_MaxMsgID
** 根据家族ID获取当前家族最大和最小消息ID
* 参 数：
* uint32 c_iFamilyID [[IN]] : 家族ID
* uint32 & nMsgID [IN,OUT]: 家族当前消息ID
* 返 回 值：int -   SUCCESS: DB_SUCCESS; 数据库错误:DB_ERROR;  如果家族创建后无任何消息，nMsgID = 0;
*
================================================================*/
int  CDatabaseMini::Get_Family_MaxMsgID(const uint32 c_iFamilyID, uint32 & nMaxMsgID, uint32 &nMinMsgID)
{
    DEF_ORASET;
    EXEC SQL BEGIN DECLARE SECTION;
        unsigned int      nFamilyID;
        unsigned int      nmaxmsgid,nminmsgid;
        VARCHAR db_link_name[32];
        int      retcode;
    EXEC SQL END DECLARE SECTION;

    nMaxMsgID = 0;
    nFamilyID = c_iFamilyID;
    nmaxmsgid = 0;
    nminmsgid = 0;

    strncpy((char*)db_link_name.arr, m_Connect,32);
    db_link_name.len = (short)strlen(m_Connect);

    int db_ret;
    int iReconnTimes;
    bool bReconn;

    EXEC SQL CONTEXT USE :m_ctx[m_nMyContextid];

start:

    EXEC SQL AT :db_link_name EXECUTE
       begin
        Mini_Local_Pkg.GetFamilyMsgID(:nFamilyID,:nmaxmsgid,:nminmsgid,:retcode);
    end;
    END-EXEC;

    db_ret = sqlca.sqlcode;
    if (conn_error(db_ret))
    {
        iReconnTimes=0;
        bReconn=ConnectDB();
        while(!bReconn)
        {
            iReconnTimes++;
            sleep(iReconnTimes%10);
            bReconn=ConnectDB();
        }
        goto start;
    }

    if( db_ret < 0 && db_ret != -1405) //数据库发生错误
    {
        sql_error(sqlca, oraca);
        CLog::Log("Get_Family_MaxMsgID",CLog::TYPE_ERROR,"获取家族最大消息ID失败,nFamilyID:%d, db_ret:%d",nFamilyID,db_ret);
        return DB_ERROR;
    }

    if( db_ret >= 0 && db_ret != 1403)
    {
        nMaxMsgID = nmaxmsgid;
        nMinMsgID = nminmsgid;
    }
    else    //初始ID从1开始
    {
        nMaxMsgID = 1;
        nMinMsgID = 0;
    }

    return DB_SUCCESS;
}

/*================================================================
*
* 函 数 名：Save_Family_RequestMsg
** 保存家族请求消息ID
* 参 数：
* uint32 c_iFamilyID    [IN] : 家族ID
* uint32 iSenderID      [IN] : 发送者ID
* uint32 iSendTime      [IN] : 请求时间
* char   *strMsg        [IN] : 请求内容
* int    iMsgLen        [IN] : 内容长度
* 返 回 值：int -   SUCCESS: DB_SUCCESS; 数据库错误:DB_ERROR;
*
================================================================*/
int CDatabaseMini::Save_Family_RequestMsg(const uint32 c_iFamilyID, uint32 iSenderID,uint32 iSendTime,const char *strMsg, int iMsgLen)
{
    DEF_ORASET;
    EXEC SQL BEGIN DECLARE SECTION;
        long_varraw * lvr;
        unsigned int     nFamilyID, nSenderID, nSendTime, nMsgSeq;
        int nMsgLen, nMsgType;
        char*   pmsg;
        OCIBlobLocator *blob;
        unsigned int offset = 1; /* attention: typedef ub4 unsigned int */
        VARCHAR db_link_name[32];
    EXEC SQL END DECLARE SECTION;

    strncpy((char*)db_link_name.arr, m_Connect,32);
    db_link_name.len = (short)strlen(m_Connect);


    nFamilyID = c_iFamilyID;
    nSenderID = iSenderID;
    nSendTime = iSendTime;
    nMsgLen = iMsgLen;
    nMsgType = CMD_CLUSTER_AUTH_REQ;
    pmsg = (char*)strMsg;

    int db_ret;
    int iReconnTimes;
    bool bReconn;

    EXEC SQL CONTEXT USE :m_ctx[m_nMyContextid];

start:
    EXEC SQL AT :db_link_name ALLOCATE :blob;

    EXEC SQL AT :db_link_name SELECT IM_CLUSTERSYSMSG_SEQ_MSGID.nextval INTO :nMsgSeq FROM DUAL;
    EXEC SQL AT :db_link_name INSERT INTO IM_CLUSTERSYSMSG(MSGID, CLUSTERID,SENDER,SRCIP,SRCPORT,SENDTIME,MSGTYPE,MSGLEN,MSG)
       VALUES(:nMsgSeq, :nFamilyID,:nSenderID,0,0,:nSendTime,:nMsgType,:nMsgLen,empty_blob());
    db_ret = sqlca.sqlcode;
    if (conn_error(db_ret))
    {
        iReconnTimes=0;
        bReconn=ConnectDB();
        while(!bReconn)
        {
            iReconnTimes++;
            sleep(iReconnTimes%10);
            bReconn=ConnectDB();
        }
        goto start;
    }

    if( db_ret < 0 || db_ret == 1403 )
    {
        sql_error(sqlca, oraca);
        EXEC SQL AT :db_link_name ROLLBACK;
        EXEC SQL AT :db_link_name FREE :blob;
        return DB_ERROR;
    }

    EXEC SQL AT :db_link_name COMMIT;

    EXEC SQL AT :db_link_name SELECT MSG INTO :blob  FROM IM_CLUSTERSYSMSG
       WHERE MSGID = :nMsgSeq FOR UPDATE;

    db_ret = sqlca.sqlcode;
    if (conn_error(db_ret))
    {
        iReconnTimes=0;
        bReconn=ConnectDB();
        while(!bReconn)
        {
            iReconnTimes++;
            sleep(iReconnTimes%10);
            bReconn=ConnectDB();
        }
        goto start;
    }

    if( db_ret < 0 || db_ret == 1403 )
    {
        sql_error(sqlca, oraca);
        EXEC SQL AT :db_link_name ROLLBACK;
        EXEC SQL AT :db_link_name FREE :blob;
        return DB_ERROR;
    }

    lvr = (long_varraw *)malloc(sizeof(ub4) + nMsgLen);
    lvr->len = nMsgLen;
    memcpy(lvr->buf,pmsg,nMsgLen);
    EXEC SQL AT :db_link_name LOB WRITE ONE :nMsgLen
        FROM :lvr WITH LENGTH :nMsgLen INTO :blob AT :offset;

    db_ret = sqlca.sqlcode;
    if (conn_error(db_ret))
    {
        iReconnTimes=0;
        bReconn=ConnectDB();
        while(!bReconn)
        {
            iReconnTimes++;
            sleep(iReconnTimes%10);
            bReconn=ConnectDB();
        }
        goto start;
    }

    if( db_ret < 0 || db_ret == 1403 )
    {
        sql_error(sqlca, oraca);
        EXEC SQL AT :db_link_name ROLLBACK;
        EXEC SQL AT :db_link_name FREE :blob;
        free(lvr);
        return DB_ERROR;
    }
    free(lvr);

    EXEC SQL AT :db_link_name UPDATE IM_CLUSTERSYSMSG SET MSG = :blob
       WHERE MSGID = :nMsgSeq;
    db_ret = sqlca.sqlcode;
    if (conn_error(db_ret))
    {
        iReconnTimes=0;
        bReconn=ConnectDB();
        while(!bReconn)
        {
            iReconnTimes++;
            sleep(iReconnTimes%10);
            bReconn=ConnectDB();
        }
        goto start;
    }

    if( db_ret < 0 || db_ret == 1403 )
    {
        sql_error(sqlca, oraca);
        EXEC SQL AT :db_link_name ROLLBACK;
        EXEC SQL AT :db_link_name FREE :blob;
        return DB_ERROR;
    }

    EXEC SQL AT :db_link_name COMMIT WORK;
    EXEC SQL AT :db_link_name FREE :blob;
    EXEC SQL AT :db_link_name COMMIT;

    return DB_SUCCESS;
}

int CDatabaseMini::Save_Offline_Msg(uint32 iRecvID,uint32 iSendID,uint32 iNatIP,uint16 iNatPort,uint32 iTime,
					uint16 iMsgType,const char *strMsg, uint16 iMsgLen, const char *strText,uint32 sendtime,char *uuid)
{
	DEF_ORASET;
	EXEC SQL BEGIN DECLARE SECTION;
		long_varraw * lvr;
		unsigned int	nRecvID,nSendID,nMsgLen;
		unsigned int	int_tmp,natip,var_sendtime;
		short	natport,nMsgType;
		char*	pmsg;
		OCIBlobLocator *blob;
		unsigned int offset = 1;  /* attention: typedef ub4 unsigned int */
		VARCHAR db_link_name[32], var_text[1315];
		VARCHAR var_fromname[41], var_toname[41];
		VARCHAR var_uuid[41],var_sendtime_1[64];
	EXEC SQL END DECLARE SECTION;
	CLog::Log("Save_Offline_Msg",CLog::TYPE_DEBUG,
		"iRecvID is %d,iSendID is %d,iNatIP is %d,iNatPort is %d,iTime is %d,iMsgType is %d,strMsg is %s,iMsgLen is %d,strText is %s sendtime %u uuid %s",
		iRecvID,iSendID,iNatIP,iNatPort,iTime,iMsgType,strMsg,iMsgLen,strText,sendtime,uuid); 
	if( !strMsg )
	{
		CLog::Log("Save_Offline_Msg",CLog::TYPE_DEBUG,"strMsg is NULL");
		return DB_PARAM;
	}
	if(strlen(strText) == 0 )
	{
		 CLog::Log("Save_Offline_Msg",CLog::TYPE_DEBUG,"strText len is 0");
		 return DB_PARAM;
	}
	strncpy((char*)db_link_name.arr, m_Connect,32);
	db_link_name.len = (short)strlen(m_Connect);

	SET_INIT_NULL(var_text);
	SET_INIT_NULL(var_fromname);
	SET_INIT_NULL(var_toname);
	SET_INIT_NULL(var_uuid);
	SET_INIT_NULL(var_sendtime_1);
	nRecvID = iRecvID;
	nSendID = iSendID;
	var_sendtime = sendtime;
	//nTime = iTime;
	nMsgLen = iMsgLen;
	nMsgType = iMsgType;
	pmsg = (char*)strMsg;
	strncpy((char *)var_text.arr,strText,1315);
	var_text.len=(unsigned short)strlen(strText);
	strncpy((char *)var_uuid.arr,uuid,41);
	var_uuid.len=(unsigned short)strlen(uuid);
	natport = iNatPort;
	natip = iNatIP;
	//delline = 3;
		
	int db_ret;
	int iReconnTimes;
	bool bReconn;
 
	EXEC SQL CONTEXT USE :m_ctx[m_nMyContextid];

start: 
	EXEC SQL AT :db_link_name ALLOCATE :blob;
	if( nMsgType == CMD_P2PMSG_SEND )
	{
		EXEC SQL AT :db_link_name SELECT COUNT(MSGID) INTO :int_tmp FROM IM_OFFLINETALKMSG 
			WHERE RECEIVER=:nRecvID;
		db_ret = sqlca.sqlcode;
		if (conn_error(db_ret))
		{
			iReconnTimes=0;
			bReconn=ConnectDB();
			while(!bReconn)
			{
				iReconnTimes++;
				sleep(iReconnTimes%10);
				bReconn=ConnectDB();
			}
			goto start; 			
		}
		
		if( db_ret < 0 )
		{
			sql_error(sqlca, oraca);
			EXEC SQL AT :db_link_name FREE :blob;
			return DB_ERROR;
		}

		if (db_ret == 1403)
			int_tmp = 0;
		
		if( int_tmp >= OFFLINE_MAX_MSGNUM  && nRecvID != MANAGER_ID) 
		{
			EXEC SQL AT :db_link_name DELETE FROM IM_OFFLINETALKMSG WHERE  MSGID=(SELECT Min(MSGID) FROM IM_OFFLINETALKMSG WHERE RECEIVER=:nRecvID);
			db_ret = sqlca.sqlcode;
			if (conn_error(db_ret))
			{
				iReconnTimes=0;
				bReconn=ConnectDB();
				while(!bReconn)
				{
					iReconnTimes++;
					sleep(iReconnTimes%10);
					bReconn=ConnectDB();
				}
				goto start; 			
			}
			
			if( db_ret < 0	)
			{
				sql_error(sqlca, oraca);
				EXEC SQL AT :db_link_name FREE :blob;
				EXEC SQL AT :db_link_name ROLLBACK;
				return DB_ERROR;			
			}
			EXEC SQL AT :db_link_name COMMIT; 
		}
		
		EXEC SQL AT :db_link_name select nickname into :var_fromname from im_userinfo where userid=:nSendID;
		EXEC SQL AT :db_link_name select nickname into :var_toname from im_userinfo where userid=:nRecvID;
		EXEC SQL AT :db_link_name SELECT IM_OFFLINETALKMSG_SEQ_MSGID.nextval into :int_tmp FROM DUAL;
		/* 如果要用IM服务器时间，则 sendtime=cast(from_tz(to_timestamp ('19700101000000', 'yyyymmddhh24miss')+ numtodsinterval(:nTime, 'second'), 'gmt') at time zone sessiontimezone as date) */
		
		//EXEC SQL AT :db_link_name select   into :var_sendtime_1 from dual;

		EXEC SQL AT :db_link_name INSERT INTO IM_OFFLINETALKMSG(MSGID, RECEIVER,SENDER,SRCIP,SRCPORT,SENDTIME,
			MSGTYPE,MSGLEN,MSG,TEXT,SenderName,ReceiverName,UUID)
			VALUES(:int_tmp, :nRecvID,:nSendID,:natip,:natport,to_date('1970-01-01 ','yyyy-MM-dd HH:MI:SS')+((:var_sendtime + 28800)/(3600*24)),
			:nMsgType,:nMsgLen,empty_blob(),:var_text,:var_fromname,:var_toname,:var_uuid);
		db_ret = sqlca.sqlcode;
		if (conn_error(db_ret))
		{
			iReconnTimes=0;
			bReconn=ConnectDB();
			while(!bReconn)
			{
				iReconnTimes++;
				sleep(iReconnTimes%10);
				bReconn=ConnectDB();
			}
			goto start; 			
		}
		
		if( db_ret < 0 || db_ret == 1403 )
		{
			sql_error(sqlca, oraca);
			EXEC SQL AT :db_link_name FREE :blob;
			EXEC SQL AT :db_link_name ROLLBACK;
			return DB_ERROR;			
		}
		EXEC SQL AT :db_link_name COMMIT; 

		EXEC SQL AT :db_link_name SELECT MSG INTO :blob  FROM IM_OFFLINETALKMSG 
			WHERE MSGID = :int_tmp FOR UPDATE;
		db_ret = sqlca.sqlcode;
		if (conn_error(db_ret))
		{
			iReconnTimes=0;
			bReconn=ConnectDB();
			while(!bReconn)
			{
				iReconnTimes++;
				sleep(iReconnTimes%10);
				bReconn=ConnectDB();
			}
			goto start; 			
		}
		
		if( sqlca.sqlcode < 0 || sqlca.sqlcode == 1403 )
		{
			sql_error(sqlca, oraca);
			EXEC SQL AT :db_link_name FREE :blob;
			EXEC SQL AT :db_link_name ROLLBACK;
			return DB_ERROR;			
		} 
	}


	lvr = (long_varraw *)malloc(sizeof(ub4) + nMsgLen);
	lvr->len = nMsgLen;
	memcpy(lvr->buf,pmsg,nMsgLen);
	EXEC SQL AT :db_link_name LOB WRITE ONE :nMsgLen
			FROM :lvr WITH LENGTH :nMsgLen INTO :blob AT :offset;
	db_ret = sqlca.sqlcode;
	if (conn_error(db_ret))
	{
		iReconnTimes=0;
		bReconn=ConnectDB();
		while(!bReconn)
		{
			iReconnTimes++;
			sleep(iReconnTimes%10);
			bReconn=ConnectDB();
		}
		goto start; 			
	}
	
	if( db_ret < 0 || db_ret == 1403 )
	{
		sql_error(sqlca, oraca);
		EXEC SQL AT :db_link_name FREE :blob;
		EXEC SQL AT :db_link_name ROLLBACK;
		free(lvr);
		return DB_ERROR;			
	} 
	free(lvr);

	if( nMsgType == CMD_P2PMSG_SEND )
	{
		EXEC SQL AT :db_link_name UPDATE IM_OFFLINETALKMSG SET MSG = :blob 
			WHERE MSGID = :int_tmp;
		db_ret = sqlca.sqlcode;
		if (conn_error(db_ret))
		{
			iReconnTimes=0;
			bReconn=ConnectDB();
			while(!bReconn)
			{
				iReconnTimes++;
				sleep(iReconnTimes%10);
				bReconn=ConnectDB();
			}
			goto start; 			
		}
		
		if( db_ret < 0 || db_ret == 1403 )
		{
			sql_error(sqlca, oraca);
			EXEC SQL AT :db_link_name FREE :blob;
			EXEC SQL AT :db_link_name ROLLBACK;
			return DB_ERROR;			
		} 
		EXEC SQL AT :db_link_name COMMIT; 
	}
	

	EXEC SQL AT :db_link_name COMMIT WORK;
	EXEC SQL AT :db_link_name FREE :blob;
	EXEC SQL AT :db_link_name COMMIT;

	return DB_SUCCESS;
}

/*================================================================
*
* 函 数 名：Save_User_Msg
** 保存用户的消息，包括系统消息
* 参 数：
* uint32 iRecvID    [IN] : 家族ID
* uint32 iSendID        [IN] : 发送者ID
* uint32 iNatIP,uint16 iNatPort,uint32 iTime [IN]
* uint16 iMsgType       [IN] : 消息类型
* char   *strMsg        [IN] : 消息内容
* uint16     iMsgLen        [IN] : 内容长度
* 返 回 值：int -   SUCCESS: DB_SUCCESS; 数据库错误:DB_ERROR;
*
================================================================*/
int CDatabaseMini::Save_User_Msg(uint32 iRecvID,uint32 iSendID,uint32 iNatIP,uint16 iNatPort,uint32 iTime,uint16 iMsgType,const char *strMsg, uint16 iMsgLen,const char *strText)
{
    DEF_ORASET;
    EXEC SQL BEGIN DECLARE SECTION;
        long_varraw * lvr;
        unsigned int    nRecvID,nSendID, nTime,nMsgLen;
        unsigned int    int_tmp,natip;
        short   natport,nMsgType;
        char*   pmsg;
        OCIBlobLocator *blob;
        unsigned int offset = 1;  /* attention: typedef ub4 unsigned int */
        VARCHAR db_link_name[32], var_text[1315];
        VARCHAR var_fromname[41], var_toname[41];
    EXEC SQL END DECLARE SECTION;
    CLog::Log("Save_User_Msg",CLog::TYPE_DEBUG,"iRecvID is %d,iSendID is %d,iNatIP is %d,iNatPort is %d,iTime is %d,iMsgType is %d,strMsg is %s,iMsgLen is %d,strText is %s",
              iRecvID,iSendID,iNatIP,iNatPort,iTime,iMsgType,strMsg,iMsgLen,strText);
    if( !strMsg )
    {
        CLog::Log("Save_User_Msg",CLog::TYPE_DEBUG,"strMsg is NULL");
        return DB_PARAM;
    }
    if(strlen(strText) == 0 )
    {
        CLog::Log("Save_User_Msg",CLog::TYPE_DEBUG,"strText len is 0");
        return DB_PARAM;
    }
    strncpy((char*)db_link_name.arr, m_Connect,32);
    db_link_name.len = (short)strlen(m_Connect);

    SET_INIT_NULL(var_text);
    SET_INIT_NULL(var_fromname);
    SET_INIT_NULL(var_toname);

    nRecvID = iRecvID;
    nSendID = iSendID;
    nTime = iTime;
    nMsgLen = iMsgLen;
    nMsgType = iMsgType;
    pmsg = (char*)strMsg;
    strncpy((char *)var_text.arr,strText,1315);
    var_text.len=(unsigned short)strlen(strText);
    natport = iNatPort;
    natip = iNatIP;
    //delline = 3;

    int db_ret;
    int iReconnTimes;
    bool bReconn;

    EXEC SQL CONTEXT USE :m_ctx[m_nMyContextid];

start:
    EXEC SQL AT :db_link_name ALLOCATE :blob;
    if( nMsgType == CMD_P2PMSG_SEND )
    {
        EXEC SQL AT :db_link_name SELECT COUNT(MSGID) INTO :int_tmp FROM IM_OFFLINETALKMSG
        WHERE RECEIVER=:nRecvID;
        db_ret = sqlca.sqlcode;
        if (conn_error(db_ret))
        {
            iReconnTimes=0;
            bReconn=ConnectDB();
            while(!bReconn)
            {
                iReconnTimes++;
                sleep(iReconnTimes%10);
                bReconn=ConnectDB();
            }
            goto start;
        }

        if( db_ret < 0 )
        {
            sql_error(sqlca, oraca);
            EXEC SQL AT :db_link_name FREE :blob;
            return DB_ERROR;
        }

        if (db_ret == 1403)
            int_tmp = 0;

        if( int_tmp >= OFFLINE_MAX_MSGNUM  && nRecvID != MANAGER_ID)
        {
            EXEC SQL AT :db_link_name DELETE FROM IM_OFFLINETALKMSG WHERE  MSGID=(SELECT Min(MSGID) FROM IM_OFFLINETALKMSG WHERE RECEIVER=:nRecvID);
            db_ret = sqlca.sqlcode;
            if (conn_error(db_ret))
            {
                iReconnTimes=0;
                bReconn=ConnectDB();
                while(!bReconn)
                {
                    iReconnTimes++;
                    sleep(iReconnTimes%10);
                    bReconn=ConnectDB();
                }
                goto start;
            }

            if( db_ret < 0  )
            {
                sql_error(sqlca, oraca);
                EXEC SQL AT :db_link_name FREE :blob;
                EXEC SQL AT :db_link_name ROLLBACK;
                return DB_ERROR;
            }
            EXEC SQL AT :db_link_name COMMIT;
        }

        EXEC SQL AT :db_link_name select nickname into :var_fromname from im_userinfo where userid=:nSendID;
        EXEC SQL AT :db_link_name select nickname into :var_toname from im_userinfo where userid=:nRecvID;
        EXEC SQL AT :db_link_name SELECT IM_OFFLINETALKMSG_SEQ_MSGID.nextval into :int_tmp FROM DUAL;
        /* 如果要用IM服务器时间，则 sendtime=cast(from_tz(to_timestamp ('19700101000000', 'yyyymmddhh24miss')+ numtodsinterval(:nTime, 'second'), 'gmt') at time zone sessiontimezone as date) */
        EXEC SQL AT :db_link_name INSERT INTO IM_OFFLINETALKMSG(MSGID, RECEIVER,SENDER,SRCIP,SRCPORT,SENDTIME,
        MSGTYPE,MSGLEN,MSG,TEXT,SenderName,ReceiverName)
        VALUES(:int_tmp, :nRecvID,:nSendID,:natip,:natport,sysdate,
        :nMsgType,:nMsgLen,empty_blob(),:var_text,:var_fromname,:var_toname);
        db_ret = sqlca.sqlcode;
        if (conn_error(db_ret))
        {
            iReconnTimes=0;
            bReconn=ConnectDB();
            while(!bReconn)
            {
                iReconnTimes++;
                sleep(iReconnTimes%10);
                bReconn=ConnectDB();
            }
            goto start;
        }

        if( db_ret < 0 || db_ret == 1403 )
        {
            sql_error(sqlca, oraca);
            EXEC SQL AT :db_link_name FREE :blob;
            EXEC SQL AT :db_link_name ROLLBACK;
            return DB_ERROR;
        }
        EXEC SQL AT :db_link_name COMMIT;

        EXEC SQL AT :db_link_name SELECT MSG INTO :blob  FROM IM_OFFLINETALKMSG
        WHERE MSGID = :int_tmp FOR UPDATE;
        db_ret = sqlca.sqlcode;
        if (conn_error(db_ret))
        {
            iReconnTimes=0;
            bReconn=ConnectDB();
            while(!bReconn)
            {
                iReconnTimes++;
                sleep(iReconnTimes%10);
                bReconn=ConnectDB();
            }
            goto start;
        }

        if( sqlca.sqlcode < 0 || sqlca.sqlcode == 1403 )
        {
            sql_error(sqlca, oraca);
            EXEC SQL AT :db_link_name FREE :blob;
            EXEC SQL AT :db_link_name ROLLBACK;
            return DB_ERROR;
        }
    }
    else
    {
        EXEC SQL AT :db_link_name SELECT COUNT(MSGID) INTO :int_tmp FROM IM_OFFLINESYSMSG
        WHERE RECEIVER=:nRecvID;
        db_ret = sqlca.sqlcode;
        if (conn_error(db_ret))
        {
            iReconnTimes=0;
            bReconn=ConnectDB();
            while(!bReconn)
            {
                iReconnTimes++;
                sleep(iReconnTimes%10);
                bReconn=ConnectDB();
            }
            goto start;
        }

        if( db_ret < 0 )
        {
            sql_error(sqlca, oraca);
            EXEC SQL AT :db_link_name FREE :blob;
            return DB_ERROR;
        }
        if( int_tmp >= OFFLINE_MAX_MSGNUM )
        {
            EXEC SQL AT :db_link_name DELETE FROM IM_OFFLINESYSMSG WHERE  MSGID=(SELECT Min(MSGID) FROM IM_OFFLINESYSMSG WHERE RECEIVER=:nRecvID);
            db_ret = sqlca.sqlcode;
            if (conn_error(db_ret))
            {
                iReconnTimes=0;
                bReconn=ConnectDB();
                while(!bReconn)
                {
                    iReconnTimes++;
                    sleep(iReconnTimes%10);
                    bReconn=ConnectDB();
                }
                goto start;
            }

            if( db_ret < 0 )
            {
                sql_error(sqlca, oraca);
                EXEC SQL AT :db_link_name FREE :blob;
                EXEC SQL AT :db_link_name ROLLBACK;
                return DB_ERROR;
            }
            EXEC SQL AT :db_link_name COMMIT;
        }

        EXEC SQL AT :db_link_name SELECT IM_OFFLINESYSMSG_SEQ_MSGID.nextval into :int_tmp FROM DUAL;

        EXEC SQL AT :db_link_name INSERT INTO IM_OFFLINESYSMSG(MSGID, RECEIVER,SENDER,SRCIP,SRCPORT,SENDTIME,MSGTYPE,MSGLEN,MSG)
        VALUES(:int_tmp, :nRecvID,:nSendID,:natip,:natport,:nTime,:nMsgType,:nMsgLen,empty_blob());
        db_ret = sqlca.sqlcode;
        if (conn_error(db_ret))
        {
            iReconnTimes=0;
            bReconn=ConnectDB();
            while(!bReconn)
            {
                iReconnTimes++;
                sleep(iReconnTimes%10);
                bReconn=ConnectDB();
            }
            goto start;
        }

        if( db_ret < 0 || db_ret == 1403 )
        {
            sql_error(sqlca, oraca);
            EXEC SQL AT :db_link_name FREE :blob;
            EXEC SQL AT :db_link_name ROLLBACK;
            return DB_ERROR;
        }
        EXEC SQL AT :db_link_name COMMIT;

        EXEC SQL AT :db_link_name SELECT MSG INTO :blob  FROM IM_OFFLINESYSMSG
        WHERE MSGID = :int_tmp FOR UPDATE;
        db_ret = sqlca.sqlcode;
        if (conn_error(db_ret))
        {
            iReconnTimes=0;
            bReconn=ConnectDB();
            while(!bReconn)
            {
                iReconnTimes++;
                sleep(iReconnTimes%10);
                bReconn=ConnectDB();
            }
            goto start;
        }

        if( db_ret < 0 || db_ret == 1403 )
        {
            sql_error(sqlca, oraca);
            EXEC SQL AT :db_link_name FREE :blob;
            EXEC SQL AT :db_link_name ROLLBACK;
            return DB_ERROR;
        }
    }

    lvr = (long_varraw *)malloc(sizeof(ub4) + nMsgLen);
    lvr->len = nMsgLen;
    memcpy(lvr->buf,pmsg,nMsgLen);
    EXEC SQL AT :db_link_name LOB WRITE ONE :nMsgLen
        FROM :lvr WITH LENGTH :nMsgLen INTO :blob AT :offset;
    db_ret = sqlca.sqlcode;
    if (conn_error(db_ret))
    {
        iReconnTimes=0;
        bReconn=ConnectDB();
        while(!bReconn)
        {
            iReconnTimes++;
            sleep(iReconnTimes%10);
            bReconn=ConnectDB();
        }
        goto start;
    }

    if( db_ret < 0 || db_ret == 1403 )
    {
        sql_error(sqlca, oraca);
        EXEC SQL AT :db_link_name FREE :blob;
        EXEC SQL AT :db_link_name ROLLBACK;
        free(lvr);
        return DB_ERROR;
    }
    free(lvr);

    if( nMsgType == CMD_P2PMSG_SEND )
    {
        EXEC SQL AT :db_link_name UPDATE IM_OFFLINETALKMSG SET MSG = :blob
        WHERE MSGID = :int_tmp;
        db_ret = sqlca.sqlcode;
        if (conn_error(db_ret))
        {
            iReconnTimes=0;
            bReconn=ConnectDB();
            while(!bReconn)
            {
                iReconnTimes++;
                sleep(iReconnTimes%10);
                bReconn=ConnectDB();
            }
            goto start;
        }

        if( db_ret < 0 || db_ret == 1403 )
        {
            sql_error(sqlca, oraca);
            EXEC SQL AT :db_link_name FREE :blob;
            EXEC SQL AT :db_link_name ROLLBACK;
            return DB_ERROR;
        }
        EXEC SQL AT :db_link_name COMMIT;
    }
    else
    {
        EXEC SQL AT :db_link_name UPDATE IM_OFFLINESYSMSG SET MSG = :blob
        WHERE MSGID = :int_tmp;
        db_ret = sqlca.sqlcode;
        if (conn_error(db_ret))
        {
            iReconnTimes=0;
            bReconn=ConnectDB();
            while(!bReconn)
            {
                iReconnTimes++;
                sleep(iReconnTimes%10);
                bReconn=ConnectDB();
            }
            goto start;
        }

        if( db_ret < 0 || db_ret == 1403 )
        {
            sql_error(sqlca, oraca);
            EXEC SQL AT :db_link_name FREE :blob;
            EXEC SQL AT :db_link_name ROLLBACK;
            return DB_ERROR;
        }
    }

    EXEC SQL AT :db_link_name COMMIT WORK;
    EXEC SQL AT :db_link_name FREE :blob;
    EXEC SQL AT :db_link_name COMMIT;

    return DB_SUCCESS;
}

/*================================================================
*
* 函 数 名：Delete_Family_Msg
** 删除家族的消息
* 参 数：
const uint32 iFamilyID  [IN] : 删除家族
* 返 回 值：int -   SUCCESS: DB_SUCCESS; 操作失败: DB_ERROR;
*
================================================================*/
int CDatabaseMini::Delete_Family_Msg(const uint32 iFamilyID)
{
    DEF_ORASET;
    EXEC SQL BEGIN DECLARE SECTION;
        unsigned int      nFamilyID;
        VARCHAR db_link_name[32];
        int      retcode;
    EXEC SQL END DECLARE SECTION;

    strncpy((char*)db_link_name.arr, m_Connect,32);
    db_link_name.len = (short)strlen((char*)db_link_name.arr);

    nFamilyID       = iFamilyID;

    int db_ret;
    int iReconnTimes;
    bool bReconn;

    EXEC SQL CONTEXT USE :m_ctx[m_nMyContextid];

start:

    EXEC SQL AT :db_link_name EXECUTE
       begin
        Mini_Local_Pkg.DeleteFamilyMsg(:nFamilyID,:retcode);
    end;
    END-EXEC;

    db_ret = sqlca.sqlcode;
    if (conn_error(db_ret))
    {
        iReconnTimes=0;
        bReconn=ConnectDB();
        while(!bReconn)
        {
            iReconnTimes++;
            sleep(iReconnTimes%10);
            bReconn=ConnectDB();
        }
        goto start;
    }

    if( db_ret < 0 )
    {
        sql_error(sqlca, oraca);
        return DB_ERROR;
    }

    return DB_SUCCESS;

}
int CDatabaseMini::Delete_FamilyMem_RecvMsg(const uint32 iFamilyID, uint32 iUserID)
{
    DEF_ORASET;
    EXEC SQL BEGIN DECLARE SECTION;
        unsigned int      nFamilyID, nUserID;
        VARCHAR db_link_name[32];
        int      retcode;
    EXEC SQL END DECLARE SECTION;

    strncpy((char*)db_link_name.arr, m_Connect,32);
    db_link_name.len = (short)strlen((char*)db_link_name.arr);

    nFamilyID       = iFamilyID;
    nUserID         = iUserID;

    int db_ret;
    int iReconnTimes;
    bool bReconn;

    EXEC SQL CONTEXT USE :m_ctx[m_nMyContextid];

start:

    EXEC SQL AT :db_link_name EXECUTE
       begin
        Mini_Local_Pkg.DeleteFamilyMemRecvMsg(:nFamilyID,:nUserID,:retcode);
    end;
    END-EXEC;

    db_ret = sqlca.sqlcode;
    if (conn_error(db_ret))
    {
        iReconnTimes=0;
        bReconn=ConnectDB();
        while(!bReconn)
        {
            iReconnTimes++;
            sleep(iReconnTimes%10);
            bReconn=ConnectDB();
        }
        goto start;
    }

    if( db_ret < 0 )
    {
        sql_error(sqlca, oraca);
        return DB_ERROR;
    }
    return DB_SUCCESS;
}

/*================================================================
*
* 函 数 名：Save_Family_Msg
** 保存家族请求消息ID获取当前家族最大消息ID
* 参 数：
* uint32 familyMsgID    [IN] : 家族消息ID
* uint32 familyID       [IN] : 家族ID
* uint32 senderID       [IN] : 发送者ID
* uint32 tm             [IN] : 发送时间
* int    msgType        [IN] : 消息类型
* char   *msg           [IN] : 消息内容
* int    msgLen         [IN] : 内容长度
* 返 回 值：int -   SUCCESS: DB_SUCCESS; 数据库错误:DB_ERROR;
*
================================================================*/
int CDatabaseMini::Save_Family_Msg(uint32 familyMsgID,uint32 familyID,uint32 senderID, int tm, int msgType,int msgLen,char *msg)
{
    DEF_ORASET;
    EXEC SQL BEGIN DECLARE SECTION;
        long_varraw * lvr;
        unsigned int    cid,sno;
        int             time,msglen;
        unsigned int int_tmp, cmid, minmsgid;
        unsigned int natip;
        short   natport,msgtype;
        char*   pmsg;
        OCIBlobLocator *blob;
        unsigned int offset = 1;  /* attention: typedef ub4 unsigned int */
        VARCHAR db_link_name[32];
    EXEC SQL END DECLARE SECTION;

    strncpy((char*)db_link_name.arr, m_Connect,32);
    db_link_name.len = (short)strlen((char*)db_link_name.arr);

    int_tmp = 0;

    cmid = familyMsgID;
    cid = familyID;
    sno = senderID;
    natip = 0;
    natport = 0;
    time = tm;
    msglen = msgLen;
    msgtype = msgType;
    pmsg = msg;

    int db_ret;
    int iReconnTimes;
    bool bReconn;

    EXEC SQL CONTEXT USE :m_ctx[m_nMyContextid];

start:

    EXEC SQL AT :db_link_name ALLOCATE :blob;
    EXEC SQL AT :db_link_name SELECT COUNT(MSGID) INTO :int_tmp FROM IM_CLUSTERTALKMSG
       WHERE CLUSTERID=:cid;
    db_ret = sqlca.sqlcode;
    if (conn_error(db_ret))
    {
        iReconnTimes=0;
        bReconn=ConnectDB();
        while(!bReconn)
        {
            iReconnTimes++;
            sleep(iReconnTimes%10);
            bReconn=ConnectDB();
        }
        goto start;
    }

    if( sqlca.sqlcode < 0 )
    {
        sql_error(sqlca, oraca);
        EXEC SQL AT :db_link_name FREE :blob;
        return DB_ERROR;
    }

    bool isupdate = false;
    if( int_tmp >= FAMILE_MAX_MSGNUM )
    {
        EXEC SQL AT :db_link_name SELECT MIN(MSGID) INTO :minmsgid FROM IM_CLUSTERTALKMSG
        WHERE CLUSTERID=:cid;
        db_ret = sqlca.sqlcode;
        if (db_ret < 0)
        {
            EXEC SQL AT :db_link_name FREE :blob;
            return DB_ERROR;
        }
        isupdate = true;
    }

    EXEC SQL AT :db_link_name SELECT MAX(MSGID) INTO :int_tmp FROM IM_CLUSTERTALKMSG
       WHERE CLUSTERID=:cid;
    db_ret = sqlca.sqlcode;
    if ((db_ret < 0 && db_ret != -1405) || db_ret == 1403)
    {
        EXEC SQL AT :db_link_name FREE :blob;
        return DB_ERROR;
    }
    if (db_ret == -1405)
        int_tmp = 1;

    if (isupdate == false)
    {
        EXEC SQL AT :db_link_name INSERT INTO IM_CLUSTERTALKMSG(MSGID,CLUSTERID,SENDER,SRCIP,SRCPORT,SENDTIME,MSGTYPE,MSGLEN,MSG)
        VALUES(:cmid,:cid,:sno,:natip,:natport,:time,:msgtype,:msglen,empty_blob());
        db_ret = sqlca.sqlcode;
        if (conn_error(db_ret))
        {
            iReconnTimes=0;
            bReconn=ConnectDB();
            while(!bReconn)
            {
                iReconnTimes++;
                sleep(iReconnTimes%10);
                bReconn=ConnectDB();
            }
            goto start;
        }

        if( sqlca.sqlcode < 0 || sqlca.sqlcode == 1403 )
        {
            sql_error(sqlca, oraca);
            EXEC SQL AT :db_link_name ROLLBACK;
            EXEC SQL AT :db_link_name FREE :blob;
            return DB_ERROR;
        }
        EXEC SQL AT :db_link_name COMMIT;
    }
    else
    {
        EXEC SQL AT :db_link_name UPDATE IM_CLUSTERTALKMSG
          SET MSGID=:cmid,SENDER=:sno,SRCIP=:natip,SRCPORT=:natport,SENDTIME=:time,MSGTYPE=:msgtype,MSGLEN=:msglen,MSG=empty_blob()
          where MSGID = :minmsgid and CLUSTERID = :cid;
        db_ret = sqlca.sqlcode;
        if (conn_error(db_ret))
        {
            iReconnTimes=0;
            bReconn=ConnectDB();
            while(!bReconn)
            {
                iReconnTimes++;
                sleep(iReconnTimes%10);
                bReconn=ConnectDB();
            }
            goto start;
        }

        if( sqlca.sqlcode < 0 || sqlca.sqlcode == 1403 )
        {
            sql_error(sqlca, oraca);
            EXEC SQL AT :db_link_name ROLLBACK;
            EXEC SQL AT :db_link_name FREE :blob;
            return DB_ERROR;
        }
        EXEC SQL AT :db_link_name COMMIT;

    }

    EXEC SQL AT :db_link_name SELECT MSG INTO :blob  FROM IM_CLUSTERTALKMSG
       WHERE MSGID=:cmid AND CLUSTERID=:cid FOR UPDATE;
    db_ret = sqlca.sqlcode;
    if (conn_error(db_ret))
    {
        iReconnTimes=0;
        bReconn=ConnectDB();
        while(!bReconn)
        {
            iReconnTimes++;
            sleep(iReconnTimes%10);
            bReconn=ConnectDB();
        }
        goto start;
    }

    if( sqlca.sqlcode < 0 || sqlca.sqlcode == 1403 )
    {
        sql_error(sqlca, oraca);
        EXEC SQL AT :db_link_name ROLLBACK;
        EXEC SQL AT :db_link_name FREE :blob;
        if( db_ret == -2112)
        {
            EXEC SQL AT :db_link_name ROLLBACK;
            EXEC SQL AT :db_link_name delete IM_CLUSTERTALKMSG t where rowid > (
            select min(rowid) from IM_CLUSTERTALKMSG y where t.MSGID=y.msgid and t.CLUSTERID=y.clusterid );
            EXEC SQL AT :db_link_name SELECT MSG INTO :blob  FROM IM_CLUSTERTALKMSG
            WHERE MSGID=:cmid AND CLUSTERID=:cid FOR UPDATE;
        }
        else
            return DB_ERROR;
    }

    lvr = (long_varraw *)malloc(sizeof(ub4) + msglen);
    lvr->len = msglen;
    memcpy(lvr->buf,pmsg,msglen);
    EXEC SQL AT :db_link_name LOB WRITE ONE :msglen
        FROM :lvr WITH LENGTH :msglen INTO :blob AT :offset;
    db_ret = sqlca.sqlcode;
    if (conn_error(db_ret))
    {
        iReconnTimes=0;
        bReconn=ConnectDB();
        while(!bReconn)
        {
            iReconnTimes++;
            sleep(iReconnTimes%10);
            bReconn=ConnectDB();
        }
        goto start;
    }

    if( sqlca.sqlcode < 0 || sqlca.sqlcode == 1403 )
    {
        sql_error(sqlca, oraca);
        EXEC SQL AT :db_link_name ROLLBACK;
        EXEC SQL AT :db_link_name FREE :blob;
        free(lvr);
        return DB_ERROR;
    }

    free(lvr);

    EXEC SQL AT :db_link_name UPDATE IM_CLUSTERTALKMSG SET MSG = :blob
       WHERE MSGID=:cmid AND CLUSTERID=:cid;
    db_ret = sqlca.sqlcode;
    if (conn_error(db_ret))
    {
        iReconnTimes=0;
        bReconn=ConnectDB();
        while(!bReconn)
        {
            iReconnTimes++;
            sleep(iReconnTimes%10);
            bReconn=ConnectDB();
        }
        goto start;
    }

    if( sqlca.sqlcode < 0 || sqlca.sqlcode == 1403 )
    {
        sql_error(sqlca, oraca);
        EXEC SQL AT :db_link_name ROLLBACK;
        EXEC SQL AT :db_link_name FREE :blob;
        return DB_ERROR;
    }

    EXEC SQL AT :db_link_name COMMIT WORK;
    EXEC SQL AT :db_link_name FREE :blob;
    EXEC SQL AT :db_link_name COMMIT;

    return DB_SUCCESS;
}

int CDatabaseMini::Get_User_OnlineTime(uint32 iUserID,uint32 &OnlineTime)
{
    DEF_ORASET;
    EXEC SQL BEGIN DECLARE SECTION;
        unsigned int    nUserID;
        double          timelen;
        VARCHAR db_link_name[32];
        int      retcode;
    EXEC SQL END DECLARE SECTION;

    strncpy((char*)db_link_name.arr, m_Connect,32);
    db_link_name.len = (short)strlen((char*)db_link_name.arr);
    nUserID = iUserID;
    timelen = 0;
    int db_ret;
    int iReconnTimes;
    bool bReconn;

    EXEC SQL CONTEXT USE :m_ctx[m_nMyContextid];

start:

    EXEC SQL AT :db_link_name EXECUTE
       begin
        Mini_Local_Pkg.GetUserOnlineTime(:nUserID,:timelen,:retcode);
    end;
    END-EXEC;

    db_ret = sqlca.sqlcode;
    if (conn_error(db_ret))
    {
        iReconnTimes=0;
        bReconn=ConnectDB();
        while(!bReconn)
        {
            iReconnTimes++;
            sleep(iReconnTimes%10);
            bReconn=ConnectDB();
        }
        goto start;
    }

    if ((db_ret < 0  && db_ret != -1405)) //出错
    {
        sql_error(sqlca, oraca);
        return DB_ERROR;
    }

    OnlineTime = (uint32)timelen;
    return DB_SUCCESS;
}

/*================================================================
*
* 函 数 名：Add_Group
** 添加分组
* 参 数：
* uint32 iUserID [[IN]] : 用户ID
* uint8 &iGroupID [IN,OUT]: 组ID，输入指定的ID。输出数据库中存储的ID
* char * strGroupName   [IN] : 组名
* 返 回 值：int -   SUCCESS: DB_SUCCESS; 数据库错误:DB_ERROR;  用所能创建的组已满：DB_GROUP_FULL; 组名已经存在:DB_GROUP_EXIST;
*
================================================================*/
int CDatabaseMini::Add_Group(uint32 iUserID, uint8 &iGroupID, char * strGroupName, uint8 &iGroupPid)
{
    DEF_ORASET;
    EXEC SQL BEGIN DECLARE SECTION;
        VARCHAR var_groupname[21];
        unsigned int nUserID;
        int     g_id;
        int     g_pid;
        int     retcode;
        VARCHAR db_link_name[32];
    EXEC SQL END DECLARE SECTION;

    SET_INIT_NULL(var_groupname);
    nUserID = iUserID;
    g_id = iGroupID;
    g_pid = iGroupPid;

    strncpy((char*)db_link_name.arr, m_Connect,32);
    db_link_name.len = (short)strlen((char*)db_link_name.arr);

    if( strlen(strGroupName) > 20 )
        return DB_PARAM;

    strncpy((char*)var_groupname.arr, strGroupName,MAX_GROUPNAME_LEN);
    var_groupname.len = (unsigned short)strlen(strGroupName);

    int db_ret;
    int iReconnTimes;
    bool bReconn;

    EXEC SQL CONTEXT USE :m_ctx[m_nMyContextid];

start:

    EXEC SQL AT :db_link_name EXECUTE
    begin
       Mini_Local_Pkg.AddGroup(:nUserID,:g_id,:var_groupname,:g_pid,:retcode);
    end;
    END-EXEC;

    db_ret = sqlca.sqlcode;
    if (conn_error(db_ret))
    {
        iReconnTimes=0;
        bReconn=ConnectDB();
        while(!bReconn)
        {
            iReconnTimes++;
            sleep(iReconnTimes%10);
            bReconn=ConnectDB();
        }
        goto start;
    }

    if ( db_ret < 0)
    {
        sql_error(sqlca, oraca);
        return DB_ERROR;
    }

    if( retcode == DB_GROUP_FULL )
        return DB_GROUP_FULL;

    if( retcode == DB_GROUP_EXIST )
        return DB_GROUP_EXIST;

    return DB_SUCCESS;
}

int CDatabaseMini::Mod_Cust_Info(uint32 id, char* account, char* time)
{
    DEF_ORASET;
    EXEC SQL BEGIN DECLARE SECTION;
        VARCHAR var_account[40];
        VARCHAR var_time[32];
        VARCHAR db_link_name[32];
        unsigned int nID;
        int retcode;
    EXEC SQL END DECLARE SECTION;

    SET_INIT_NULL(var_account);
    SET_INIT_NULL(var_time);
    nID = id;

    var_account.len = (unsigned short)strlen(account);
    strncpy((char*)var_account.arr,account,MAX_CUST_ACCOUNT_LEN);

    var_time.len = (unsigned short)strlen(time);
    strncpy((char*)var_time.arr,time,MAX_CUST_TIME_LEN);

    strncpy((char*)db_link_name.arr, m_Connect,32);
    db_link_name.len = (short)strlen((char*)db_link_name.arr);

    int db_ret;
    int iReconnTimes;
    bool bReconn;

    EXEC SQL CONTEXT USE :m_ctx[m_nMyContextid];

start:

    EXEC SQL AT :db_link_name EXECUTE
       begin
        Mini_Local_Pkg.ModifyCustInfo(:nID,:var_account,:var_time,:retcode);
    end;
    END-EXEC;
    db_ret = sqlca.sqlcode;
    if (conn_error(db_ret))
    {
        iReconnTimes=0;
        bReconn=ConnectDB();
        while(!bReconn)
        {
            iReconnTimes++;
            sleep(iReconnTimes%10);
            bReconn=ConnectDB();
        }
        goto start;
    }

    if(db_ret == 1403 || db_ret < 0)
    {
        sql_error(sqlca, oraca);
        return DB_ERROR;
    }
    if (retcode == 1)
        return DB_ERROR;

    return DB_SUCCESS;
}


int CDatabaseMini::Mod_Cust_Remark(uint32 id, char* account, char* time,char* remark)
{
    DEF_ORASET;
    EXEC SQL BEGIN DECLARE SECTION;
        VARCHAR var_account[40];
        VARCHAR var_time[32];
        VARCHAR var_remark[201];
        VARCHAR db_link_name[32];
        unsigned int nID;
        int retcode;
    EXEC SQL END DECLARE SECTION;

    SET_INIT_NULL(var_account);
    SET_INIT_NULL(var_time);
    SET_INIT_NULL(var_remark);

    nID = id;

    var_account.len = (unsigned short)strlen(account);
    strncpy((char*)var_account.arr,account,MAX_CUST_ACCOUNT_LEN);

    var_time.len = (unsigned short)strlen(time);
    strncpy((char*)var_time.arr,time,MAX_CUST_TIME_LEN);

    var_remark.len = (unsigned short)strlen(remark);
    strncpy((char*)var_remark.arr,remark,MAX_CUST_REMAKE_LEN);

    strncpy((char*)db_link_name.arr, m_Connect,32);
    db_link_name.len = (short)strlen((char*)db_link_name.arr);

    int db_ret;
    int iReconnTimes;
    bool bReconn;

    EXEC SQL CONTEXT USE :m_ctx[m_nMyContextid];

start:

    EXEC SQL AT :db_link_name EXECUTE
       begin
        Mini_Local_Pkg.ModifyCustRemark(:nID,:var_account,:var_time,:var_remark,:retcode);
    end;
    END-EXEC;
    db_ret = sqlca.sqlcode;
    if (conn_error(db_ret))
    {
        iReconnTimes=0;
        bReconn=ConnectDB();
        while(!bReconn)
        {
            iReconnTimes++;
            sleep(iReconnTimes%10);
            bReconn=ConnectDB();
        }
        goto start;
    }
    CLog::Log("CBusinessModCustRemark", CLog::TYPE_DEBUG, "id:%d, db_ret:%d, retcode:%d", id, db_ret, retcode);

    if(db_ret == 1403 || db_ret < 0)
    {
        sql_error(sqlca, oraca);
        return DB_ERROR;
    }

    if (retcode == 1)
        return DB_ERROR;

    return DB_SUCCESS;
}




int CDatabaseMini::Get_Cust_Remark(uint32 id, char* account, char* time, char* remark)
{
    DEF_ORASET;
    EXEC SQL BEGIN DECLARE SECTION;
        VARCHAR db_link_name[32];
        VARCHAR var_account[40];
        VARCHAR var_time[32];
        VARCHAR var_remark[201];
        unsigned int nID;
        int retcode;
    EXEC SQL END DECLARE SECTION;

    strncpy((char*)db_link_name.arr, m_Connect,32);
    db_link_name.len = (short)strlen((char*)db_link_name.arr);

    strncpy((char*)var_account.arr, account,MAX_CUST_ACCOUNT_LEN);
    var_account.len = (short)strlen(account);

    nID=id;

    SET_INIT_NULL(var_time);
    SET_INIT_NULL(var_remark);

    int db_ret, iReconnTimes;
    bool bReconn;

    EXEC SQL CONTEXT USE :m_ctx[m_nMyContextid];

start:
    EXEC SQL AT :db_link_name EXECUTE
       begin
        Mini_Local_Pkg.GetCustRemark(:nID,:var_account,:var_time,:var_remark,:retcode);
    end;
    END-EXEC;


    db_ret = sqlca.sqlcode;
    if (conn_error(db_ret))
    {
        iReconnTimes=0;
        bReconn=ConnectDB();
        while(!bReconn)
        {
            iReconnTimes++;
            sleep(iReconnTimes%10);
            bReconn=ConnectDB();
        }
        goto start;
    }
    CLog::Log("CDatabaseMini::Get_Cust_Remark", CLog::TYPE_DEBUG, "id:%d, db_ret:%d, retcode:%d",id, db_ret, retcode);

    if( db_ret < 0 && db_ret != -1405)
    {
        sql_error(sqlca, oraca);
        return DB_ERROR;
    }

    if (retcode == 1)
    {
        return DB_ERROR;
    }

    strncpy(time,(char*)var_time.arr,31);
    strncpy(remark,(char*)var_remark.arr,MAX_CUST_REMAKE_LEN-1);

    return DB_SUCCESS;
}




int CDatabaseMini::Get_Cust_Num(uint32 id, char* btime, char* etime, uint32& nRetCount)
{
    DEF_ORASET;
    EXEC SQL BEGIN DECLARE SECTION;
        VARCHAR db_link_name[32];
        VARCHAR var_btime[32];
        VARCHAR var_etime[32];
        unsigned int nID, nCount;
        int retcode;
    EXEC SQL END DECLARE SECTION;

    strncpy((char*)db_link_name.arr, m_Connect,32);
    db_link_name.len = (short)strlen((char*)db_link_name.arr);

    strncpy((char*)var_btime.arr, btime,32);
    var_btime.len = (short)strlen(btime);

    strncpy((char*)var_etime.arr, etime,32);
    var_etime.len = (short)strlen(etime);

    nID=id;
    nCount=nRetCount;

    int db_ret, iReconnTimes;
    bool bReconn;

    EXEC SQL CONTEXT USE :m_ctx[m_nMyContextid];

start:

    EXEC SQL AT :db_link_name EXECUTE
       begin
        Mini_Local_Pkg.GetCustNum(:nID,:var_btime,:var_etime,:nCount,:retcode);
    end;
    END-EXEC;
    db_ret = sqlca.sqlcode;
    if (conn_error(db_ret))
    {
        iReconnTimes=0;
        bReconn=ConnectDB();
        while(!bReconn)
        {
            iReconnTimes++;
            sleep(iReconnTimes%10);
            bReconn=ConnectDB();
        }
        goto start;
    }

    if(db_ret == 1403 || db_ret < 0)
    {
        sql_error(sqlca, oraca);
        return DB_ERROR;
    }

    if (retcode == 1)
        return DB_ERROR;

    nRetCount=nCount;
    return DB_SUCCESS;
}

int CDatabaseMini::Get_Cust_Info(uint32 id, char* btime, char* etime, uint32 count, uint16 start_pos, uint16 iNeedCustCount, uint8 bDirect, XT_GET_NEAR_COMM_CUST_ACK::TagCommInfo* CliInfo, uint32& nRetCount)
{
    DEF_ORASET;
    EXEC SQL BEGIN DECLARE SECTION;
        VARCHAR db_link_name[32],var_btime[32],var_etime[32],var_account[40],var_conntime[32],var_orderid[64],var_comment[128];
        unsigned int nID,nMaxCount,nPos,nCount,nDirect;
        int retcode;
        SQL_CURSOR cur_cliInfo;
    EXEC SQL END DECLARE SECTION;

    strncpy((char*)db_link_name.arr, m_Connect,32);
    db_link_name.len = (short)strlen(m_Connect);

    strncpy((char*)var_btime.arr, btime,32);
    var_btime.len = (short)strlen(btime);

    strncpy((char*)var_etime.arr, etime,32);
    var_etime.len = (short)strlen(etime);

    nID=id;
    nMaxCount=count;
    nPos=start_pos;
    nCount=iNeedCustCount;
    nDirect=bDirect;
    SET_INIT_NULL(var_account);
    SET_INIT_NULL(var_conntime);
    SET_INIT_NULL(var_orderid);
    SET_INIT_NULL(var_comment);

    int db_ret, iReconnTimes;
    uint32 iNum = 0;
    bool bReconn;

    EXEC SQL CONTEXT USE :m_ctx[m_nMyContextid];

start:
    EXEC SQL ALLOCATE :cur_cliInfo;
    EXEC SQL AT :db_link_name EXECUTE
    begin
      Mini_Local_Pkg.GetCustInfo(:nID,:var_btime,:var_etime,:nMaxCount,:nPos,:nCount,:nDirect,:cur_cliInfo,:retcode);
    end;
    END-EXEC;

    db_ret = sqlca.sqlcode;
    if (conn_error(db_ret))
    {
        EXEC SQL CLOSE :cur_cliInfo;
        iReconnTimes=0;
        bReconn=ConnectDB();
        while(!bReconn)
        {
            iReconnTimes++;
            sleep(iReconnTimes%10);
            bReconn=ConnectDB();
        }
        goto start;
    }
    CLog::Log("Get_Cust_Info",CLog::TYPE_DEBUG,"id:%d, db_ret:%d, retcode:%d ",id, db_ret, retcode);

    if(db_ret < 0 && db_ret != -1405)
    {
        sql_error(sqlca, oraca);
        EXEC SQL CLOSE :cur_cliInfo;
        EXEC SQL FREE  :cur_cliInfo;
        return DB_ERROR;
    }

    for(;;)
    {
        EXEC SQL FETCH :cur_cliInfo INTO :var_account,:var_conntime,:var_orderid,:var_comment;
        db_ret = sqlca.sqlcode;
        if (db_ret == 1403 )
        {
            nRetCount = iNum;
            break;
        }
        if (iNum >= nRetCount)
        {
            break;
        }
        if( db_ret < 0 && db_ret != -1405 )
        {
            sql_error(sqlca, oraca);
            nRetCount = iNum;
            break;
        }
        SET_END_NULL(var_account);
        SET_END_NULL(var_conntime);
        SET_END_NULL(var_orderid);
        SET_END_NULL(var_comment);

        strncpy(CliInfo[iNum].szCommAccount,(char*)var_account.arr,MAX_CUST_ACCOUNT_LEN);
        strncpy(CliInfo[iNum].szCommTime,(char*)var_conntime.arr,MAX_CUST_TIME_LEN);
        strncpy(CliInfo[iNum].szTransInfo,(char*)var_orderid.arr,MAX_CUST_ORDER_LEN);
        strncpy(CliInfo[iNum].szRemarks,(char*)var_comment.arr,MAX_CUST_REMAKE_LEN);

        ++iNum;
    }
    EXEC SQL CLOSE :cur_cliInfo;
    EXEC SQL FREE  :cur_cliInfo;
    return DB_SUCCESS;
}

int CDatabaseMini::Modify_Group(uint32 iUserID, uint8 iGroupID, char *strGroupName)
{
    DEF_ORASET;
    EXEC SQL BEGIN DECLARE SECTION;
        VARCHAR var_groupname[21];
        VARCHAR db_link_name[32];
        unsigned int     nUserID;
        int     g_id;
        int      retcode;
    EXEC SQL END DECLARE SECTION;
    SET_INIT_NULL(var_groupname);
    nUserID = iUserID;
    g_id = iGroupID;
    if( strlen(strGroupName) > 20 )
        return DB_PARAM;
    var_groupname.len = (unsigned short)strlen(strGroupName);
    strncpy((char*)var_groupname.arr,strGroupName,MAX_GROUPNAME_LEN);

    strncpy((char*)db_link_name.arr, m_Connect,32);
    db_link_name.len = (short)strlen((char*)db_link_name.arr);
    int db_ret;
    int iReconnTimes;
    bool bReconn;

    EXEC SQL CONTEXT USE :m_ctx[m_nMyContextid];

start:

    EXEC SQL AT :db_link_name EXECUTE
       begin
        Mini_Local_Pkg.ModifyGroup(:nUserID,:g_id,:var_groupname,:retcode);
    end;
    END-EXEC;
    db_ret = sqlca.sqlcode;
    if (conn_error(db_ret))
    {
        iReconnTimes=0;
        bReconn=ConnectDB();
        while(!bReconn)
        {
            iReconnTimes++;
            sleep(iReconnTimes%10);
            bReconn=ConnectDB();
        }
        goto start;
    }

    if(db_ret == 1403 || db_ret < 0)
    {
        sql_error(sqlca, oraca);
        return DB_ERROR;
    }

    if (retcode == DB_GROUP_EXIST)
        return DB_GROUP_EXIST;

    return DB_SUCCESS;
}

int CDatabaseMini::Delete_Group(uint32 iUserID, uint8 iGroupID)
{
    DEF_ORASET;
    EXEC SQL BEGIN DECLARE SECTION;
        unsigned int     nUserID;
        int g_id;
        int      retcode;
        VARCHAR db_link_name[32];
    EXEC SQL END DECLARE SECTION;

    nUserID = iUserID;
    g_id = iGroupID;

    strncpy((char*)db_link_name.arr, m_Connect,32);
    db_link_name.len = (short)strlen((char*)db_link_name.arr);

    int db_ret;
    int iReconnTimes;
    bool bReconn;

    EXEC SQL CONTEXT USE :m_ctx[m_nMyContextid];

start:

    EXEC SQL AT :db_link_name EXECUTE
       begin
        Mini_Local_Pkg.DeleteGroup(:nUserID,:g_id,:retcode);
    end;
    END-EXEC;

    db_ret = sqlca.sqlcode;
    if (conn_error(db_ret))
    {
        iReconnTimes=0;
        bReconn=ConnectDB();
        while(!bReconn)
        {
            iReconnTimes++;
            sleep(iReconnTimes%10);
            bReconn=ConnectDB();
        }
        goto start;
    }

    if(db_ret < 0)
    {
        sql_error(sqlca, oraca);
        return DB_ERROR;
    }
    return DB_SUCCESS;
}

int CDatabaseMini::Save_User_Login(uint32 userid,uint32 userip, uint16 userport, int serverno)
{
    DEF_ORASET;
    EXEC SQL BEGIN DECLARE SECTION;
        unsigned int clientno;
        unsigned int clientip;
        int thissrvno;
        short clientport;
        int      retcode;
        VARCHAR nowdate[24];
        VARCHAR db_link_name[32];
    EXEC SQL END DECLARE SECTION;

    strncpy((char*)db_link_name.arr, m_Connect,32);
    db_link_name.len = (short)strlen((char*)db_link_name.arr);
    SET_INIT_NULL(nowdate);

    if (userid ==0)
        return DB_PARAM;
    clientno = userid;
    clientip = userip;
    thissrvno = serverno;
    char strTime[20];
    time_t ntm;
    time(&ntm);
    struct tm *newtime;
    newtime = localtime(&ntm);
    sprintf(strTime, "%d-%d-%d", newtime->tm_year + 1900, newtime->tm_mon + 1, newtime->tm_mday);
    strncpy((char*)nowdate.arr, strTime,19);
    nowdate.len = (short)strlen((char*)nowdate.arr);
    int db_ret;
    int iReconnTimes;
    bool bReconn;

    EXEC SQL CONTEXT USE :m_ctx[m_nMyContextid];

start:

    EXEC SQL AT :db_link_name EXECUTE
       begin
        Mini_Local_Pkg.SaveUserLogin(:clientno,:clientip,:clientport,:thissrvno,:retcode);
    end;
    END-EXEC;

    db_ret = sqlca.sqlcode;
    if (conn_error(db_ret))
    {
        iReconnTimes=0;
        bReconn=ConnectDB();
        while(!bReconn)
        {
            iReconnTimes++;
            sleep(iReconnTimes%10);
            bReconn=ConnectDB();
        }
        goto start;
    }

    if( db_ret < 0 )
    {
        sql_error(sqlca, oraca);
        return DB_ERROR;
    }


    return DB_SUCCESS;
}

int CDatabaseMini::Save_User_Logout(uint32 userid)
{
    DEF_ORASET;
    EXEC SQL BEGIN DECLARE SECTION;
        unsigned int clientno;
        int      retcode;
        VARCHAR db_link_name[32];
    EXEC SQL END DECLARE SECTION;

    strncpy((char*)db_link_name.arr, m_Connect,32);
    db_link_name.len = (short)strlen((char*)db_link_name.arr);

    if (userid ==0)
        return DB_PARAM;
    clientno = userid;
    int db_ret;
    int iReconnTimes;
    bool bReconn;

    EXEC SQL CONTEXT USE :m_ctx[m_nMyContextid];

start:

    EXEC SQL AT :db_link_name EXECUTE
       begin
        Mini_Local_Pkg.SaveUserLogout(:clientno,:retcode);
    end;
    END-EXEC;

    db_ret = sqlca.sqlcode;
    if (conn_error(db_ret))
    {
        iReconnTimes=0;
        bReconn=ConnectDB();
        while(!bReconn)
        {
            iReconnTimes++;
            sleep(iReconnTimes%10);
            bReconn=ConnectDB();
        }
        goto start;
    }

    if( db_ret < 0 )
    {
        sql_error(sqlca, oraca);
        return DB_ERROR;
    }

    return DB_SUCCESS;
}

int CDatabaseMini::Update_All_Logout(int serverno)
{
    DEF_ORASET;
    EXEC SQL BEGIN DECLARE SECTION;
        int v_serverno;
        int retcode;
        VARCHAR db_link_name[32];
    EXEC SQL END DECLARE SECTION;

    SET_INIT_NULL(db_link_name);
    strncpy((char*)db_link_name.arr, m_Connect,32);
    db_link_name.len = (short)strlen((char*)db_link_name.arr);

    v_serverno = serverno;
    int db_ret;
    int iReconnTimes;
    bool bReconn;

    EXEC SQL CONTEXT USE :m_ctx[m_nMyContextid];

start:

    EXEC SQL AT :db_link_name EXECUTE
       begin
        Mini_Local_Pkg.UpdateAllLogout(:v_serverno,:retcode);
    end;
    END-EXEC;

    db_ret = sqlca.sqlcode;
    if (conn_error(db_ret))
    {
        iReconnTimes=0;
        bReconn=ConnectDB();
        while(!bReconn)
        {
            iReconnTimes++;
            sleep(iReconnTimes%10);
            bReconn=ConnectDB();
        }
        goto start;
    }

    if( db_ret < 0 )
    {
        sql_error(sqlca, oraca);
        return DB_ERROR;
    }

    return DB_SUCCESS;
}

int CDatabaseMini::Save_User_Action(uint32 userid,XT_USER_ACTION_AUDIT_REQ::Action *action,uint16 count)
{
    DEF_ORASET;
    EXEC SQL BEGIN DECLARE SECTION;
        unsigned int clientno,actionno;
        int actioncount;
        int      retcode;
        VARCHAR db_link_name[32];
    EXEC SQL END DECLARE SECTION;

    strncpy((char*)db_link_name.arr, m_Connect,32);
    db_link_name.len = (short)strlen((char*)db_link_name.arr);

    if (userid <=0)
        return 1;

    clientno = userid;

    int db_ret;
    int iReconnTimes;
    bool bReconn;

    EXEC SQL CONTEXT USE :m_ctx[m_nMyContextid];

start:

    for(int i = 0; i < count; ++i)
    {
        actionno = action[i].OpeId;
        actioncount = action[i].count;

        EXEC SQL AT :db_link_name EXECUTE
        begin
          Mini_Local_Pkg.SaveUserAction(:clientno,:actionno,:actioncount,:retcode);
        end;
        END-EXEC;
        db_ret = sqlca.sqlcode;
        if (conn_error(db_ret))
        {
            iReconnTimes=0;
            bReconn=ConnectDB();
            while(!bReconn)
            {
                iReconnTimes++;
                sleep(iReconnTimes%10);
                bReconn=ConnectDB();
            }
            goto start;
        }

        if( db_ret < 0 )
        {
            sql_error(sqlca, oraca);
            continue;
        }
    }

    return DB_SUCCESS;
}

int CDatabaseMini::Save_User_Timelen(uint32 userid, int logintm, int logouttm)
{
    DEF_ORASET;
    EXEC SQL BEGIN DECLARE SECTION;
        unsigned int        clientno,onlinetm;
        int      retcode;
        VARCHAR db_link_name[32];
    EXEC SQL END DECLARE SECTION;

    strncpy((char*)db_link_name.arr, m_Connect,32);
    db_link_name.len = (short)strlen((char*)db_link_name.arr);

    clientno = userid;

    CTime intm(logintm);
    CTime outtm(logouttm);

    onlinetm = 0;

    if ( intm.GetDay() == outtm.GetDay())
    {
        onlinetm = (unsigned int)(logouttm - logintm)/60;   //按分钟记时
    }
    else
    {
        onlinetm = outtm.GetHour() * 60 + outtm.GetMinute();
        onlinetm = onlinetm + (24*60-intm.GetHour()*60-intm.GetMinute());
    }
    if(onlinetm ==0)
        return DB_SUCCESS;

    int db_ret;
    int iReconnTimes;
    bool bReconn;

    EXEC SQL CONTEXT USE :m_ctx[m_nMyContextid];

start:

    EXEC SQL AT :db_link_name EXECUTE
       begin
        Mini_Local_Pkg.SaveUserTimelen(:clientno,:onlinetm,:retcode);
    end;
    END-EXEC;
    db_ret = sqlca.sqlcode;
    if (conn_error(db_ret))
    {
        iReconnTimes=0;
        bReconn=ConnectDB();
        while(!bReconn)
        {
            iReconnTimes++;
            sleep(iReconnTimes%10);
            bReconn=ConnectDB();
        }
        goto start;
    }

    if (db_ret < 0 && db_ret != -1405) //出错
    {
        sql_error(sqlca, oraca);
        return DB_ERROR;
    }

    return DB_SUCCESS;
}

int CDatabaseMini::Save_Merchant_Login(uint32 userid,int logintm)
{
    DEF_ORASET;
    EXEC SQL BEGIN DECLARE SECTION;
        unsigned int merchantid,thisintm;
        int      retcode;
        VARCHAR db_link_name[32];
    EXEC SQL END DECLARE SECTION;

    strncpy((char*)db_link_name.arr, m_Connect,32);
    db_link_name.len = (short)strlen((char*)db_link_name.arr);

    merchantid = userid;
    thisintm = logintm;
    if (userid ==0)
        return DB_PARAM;
    int db_ret;
    int iReconnTimes;
    bool bReconn;

    EXEC SQL CONTEXT USE :m_ctx[m_nMyContextid];

start:

    EXEC SQL AT :db_link_name EXECUTE
       begin
        Mini_Local_Pkg.SaveMerchantLogin(:merchantid,:thisintm,:retcode);
    end;
    END-EXEC;

    db_ret = sqlca.sqlcode;
    if (conn_error(db_ret))
    {
        iReconnTimes=0;
        bReconn=ConnectDB();
        while(!bReconn)
        {
            iReconnTimes++;
            sleep(iReconnTimes%10);
            bReconn=ConnectDB();
        }
        goto start;
    }

    if( db_ret < 0 )
    {
        sql_error(sqlca, oraca);
        return DB_ERROR;
    }
    EXEC SQL AT :db_link_name COMMIT;
    return DB_SUCCESS;
}



int CDatabaseMini::Save_Merchant_Logout(uint32 userid,int logouttm)
{
    DEF_ORASET;
    EXEC SQL BEGIN DECLARE SECTION;
        unsigned int merchantid,thisouttm;
        int      retcode;
        VARCHAR db_link_name[32];
    EXEC SQL END DECLARE SECTION;

    strncpy((char*)db_link_name.arr, m_Connect,32);
    db_link_name.len = (short)strlen((char*)db_link_name.arr);

    merchantid = userid;
    thisouttm = logouttm;
    if (userid ==0)
        return DB_PARAM;
    int db_ret;
    int iReconnTimes;
    bool bReconn;

    EXEC SQL CONTEXT USE :m_ctx[m_nMyContextid];

start:

    EXEC SQL AT :db_link_name EXECUTE
       begin
        Mini_Local_Pkg.SaveMerchantLogout(:merchantid,:thisouttm,:retcode);
    end;
    END-EXEC;

    db_ret = sqlca.sqlcode;
    if (conn_error(db_ret))
    {
        iReconnTimes=0;
        bReconn=ConnectDB();
        while(!bReconn)
        {
            iReconnTimes++;
            sleep(iReconnTimes%10);
            bReconn=ConnectDB();
        }
        goto start;
    }
    if( db_ret < 0 )
    {
        sql_error(sqlca, oraca);
        return DB_ERROR;
    }
    EXEC SQL AT :db_link_name COMMIT;
    return DB_SUCCESS;
}

int CDatabaseMini::Save_Buyer_Login(uint32 userid,int logintm)
{
    DEF_ORASET;
    EXEC SQL BEGIN DECLARE SECTION;
        unsigned int merchantid,thisintm;
        int      retcode;
        VARCHAR db_link_name[32];
    EXEC SQL END DECLARE SECTION;

    strncpy((char*)db_link_name.arr, m_Connect,32);
    db_link_name.len = (short)strlen((char*)db_link_name.arr);

    merchantid = userid;
    thisintm = logintm;
    if (userid ==0)
        return DB_PARAM;
    int db_ret;
    int iReconnTimes;
    bool bReconn;

    EXEC SQL CONTEXT USE :m_ctx[m_nMyContextid];

start:

    EXEC SQL AT :db_link_name EXECUTE
       begin
        Mini_Local_Pkg.SaveBuyerLogin(:merchantid,:thisintm,:retcode);
    end;
    END-EXEC;

    db_ret = sqlca.sqlcode;
    if (conn_error(db_ret))
    {
        iReconnTimes=0;
        bReconn=ConnectDB();
        while(!bReconn)
        {
            iReconnTimes++;
            sleep(iReconnTimes%10);
            bReconn=ConnectDB();
        }
        goto start;
    }

    if( db_ret < 0 )
    {
        sql_error(sqlca, oraca);
        return DB_ERROR;
    }
    EXEC SQL AT :db_link_name COMMIT;
    return DB_SUCCESS;
}

int CDatabaseMini::Save_Buyer_Logout(uint32 userid,int logouttm)
{
    DEF_ORASET;
    EXEC SQL BEGIN DECLARE SECTION;
        unsigned int merchantid,thisouttm;
        int      retcode;
        VARCHAR db_link_name[32];
    EXEC SQL END DECLARE SECTION;

    strncpy((char*)db_link_name.arr, m_Connect,32);
    db_link_name.len = (short)strlen((char*)db_link_name.arr);

    merchantid = userid;
    thisouttm = logouttm;
    if (userid ==0)
        return DB_PARAM;
    int db_ret;
    int iReconnTimes;
    bool bReconn;

    EXEC SQL CONTEXT USE :m_ctx[m_nMyContextid];

start:

    EXEC SQL AT :db_link_name EXECUTE
       begin
        Mini_Local_Pkg.SaveBuyerLogout(:merchantid,:thisouttm,:retcode);
    end;
    END-EXEC;

    db_ret = sqlca.sqlcode;
    if (conn_error(db_ret))
    {
        iReconnTimes=0;
        bReconn=ConnectDB();
        while(!bReconn)
        {
            iReconnTimes++;
            sleep(iReconnTimes%10);
            bReconn=ConnectDB();
        }
        goto start;
    }
    if( db_ret < 0 )
    {
        sql_error(sqlca, oraca);
        return DB_ERROR;
    }
    EXEC SQL AT :db_link_name COMMIT;
    return DB_SUCCESS;
}

int CDatabaseMini::Save_User_OnlineTime(uint32 clientno,int logintm,int logouttm, int &money)
{
    DEF_ORASET;
    EXEC SQL BEGIN DECLARE SECTION;
        unsigned int        userid,lstouttm, thisintm, thisouttm;
        int                 sendmoney, daymoney;
        int                 countFlag;
        float               onlinetime, todayonlinetm;
        VARCHAR db_link_name[32];
    EXEC SQL END DECLARE SECTION;

    strncpy((char*)db_link_name.arr, m_Connect,32);
    db_link_name.len = (short)strlen((char*)db_link_name.arr);

    userid = clientno;
    thisintm = logintm;
    thisouttm = logouttm;
    sendmoney = DAY_SEND_MONEY;
    todayonlinetm = 0;
    countFlag = 0;
    money = 0;
    lstouttm = 0;
    todayonlinetm = 0;

    unsigned int onlinetm = (unsigned int)(logouttm - logintm);
    char buf[10];
    sprintf(buf, "%.1f", float(onlinetm)/60.0/60);  //六分钟记时
    float onlinetimelen = (float)atof(buf);
    if (onlinetimelen < 0.1)    //小时
        return DB_SUCCESS;
    onlinetime = onlinetimelen;

    int db_ret;
    int iReconnTimes;
    bool bReconn;

    EXEC SQL CONTEXT USE :m_ctx[m_nMyContextid];

start:
    EXEC SQL AT :db_link_name
       SELECT LstLogoutTime, CountFlag, TodayLineTime INTO :lstouttm, :countFlag, :todayonlinetm
       FROM IM_USERSTAT
       WHERE UserId=:userid;
    db_ret = sqlca.sqlcode;
    if (conn_error(db_ret))
    {
        iReconnTimes=0;
        bReconn=ConnectDB();
        while(!bReconn)
        {
            iReconnTimes++;
            sleep(iReconnTimes%10);
            bReconn=ConnectDB();
        }
        goto start;
    }

    if (db_ret < 0 && db_ret != -1405) //出错
    {
        sql_error(sqlca, oraca);
        money = 0;
        return DB_ERROR;
    }
    if (db_ret == 1403)//没有该用户
    {
        if (onlinetimelen >= 2.0)
        {
            EXEC SQL AT :db_link_name INSERT INTO IM_USERSTAT (UserId,LstLoginTime,LstLogoutTime,TotalLineTime,
                 LoginCount, CountFlag,TotalMoney, TodayLineTime)
            values(:userid, :thisintm,:thisouttm,:onlinetime,1, 1, :sendmoney, :onlinetime);
            db_ret = sqlca.sqlcode;
            if (conn_error(db_ret))
            {
                iReconnTimes=0;
                bReconn=ConnectDB();
                while(!bReconn)
                {
                    iReconnTimes++;
                    sleep(iReconnTimes%10);
                    bReconn=ConnectDB();
                }
                goto start;
            }

            if (db_ret < 0 ) //出错
            {
                sql_error(sqlca, oraca);
                money = 0;
                return DB_ERROR;
            }
            EXEC SQL AT :db_link_name COMMIT;
            money = DAY_SEND_MONEY;
        }
        else
        {
            EXEC SQL AT :db_link_name INSERT INTO  IM_USERSTAT (UserId,LstLoginTime,LstLogoutTime,TotalLineTime,
                 LoginCount, TodayLineTime)
            values(:userid, :thisintm,:thisouttm,:onlinetime,1, :onlinetime);
            db_ret = sqlca.sqlcode;
            if (db_ret < 0 ) //出错
            {
                return DB_ERROR;
            }
            EXEC SQL AT :db_link_name COMMIT;
        }

        return DB_SUCCESS;
    }

    if (lstouttm == 0)
        lstouttm = logouttm - 24*60*60;

    //用户登录过
    //上次登出时间与本次登出时间比较

    CTime lst(lstouttm);    //上次登出时间
    CTime logout(logouttm); //本次登出时间
    CTime login(logintm);   //本次登录时间


    //当天非第一次登出
    if (logout.GetYear() == lst.GetYear() && logout.GetMonth() == lst.GetMonth() && logout.GetDay() == lst.GetDay())//年月日相同
    {
        if (countFlag == 0)//当日未充金币
        {
            float tmlen = todayonlinetm + onlinetimelen;
            if ( tmlen >= 2.0)//当日在线时长超过两小时
            {
                EXEC SQL AT :db_link_name UPDATE IM_USERSTAT SET lstLoginTime=:thisintm,LstLogoutTime=:thisouttm,
                TotalLineTime = TotalLineTime+:onlinetime, LoginCount=LoginCount+1,
                CountFlag = 1,TotalMoney= TotalMoney + :sendmoney, TodayLineTime = TodayLineTime + :onlinetime
                WHERE UserId=:userid;
                db_ret = sqlca.sqlcode;
                if (db_ret < 0 ) //出错
                {
                    return DB_ERROR;
                }
                EXEC SQL AT :db_link_name COMMIT;
                money = DAY_SEND_MONEY;
            }
            else//不足两小时
            {
                EXEC SQL AT :db_link_name UPDATE IM_USERSTAT SET lstLoginTime=:thisintm,LstLogoutTime=:thisouttm,
                TotalLineTime = TotalLineTime+:onlinetime, LoginCount=LoginCount+1,
                CountFlag = 0, TodayLineTime = TodayLineTime + :onlinetime WHERE UserId=:userid;
                db_ret = sqlca.sqlcode;
                if (db_ret < 0 ) //出错
                {
                    return DB_ERROR;
                }
                EXEC SQL AT :db_link_name COMMIT;
            }
        }
        else//已充金币
        {
            EXEC SQL AT :db_link_name UPDATE IM_USERSTAT SET lstLoginTime=:thisintm,LstLogoutTime=:thisouttm,
            TotalLineTime = TotalLineTime+:onlinetime, LoginCount=LoginCount+1,
            TodayLineTime = TodayLineTime + :onlinetime WHERE UserId=:userid;
            db_ret = sqlca.sqlcode;
            if (db_ret < 0 ) //出错
            {
                return DB_ERROR;
            }
            EXEC SQL AT :db_link_name COMMIT;
        }
        return DB_SUCCESS;

    }
    else//与上次登出年月日有一个不同 当天第一次登出。
    {
        if (logout.GetDay() == login.GetDay())//同一天登录登出,表示当天第一次上线离线(丢弃在线一个月)
        {
            if ( onlinetimelen >= 2.0)//本次在线时长超过两小时
            {
                EXEC SQL AT :db_link_name UPDATE IM_USERSTAT SET lstLoginTime=:thisintm,LstLogoutTime=:thisouttm,
                TotalLineTime = TotalLineTime+:onlinetime, LoginCount=LoginCount+1,
                CountFlag = 1,TotalMoney= TotalMoney + :sendmoney, TodayLineTime =  :onlinetime
                WHERE UserId=:userid;
                db_ret = sqlca.sqlcode;
                if (db_ret < 0 ) //出错
                {
                    return DB_ERROR;
                }
                EXEC SQL AT :db_link_name COMMIT;
                money = DAY_SEND_MONEY;
            }
            else//不足两小时
            {
                EXEC SQL AT :db_link_name UPDATE IM_USERSTAT SET lstLoginTime=:thisintm,LstLogoutTime=:thisouttm,
                TotalLineTime = TotalLineTime+:onlinetime, LoginCount=LoginCount+1,
                CountFlag = 0, TodayLineTime = :onlinetime WHERE UserId=:userid;
                db_ret = sqlca.sqlcode;
                if (db_ret < 0 ) //出错
                {
                    return DB_ERROR;
                }
                EXEC SQL AT :db_link_name COMMIT;
            }
            return DB_SUCCESS;
        }
        else//上下线不在同一天。
        {
            char buf[10];
            sprintf(buf, "%.1f", login.GetMinute()/60.0);
            float fintm = (float)atof(buf);
            fintm = float(24.0 -(float)login.GetHour()-fintm);//登录当天在线时长
            sprintf(buf, "%.1f", logout.GetMinute()/60.0);
            float fouttm = (float)atof(buf);
            fouttm = (float)logout.GetHour()+fouttm;//登出当天在线时长

            if (fintm >= 2.0)//登录当天在线时长超过两小时
            {
                if (login.GetYear() == lst.GetYear() && login.GetMonth() == lst.GetMonth() && login.GetDay() == lst.GetDay())//当天有登出过
                {
                    if (countFlag == 0)//前一天未充金币
                    {
                        EXEC SQL AT :db_link_name UPDATE IM_USERSTAT SET TotalMoney= TotalMoney + :sendmoney
                        WHERE UserId=:userid;
                        db_ret = sqlca.sqlcode;
                        if (db_ret < 0 ) //出错
                        {
                            return DB_ERROR;
                        }
                        EXEC SQL AT :db_link_name COMMIT;
                        money = DAY_SEND_MONEY;
                    }
                }
                else
                {
                    EXEC SQL AT :db_link_name UPDATE IM_USERSTAT SET TotalMoney= TotalMoney + :sendmoney
                    WHERE UserId=:userid;
                    db_ret = sqlca.sqlcode;
                    if (db_ret < 0 ) //出错
                    {
                        return DB_ERROR;
                    }
                    EXEC SQL AT :db_link_name COMMIT;
                    money = DAY_SEND_MONEY;

                }
            }
            else//22点以后登录
            {
                if (login.GetYear() == lst.GetYear() && login.GetMonth() == lst.GetMonth() && login.GetDay() == lst.GetDay())//前一天有登出过
                {
                    if (countFlag == 0)//前一天未充金币
                    {
                        float tmlen = todayonlinetm + fintm;
                        if ( tmlen >= 2.0)//前一天在线时长累计超过两小时
                        {
                            EXEC SQL AT :db_link_name UPDATE IM_USERSTAT SET TotalMoney= TotalMoney + :sendmoney
                            WHERE UserId=:userid;
                            db_ret = sqlca.sqlcode;
                            if (db_ret < 0 ) //出错
                            {
                                return DB_ERROR;
                            }
                            EXEC SQL AT :db_link_name COMMIT;
                            money = DAY_SEND_MONEY;//登入当天发送的金币
                        }
                    }
                }
            }


            float tmlen = onlinetimelen-fintm-fouttm;//除登入登出天在线时间

            int day = int(tmlen)/24;//登录登出间隔天数
            if (day != 0)
            {
                daymoney = sendmoney * day;
                EXEC SQL AT :db_link_name UPDATE IM_USERSTAT SET TotalMoney= TotalMoney + :daymoney
                WHERE UserId=:userid;
                db_ret = sqlca.sqlcode;
                if (db_ret < 0 ) //出错
                {
                    return DB_SUCCESS;
                }
                EXEC SQL AT :db_link_name COMMIT;
                money = money  + daymoney;

            }
            onlinetime = fouttm;
            if( fouttm >= 2.0)//登出当天在线时长超过两小时
            {
                EXEC SQL AT :db_link_name UPDATE IM_USERSTAT SET lstLoginTime=:thisintm,LstLogoutTime=:thisouttm,
                TotalLineTime = TotalLineTime+:onlinetime, LoginCount=LoginCount+1,
                CountFlag = 1,TotalMoney= TotalMoney + :sendmoney, TodayLineTime =  :onlinetime
                WHERE UserId=:userid;
                db_ret = sqlca.sqlcode;
                if (db_ret < 0 ) //出错
                {
                    return DB_SUCCESS;
                }
                EXEC SQL AT :db_link_name COMMIT;
                money = money  + DAY_SEND_MONEY;
            }
            else//不足两小时
            {
                EXEC SQL AT :db_link_name UPDATE IM_USERSTAT SET lstLoginTime=:thisintm,LstLogoutTime=:thisouttm,
                TotalLineTime = TotalLineTime+:onlinetime, LoginCount=LoginCount+1,
                CountFlag = 0, TodayLineTime = :onlinetime WHERE UserId=:userid;
                db_ret = sqlca.sqlcode;
                if (db_ret < 0 ) //出错
                {
                    return DB_SUCCESS;
                }
                EXEC SQL AT :db_link_name COMMIT;
            }
        }
    }

    return DB_SUCCESS;
}

int CDatabaseMini::Save_User_RecvFamilyMsgID(uint32 uid, uint32 cid, uint32 mid)
{
    DEF_ORASET;
    EXEC SQL BEGIN DECLARE SECTION;
        unsigned int  clusterid,clientid,msgid;
        VARCHAR db_link_name[32];
        int      retcode;
    EXEC SQL END DECLARE SECTION;

    clusterid = cid;
    clientid=uid;
    msgid = mid;
    strncpy((char*)db_link_name.arr, m_Connect,32);
    db_link_name.len = (short)strlen((char*)db_link_name.arr);

    int db_ret;
    int iReconnTimes;
    bool bReconn;

    EXEC SQL CONTEXT USE :m_ctx[m_nMyContextid];

start:
    EXEC SQL AT :db_link_name EXECUTE
       begin
        Mini_Local_Pkg.SaveUserRecvFamilyMsg(:clusterid,:clientid,:msgid,:retcode);
    end;
    END-EXEC;

    db_ret = sqlca.sqlcode;
    if (conn_error(db_ret))
    {
        iReconnTimes=0;
        bReconn=ConnectDB();
        while(!bReconn)
        {
            iReconnTimes++;
            sleep(iReconnTimes%10);
            bReconn=ConnectDB();
        }
        goto start;
    }

    if( db_ret < 0 )
    {
        sql_error(sqlca, oraca);
        return DB_ERROR;
    }

    return DB_SUCCESS;
}


int CDatabaseMini::Get_User_FamilyMsgID(uint32 userID, uint32 familyID, uint32 &msgID)
{
    DEF_ORASET;
    EXEC SQL BEGIN DECLARE SECTION;
        unsigned int      clusterid,mid,clientno;
        VARCHAR db_link_name[32];
        int  retcode;
    EXEC SQL END DECLARE SECTION;

    clientno=userID;
    clusterid = familyID;
    strncpy((char*)db_link_name.arr, m_Connect,32);
    db_link_name.len = (short)strlen((char*)db_link_name.arr);
    int db_ret;
    int iReconnTimes;
    bool bReconn;
    EXEC SQL CONTEXT USE :m_ctx[m_nMyContextid];

start:
    EXEC SQL AT :db_link_name EXECUTE
       begin
        Mini_Local_Pkg.GetUserFamilyMsgID(:clientno,:clusterid,:mid,:retcode);
    end;
    END-EXEC;

    db_ret = sqlca.sqlcode;
    if (conn_error(db_ret))
    {
        iReconnTimes=0;
        bReconn=ConnectDB();
        while(!bReconn)
        {
            iReconnTimes++;
            sleep(iReconnTimes%10);
            bReconn=ConnectDB();
        }
        goto start;
    }

    if( db_ret < 0 && db_ret != -1405)
    {
        mid = 0;
        sql_error(sqlca, oraca);
    }

    if (db_ret == 1403 || retcode == 1403 || db_ret == -1405)
        mid = 0;

    msgID = mid;
    return DB_SUCCESS;
}

int CDatabaseMini::Delete_All_Offline_Msg(uint32 userID)
{
    DEF_ORASET;
    EXEC SQL BEGIN DECLARE SECTION;
        unsigned int     recv;
        VARCHAR db_link_name[32];
        int      retcode;
    EXEC SQL END DECLARE SECTION;
    recv = userID;
    strncpy((char*)db_link_name.arr, m_Connect,32);
    db_link_name.len = (short)strlen((char*)db_link_name.arr);

    int db_ret;
    int iReconnTimes;
    bool bReconn;

    EXEC SQL CONTEXT USE :m_ctx[m_nMyContextid];
start:

    EXEC SQL AT :db_link_name EXECUTE
       begin
        Mini_Local_Pkg.DeleteAllOfflineMsg(:recv,:retcode);
    end;
    END-EXEC;

    db_ret = sqlca.sqlcode;
    if (conn_error(db_ret))
    {
        iReconnTimes=0;
        bReconn=ConnectDB();
        while(!bReconn)
        {
            iReconnTimes++;
            sleep(iReconnTimes%10);
            bReconn=ConnectDB();
        }
        goto start;
    }

    if( db_ret < 0 && db_ret != -1405)
    {
        sql_error(sqlca, oraca);
    }
    return DB_SUCCESS;
}

int CDatabaseMini::Get_Family_Offline_Msg(uint32 userID, uint32 familyID, uint32 &msgID, ST_OFFLINE_MSG *pFamilyMsg, uint8 &nRetCount)
{
    DEF_ORASET;
    EXEC SQL BEGIN DECLARE SECTION;
        long_varraw *lvr;
        unsigned int     origin,time,msglen,msgid,int_tmp;
        short   msgtype;
        OCIBlobLocator *blob;
        unsigned int amt,offset,bufsize,clusid,msgno;
        VARCHAR db_link_name[32];
    EXEC SQL END DECLARE SECTION;

    strncpy((char*)db_link_name.arr, m_Connect,32);
    db_link_name.len = (short)strlen((char*)db_link_name.arr);

    amt = 0;
    offset=1;
    bufsize = MAX_MSG_LEN;
    clusid = familyID;
    msgid = msgID;
    unsigned int nowmid=msgid;
    int db_ret;
    msgID = 0;
    int iReconnTimes;
    bool bReconn;

    EXEC SQL CONTEXT USE :m_ctx[m_nMyContextid];

start:
    if (nRetCount == 0)
    {
        EXEC SQL AT :db_link_name SELECT COUNT(MsgId) INTO :int_tmp
        FROM  IM_CLUSTERTALKMSG
        WHERE ClusterId= :clusid AND MsgId > :msgid;
        db_ret = sqlca.sqlcode;
        if (conn_error(db_ret))
        {
            iReconnTimes=0;
            bReconn=ConnectDB();
            while(!bReconn)
            {
                iReconnTimes++;
                sleep(iReconnTimes%10);
                bReconn=ConnectDB();
            }
            goto start;
        }

        if( db_ret < 0 )
        {
            sql_error(sqlca, oraca);
            return DB_ERROR;
        }
        nRetCount = int_tmp;
        return DB_SUCCESS;
    }

    EXEC SQL AT :db_link_name DECLARE cur_getfamilymsg CURSOR FOR
       SELECT MsgId,SENDER,SENDTIME,MSGTYPE,MSGLEN,MSG
       FROM  IM_CLUSTERTALKMSG WHERE ClusterId= :clusid AND MsgId > :msgid ORDER BY MsgId;

    EXEC SQL OPEN cur_getfamilymsg;
    db_ret = sqlca.sqlcode;
    if (conn_error(db_ret))
    {
        EXEC SQL CLOSE cur_getfamilymsg;
        iReconnTimes=0;
        bReconn=ConnectDB();
        while(!bReconn)
        {
            iReconnTimes++;
            sleep(iReconnTimes%10);
            bReconn=ConnectDB();
        }
        goto start;
    }

    if( db_ret < 0  && db_ret != -1405)
    {

        sql_error(sqlca, oraca);
        EXEC SQL CLOSE cur_getfamilymsg;
        return DB_ERROR;
    }

    EXEC SQL AT :db_link_name ALLOCATE :blob;
    db_ret = sqlca.sqlcode;
    if (conn_error(db_ret))
    {
        EXEC SQL CLOSE cur_getfamilymsg;
        iReconnTimes=0;
        bReconn=ConnectDB();
        while(!bReconn)
        {
            iReconnTimes++;
            sleep(iReconnTimes%10);
            bReconn=ConnectDB();
        }
        goto start;
    }

    if (db_ret == 1403 || (db_ret < 0  && db_ret != -1405 ))
    {
        sql_error(sqlca, oraca);
        EXEC SQL AT :db_link_name FREE :blob;
        EXEC SQL CLOSE cur_getfamilymsg;
        return DB_ERROR;
    }

    lvr = (long_varraw *)malloc(sizeof(unsigned int) + bufsize);
    lvr->len = bufsize;

    int iNum = 0;
    for(;;)
    {
        msglen=0;
        amt = 0;
        offset=1;
        bufsize = MAX_MSG_LEN;
        EXEC SQL FETCH cur_getfamilymsg INTO :msgno,:origin,:time,:msgtype,:msglen,:blob;
        db_ret = sqlca.sqlcode;
        if (conn_error(db_ret))
        {
            EXEC SQL CLOSE cur_getfamilymsg;
            iReconnTimes=0;
            bReconn=ConnectDB();
            while(!bReconn)
            {
                iReconnTimes++;
                sleep(iReconnTimes%10);
                bReconn=ConnectDB();
            }
            goto start;
        }

        if ((db_ret < 0 && db_ret != -1405)|| db_ret == 1403 || iNum >= nRetCount)
        {
            if (db_ret != 1403)
                sql_error(sqlca, oraca);

            EXEC SQL AT :db_link_name FREE :blob;
            EXEC SQL CLOSE cur_getfamilymsg;
            free(lvr);
            msgID = nowmid;
            nRetCount = iNum;
            return DB_SUCCESS;
        }

        pFamilyMsg[iNum].msgid      = msgno;
        pFamilyMsg[iNum].recvID     = userID;
        pFamilyMsg[iNum].sendID     = origin;
        pFamilyMsg[iNum].tm         = (unsigned int)time;
        pFamilyMsg[iNum].msgtype    = (unsigned short)msgtype;
        pFamilyMsg[iNum].msglen     = msglen + 1;


        EXEC SQL AT :db_link_name LOB READ :amt FROM :blob AT :offset INTO :lvr WITH LENGTH :msglen;
        if (sqlca.sqlcode == 1403 )
        {
            memcpy((char*)pFamilyMsg[iNum].msg,lvr->buf,msglen + 1);
            memset(lvr->buf, 0, msglen);
            nowmid = msgno;
        }
        ++iNum;
    }

    EXEC SQL AT :db_link_name FREE :blob;
    EXEC SQL CLOSE cur_getfamilymsg;
    free(lvr);
    return DB_SUCCESS;
}

int CDatabaseMini::Get_Family_Offline_SysMsg(uint32 userID, uint32 familyID,ST_OFFLINE_MSG *pFamilyMsg, uint8 &nRetCount)
{
    DEF_ORASET;
    EXEC SQL BEGIN DECLARE SECTION;
        long_varraw *lvr;
        unsigned int     sendno,time,msglen, int_tmp;
        short   msgtype;
        OCIBlobLocator *blob;
        unsigned int amt,offset,bufsize;
        unsigned int clusid;
        VARCHAR db_link_name[32];
    EXEC SQL END DECLARE SECTION;

    strncpy((char*)db_link_name.arr, m_Connect,32);
    db_link_name.len = (short)strlen((char*)db_link_name.arr);

    //unsigned int nowmid=0;
    amt = 0;
    offset=1;
    bufsize = MAX_MSG_LEN;
    clusid = familyID;
    int db_ret;
    int iReconnTimes;
    bool bReconn;

    EXEC SQL CONTEXT USE :m_ctx[m_nMyContextid];

start:
    if (nRetCount == 0)
    {
        EXEC SQL AT :db_link_name SELECT COUNT(MsgId) INTO :int_tmp
        FROM IM_CLUSTERSYSMSG
        WHERE ClusterId= :clusid;
        db_ret = sqlca.sqlcode;
        if (conn_error(db_ret))
        {
            iReconnTimes=0;
            bReconn=ConnectDB();
            while(!bReconn)
            {
                iReconnTimes++;
                sleep(iReconnTimes%10);
                bReconn=ConnectDB();
            }
            goto start;
        }

        if( db_ret < 0 )
        {
            sql_error(sqlca, oraca);
            return DB_ERROR;
        }
        nRetCount = int_tmp;
        return DB_SUCCESS;
    }

    EXEC SQL AT :db_link_name DECLARE cur_familysysmsg CURSOR FOR
       SELECT MsgId,SendTime,MsgType,MsgLen,MSG
       FROM   IM_CLUSTERSYSMSG WHERE ClusterId= :clusid;
    EXEC SQL OPEN cur_familysysmsg;
    db_ret = sqlca.sqlcode;
    if (conn_error(db_ret))
    {
        EXEC SQL CLOSE cur_familysysmsg;
        iReconnTimes=0;
        bReconn=ConnectDB();
        while(!bReconn)
        {
            iReconnTimes++;
            sleep(iReconnTimes%10);
            bReconn=ConnectDB();
        }
        goto start;
    }

    if( db_ret < 0 )
    {
        sql_error(sqlca, oraca);
        EXEC SQL CLOSE cur_familysysmsg;
        return DB_ERROR;
    }

    EXEC SQL AT :db_link_name ALLOCATE :blob;
    db_ret = sqlca.sqlcode;
    if (conn_error(db_ret))
    {
        EXEC SQL CLOSE cur_familysysmsg;
        iReconnTimes=0;
        bReconn=ConnectDB();
        while(!bReconn)
        {
            iReconnTimes++;
            sleep(iReconnTimes%10);
            bReconn=ConnectDB();
        }
        goto start;
    }

    if (db_ret == 1403 || db_ret < 0)
    {
        if (db_ret != 1403)
            sql_error(sqlca, oraca);
        EXEC SQL AT :db_link_name FREE :blob;
        EXEC SQL CLOSE cur_familysysmsg;
        return DB_ERROR;
    }

    lvr = (long_varraw *)malloc(sizeof(unsigned int) + bufsize);
    lvr->len = bufsize;

    int iNum = 0;
    for(;;)
    {
        amt = 0;
        offset=1;
        bufsize = MAX_MSG_LEN;
        EXEC SQL FETCH cur_familysysmsg INTO :sendno,:time,:msgtype,:msglen,:blob;
        db_ret = sqlca.sqlcode;
        if (conn_error(db_ret))
        {
            EXEC SQL CLOSE cur_familysysmsg;
            iReconnTimes=0;
            bReconn=ConnectDB();
            while(!bReconn)
            {
                iReconnTimes++;
                sleep(iReconnTimes%10);
                bReconn=ConnectDB();
            }
            goto start;
        }

        if ( db_ret < 0 || db_ret == 1403 || iNum >= nRetCount)
        {
            if (db_ret != 1403)
                sql_error(sqlca, oraca);
            EXEC SQL AT :db_link_name FREE :blob;
            free(lvr);
            EXEC SQL CLOSE cur_familysysmsg;
            if (iNum > 0)
            {
                EXEC SQL AT :db_link_name DELETE FROM IM_CLUSTERSYSMSG WHERE  ClusterId = :clusid;//清除验证记录
                EXEC SQL AT :db_link_name COMMIT;
            }
            nRetCount = iNum;
            return DB_SUCCESS;
        }

        pFamilyMsg[iNum].recvID     = userID;
        pFamilyMsg[iNum].sendID     = sendno;
        pFamilyMsg[iNum].tm         = (unsigned int)time;
        pFamilyMsg[iNum].msgtype    = (unsigned short)msgtype;
        pFamilyMsg[iNum].msglen     = msglen + 1;


        EXEC SQL AT :db_link_name LOB READ :amt FROM :blob AT :offset INTO :lvr WITH LENGTH :msglen;
        if (sqlca.sqlcode == 1403 )
        {
            memcpy((char*)pFamilyMsg[iNum].msg,lvr->buf,msglen + 1);
        }
        ++iNum;
    }

    EXEC SQL AT :db_link_name DELETE FROM IM_CLUSTERSYSMSG WHERE  ClusterId = :clusid;//清除验证记录


    EXEC SQL AT :db_link_name FREE :blob;
    EXEC SQL CLOSE cur_familysysmsg;
    free(lvr);
    return DB_SUCCESS;
}

/* 获取某个用户的离线聊天信息 */
int  CDatabaseMini::Get_User_Offline_Msg(uint32 userID,ST_OFFLINE_MSG *pFamilyMsg, uint8 &nRetCount)
{
    DEF_ORASET;
    EXEC SQL BEGIN DECLARE SECTION;
        long_varraw *lvr;
        unsigned int     recv,origin,time,msglen, int_tmp;
        short   msgtype;
        OCIBlobLocator *blob;
        unsigned int amt,offset,bufsize;
        VARCHAR db_link_name[32];
    EXEC SQL END DECLARE SECTION;

    strncpy((char*)db_link_name.arr, m_Connect,32);
    db_link_name.len = (short)strlen((char*)db_link_name.arr);

    amt = 0;
    offset=1;
    bufsize = MAX_MSG_LEN;

    recv = userID;

    int db_ret;
    int iReconnTimes;
    bool bReconn;

    EXEC SQL CONTEXT USE :m_ctx[m_nMyContextid];

start:
    if (nRetCount == 0)
    {
        EXEC SQL AT :db_link_name SELECT COUNT(Sender) INTO :int_tmp
        FROM  IM_OFFLINETALKMSG WHERE Receiver= :recv;
        db_ret = sqlca.sqlcode;
        if (conn_error(db_ret))
        {
            iReconnTimes=0;
            bReconn=ConnectDB();
            while(!bReconn)
            {
                iReconnTimes++;
                sleep(iReconnTimes%10);
                bReconn=ConnectDB();
            }
            goto start;
        }

        if( db_ret < 0 )
        {
            sql_error(sqlca, oraca);
            return DB_ERROR;
        }
        nRetCount = int_tmp;
        return DB_SUCCESS;
    }

    EXEC SQL AT :db_link_name DECLARE cur_getusermsg CURSOR FOR
       SELECT Sender,
        (cast(cast(SendTime as timestamp) at time zone 'gmt' as date)-to_date('19700101 00:00:00','yyyymmdd hh24:mi:ss'))*24*60*
    60 as SendTime, MsgType,MsgLen,MSG
       FROM  IM_OFFLINETALKMSG WHERE Receiver= :recv order by SendTime;
    EXEC SQL OPEN cur_getusermsg;
    db_ret = sqlca.sqlcode;
    if (conn_error(db_ret))
    {
        EXEC SQL CLOSE cur_familysysmsg;
        iReconnTimes=0;
        bReconn=ConnectDB();
        while(!bReconn)
        {
            iReconnTimes++;
            sleep(iReconnTimes%10);
            bReconn=ConnectDB();
        }
        goto start;
    }

    if( db_ret < 0 && db_ret != -1405)
    {
        sql_error(sqlca, oraca);
        EXEC SQL CLOSE cur_familysysmsg;
        return DB_ERROR;
    }

    EXEC SQL AT :db_link_name ALLOCATE :blob;
    db_ret = sqlca.sqlcode;
    if (conn_error(db_ret))
    {
        EXEC SQL CLOSE cur_familysysmsg;
        iReconnTimes=0;
        bReconn=ConnectDB();
        while(!bReconn)
        {
            iReconnTimes++;
            sleep(iReconnTimes%10);
            bReconn=ConnectDB();
        }
        goto start;
    }

    if (db_ret == 1403 || db_ret < 0)
    {
        sql_error(sqlca, oraca);
        EXEC SQL AT :db_link_name FREE :blob;
        EXEC SQL CLOSE cur_familysysmsg;
        return DB_ERROR;
    }

    lvr = (long_varraw *)malloc(sizeof(unsigned int) + bufsize);
    lvr->len = bufsize;

    int iNum = 0;

    for(;;)
    {
        amt = 0;
        offset=1;
        bufsize = MAX_MSG_LEN;

        EXEC SQL FETCH cur_getusermsg INTO :origin,:time,:msgtype,:msglen,:blob;
        db_ret = sqlca.sqlcode;
        if (conn_error(db_ret))
        {
            EXEC SQL CLOSE cur_getusermsg;
            iReconnTimes=0;
            bReconn=ConnectDB();
            while(!bReconn)
            {
                iReconnTimes++;
                sleep(iReconnTimes%10);
                bReconn=ConnectDB();
            }
            goto start;
        }

        if (( db_ret < 0  && db_ret != -1405)|| db_ret == 1403 || iNum >= nRetCount)
        {
            if (db_ret != 1403)
                sql_error(sqlca, oraca);
            EXEC SQL AT :db_link_name FREE :blob;
            EXEC SQL CLOSE cur_getusermsg;
            free(lvr);
            nRetCount = iNum;
            return DB_SUCCESS;
        }

        pFamilyMsg[iNum].recvID     = userID;
        pFamilyMsg[iNum].sendID     = origin;
        pFamilyMsg[iNum].tm         = (unsigned int)time;
        pFamilyMsg[iNum].msgtype    = (unsigned short)msgtype;
        pFamilyMsg[iNum].msglen     = msglen + 1;


        EXEC SQL AT :db_link_name LOB READ :amt FROM :blob AT :offset INTO :lvr WITH LENGTH :msglen;
        if (sqlca.sqlcode == 1403 )
        {
            memcpy((char*)pFamilyMsg[iNum].msg,lvr->buf,msglen + 1);
        }
        ++iNum;

    }

    EXEC SQL AT :db_link_name FREE :blob;
    EXEC SQL CLOSE cur_getusermsg;
    free(lvr);
    return DB_SUCCESS;
}


//   获取某个用户的离线系统信息
int  CDatabaseMini::Get_User_Offline_SysMsg(uint32 userID,ST_OFFLINE_MSG *pFamilyMsg, uint8 &nRetCount)
{
    DEF_ORASET;
    EXEC SQL BEGIN DECLARE SECTION;
        long_varraw *lvr;
        unsigned int     recv,origin,time,msglen, int_tmp;
        short   msgtype;
        OCIBlobLocator *blob;
        unsigned int amt,offset,bufsize;
        VARCHAR db_link_name[32];
    EXEC SQL END DECLARE SECTION;

    strncpy((char*)db_link_name.arr, m_Connect,32);
    db_link_name.len = (short)strlen((char*)db_link_name.arr);


    amt = 0;
    offset=1;
    bufsize = MAX_MSG_LEN;

    recv = userID;
    int db_ret;
    int iReconnTimes;
    bool bReconn;

    EXEC SQL CONTEXT USE :m_ctx[m_nMyContextid];

start:
    if (nRetCount == 0)
    {
        EXEC SQL AT :db_link_name SELECT COUNT(Sender) INTO :int_tmp
        FROM  IM_OFFLINESYSMSG WHERE Receiver= :recv;
        db_ret = sqlca.sqlcode;
        if (conn_error(db_ret))
        {
            iReconnTimes=0;
            bReconn=ConnectDB();
            while(!bReconn)
            {
                iReconnTimes++;
                sleep(iReconnTimes%10);
                bReconn=ConnectDB();
            }
            goto start;
        }

        if( db_ret < 0 )
        {
            sql_error(sqlca, oraca);
            return DB_ERROR;
        }
        nRetCount = int_tmp;
        return DB_SUCCESS;
    }

    EXEC SQL AT :db_link_name DECLARE cur_getusersysmsg CURSOR FOR
       SELECT Sender,SendTime,MsgType,MsgLen,MSG
       FROM   IM_OFFLINESYSMSG WHERE Receiver= :recv;
    EXEC SQL OPEN cur_getusersysmsg;
    db_ret = sqlca.sqlcode;
    if (conn_error(db_ret))
    {
        EXEC SQL CLOSE cur_familysysmsg;
        iReconnTimes=0;
        bReconn=ConnectDB();
        while(!bReconn)
        {
            iReconnTimes++;
            sleep(iReconnTimes%10);
            bReconn=ConnectDB();
        }
        goto start;
    }

    if( db_ret < 0  && db_ret != -1405)
    {
        sql_error(sqlca, oraca);
        EXEC SQL CLOSE cur_familysysmsg;
        return DB_ERROR;
    }

    EXEC SQL AT :db_link_name ALLOCATE :blob;
    db_ret = sqlca.sqlcode;
    if (conn_error(db_ret))
    {
        EXEC SQL CLOSE cur_familysysmsg;
        iReconnTimes=0;
        bReconn=ConnectDB();
        while(!bReconn)
        {
            iReconnTimes++;
            sleep(iReconnTimes%10);
            bReconn=ConnectDB();
        }
        goto start;
    }

    if (db_ret == 1403 || (db_ret < 0  && db_ret != -1405) )
    {
        if (db_ret != 1403)
            sql_error(sqlca, oraca);
        EXEC SQL AT :db_link_name FREE :blob;
        EXEC SQL CLOSE cur_familysysmsg;
        return DB_ERROR;
    }

    lvr = (long_varraw *)malloc(sizeof(unsigned int) + bufsize);
    lvr->len = bufsize;

    int iNum = 0;

    for(;;)
    {
        amt = 0;
        offset=1;
        bufsize = MAX_MSG_LEN;
        EXEC SQL FETCH cur_getusersysmsg INTO :origin,:time,:msgtype,:msglen,:blob;

        db_ret = sqlca.sqlcode;
        if (conn_error(db_ret))
        {
            EXEC SQL CLOSE cur_getusersysmsg;
            iReconnTimes=0;
            bReconn=ConnectDB();
            while(!bReconn)
            {
                iReconnTimes++;
                sleep(iReconnTimes%10);
                bReconn=ConnectDB();
            }
            goto start;
        }

        if ( (db_ret < 0 && db_ret != -1405) || db_ret == 1403 || iNum >= nRetCount)
        {
            if (db_ret != 1403)
                sql_error(sqlca, oraca);
            EXEC SQL AT :db_link_name FREE :blob;
            EXEC SQL CLOSE cur_getusersysmsg;
            free(lvr);
            nRetCount = iNum;
            return DB_SUCCESS;
        }

        pFamilyMsg[iNum].recvID     = userID;
        pFamilyMsg[iNum].sendID     = origin;
        pFamilyMsg[iNum].tm         = (unsigned int)time;
        pFamilyMsg[iNum].msgtype    = (unsigned short)msgtype;
        pFamilyMsg[iNum].msglen     = msglen + 1;


        EXEC SQL AT :db_link_name LOB READ :amt FROM :blob AT :offset INTO :lvr WITH LENGTH :msglen;
        if (sqlca.sqlcode == 1403 )
        {
            memcpy((char*)pFamilyMsg[iNum].msg,lvr->buf,msglen + 1);
        }
        ++iNum;
    }

    EXEC SQL AT :db_link_name FREE :blob;
    EXEC SQL CLOSE cur_getusersysmsg;
    free(lvr);
    return DB_SUCCESS;
}

//获取客户端系统消息（公告)
int CDatabaseMini::Get_Pub_Msg(uint32 userID,ST_WEB_MSG *pMsg, uint8 &nRetCount)
{
    DEF_ORASET;
    EXEC SQL BEGIN DECLARE SECTION;
        unsigned int     recv;
        unsigned int msgno, msgrecvid, timenow;
        VARCHAR var_msg[1401];
        VARCHAR db_link_name[32],timesend[32];
    EXEC SQL END DECLARE SECTION;

    SET_INIT_NULL(var_msg);

    strncpy((char*)db_link_name.arr, m_Connect,32);
    db_link_name.len = (short)strlen((char*)db_link_name.arr);

    var_msg.arr[0]='\0';
    var_msg.len=0;
    timesend.arr[0] = '\0';
    timesend.len = 0;
    msgrecvid = 0;
    msgno = 0;

    EXEC SQL CONTEXT USE :m_ctx[m_nMyContextid];

    recv = userID;
    int db_ret;
    int iReconnTimes;
    bool bReconn;

start:
    EXEC SQL AT :db_link_name SELECT MsgID INTO :msgno FROM IM_USERSTAT WHERE UserId=:recv;
    db_ret = sqlca.sqlcode;
    if (conn_error(db_ret))
    {
        iReconnTimes=0;
        bReconn=ConnectDB();
        while(!bReconn)
        {
            iReconnTimes++;
            sleep(iReconnTimes%10);
            bReconn=ConnectDB();
        }
        goto start;
    }

    if (db_ret < 0)
    {
        sql_error(sqlca, oraca);
        return DB_ERROR;
    }

    if (db_ret == 1403)//没有该用户
    {
        msgno = 0;

        time_t t;
        time(&t);
        timenow = (unsigned int)t;
        EXEC SQL AT :db_link_name INSERT INTO  IM_USERSTAT (UserId,MSGID,LstLoginTime,LstLogoutTime)
        values(:recv, :msgno, :timenow,:timenow);
        db_ret = sqlca.sqlcode;
        if (conn_error(db_ret))
        {
            iReconnTimes=0;
            bReconn=ConnectDB();
            while(!bReconn)
            {
                iReconnTimes++;
                sleep(iReconnTimes%10);
                bReconn=ConnectDB();
            }
            goto start;
        }

        if (db_ret < 0 ) //出错
        {
            sql_error(sqlca, oraca);
            return DB_ERROR;
        }
        EXEC SQL AT :db_link_name COMMIT;
    }

    EXEC SQL AT :db_link_name DECLARE cur_pubmsg CURSOR FOR
       SELECT Msgid, msg,TO_CHAR(PubTime,'YYYY/MM/DD HH24:MI:SS')
       FROM IM_SYSTEMMSG WHERE Msgid > :msgno AND ExpireTime>= sysdate ORDER BY MSGID;
    EXEC SQL OPEN cur_pubmsg;
    int iNum = 0;
    for(;;)
    {
        EXEC SQL FETCH cur_pubmsg INTO :msgrecvid, :var_msg,:timesend;
        db_ret = sqlca.sqlcode;
        if (db_ret == 1403 )
        {
            EXEC SQL CLOSE cur_pubmsg;
            if (iNum != 0)
            {
                EXEC SQL AT :db_link_name UPDATE IM_USERSTAT SET MSGID = :msgno WHERE UserId=:recv;
                EXEC SQL AT :db_link_name COMMIT;
            }
            nRetCount = iNum;
            return DB_SUCCESS;
        }
        if( db_ret < 0 && db_ret != -1405 )
        {
            sql_error(sqlca, oraca);
            EXEC SQL CLOSE cur_pubmsg;
            nRetCount = iNum;
            return DB_SUCCESS;
        }
        msgno = msgrecvid;

        var_msg.arr[var_msg.len]='\0';
        timesend.arr[timesend.len] = '\0';

        pMsg[iNum].recID            = 0;
        pMsg[iNum].recvID       = recv;
        pMsg[iNum].sendID       = 0;
        pMsg[iNum].msgtype      = 0;
        //pMsg[iNum].msglen     = var_msg.len + 1;
        memcpy((char*)pMsg[iNum].msg,var_msg.arr,var_msg.len + 1);
        strncpy(pMsg[iNum].sendTime, (char*)timesend.arr,31);

        iNum++;
        memset(var_msg.arr, 0,var_msg.len);
        memset(timesend.arr, 0, timesend.len);
    }

    EXEC SQL CLOSE cur_pubmsg;
    return DB_SUCCESS;
}

int CDatabaseMini::Save_OnlineUser_Num(uint32 onlinenum)
{
    DEF_ORASET;
    EXEC SQL BEGIN DECLARE SECTION;
        unsigned int     ionlinenum;
        VARCHAR db_link_name[32];
        int      retcode;
    EXEC SQL END DECLARE SECTION;


    strncpy((char*)db_link_name.arr, m_Connect,32);
    db_link_name.len = (short)strlen((char*)db_link_name.arr);

    ionlinenum = onlinenum;
    EXEC SQL CONTEXT USE :m_ctx[m_nMyContextid];

    int db_ret;
    int iReconnTimes;
    bool bReconn;

start:
    EXEC SQL AT :db_link_name EXECUTE
       begin
        Mini_Local_Pkg.SaveOnlineNum(:ionlinenum,:retcode);
    end;
    END-EXEC;
    db_ret = sqlca.sqlcode;
    if (conn_error(db_ret))
    {
        iReconnTimes=0;
        bReconn=ConnectDB();
        while(!bReconn)
        {
            iReconnTimes++;
            sleep(iReconnTimes%10);
            bReconn=ConnectDB();
        }
        goto start;
    }

    if (db_ret < 0)
    {
        sql_error(sqlca, oraca);
        return DB_ERROR;
    }

    return DB_SUCCESS;
}

int CDatabaseMini::TestContext(void)
{
//  DEF_ORASET;

//  EXEC SQL BEGIN DECLARE SECTION;
//      sql_context testctx[ 1 ];
//  EXEC SQL END DECLARE SECTION;
//
//  for (int i = 0; i < 1; ++i)
//  {
//      EXEC SQL CONTEXT ALLOCATE :testctx[i];
//  }
//  for (int i = 0; i < 1; ++i)
//  {
//      EXEC SQL CONTEXT USE :testctx[i];
//      EXEC SQL CONTEXT FREE :testctx[i];
//  }
    return 0;
}

//test blob procedure
int CDatabaseMini::Save_Family_RequestMsg2(const uint32 c_iFamilyID, uint32 iSenderID,uint32 iSendTime,const char *strMsg, int iMsgLen)
{
    DEF_ORASET;
    EXEC SQL BEGIN DECLARE SECTION;
        long_varraw * lvr;
        unsigned int     nFamilyID, nSenderID, nSendTime, nMsgSeq;
        int nMsgLen, nMsgType;
        char*   pmsg;
        OCIBlobLocator *blob;
        unsigned int offset = 1; /* attention: typedef ub4 unsigned int */
        VARCHAR db_link_name[32];
        int      retcode;
    EXEC SQL END DECLARE SECTION;

    strncpy((char*)db_link_name.arr, m_Connect,32);
    db_link_name.len = (short)strlen(m_Connect);


    nFamilyID = c_iFamilyID;
    nSenderID = iSenderID;
    nSendTime = iSendTime;
    nMsgLen = iMsgLen;
    nMsgType = CMD_CLUSTER_AUTH_REQ;
    pmsg = (char*)strMsg;

    int db_ret;
    int iReconnTimes;
    bool bReconn;

    EXEC SQL CONTEXT USE :m_ctx[m_nMyContextid];

start:
    EXEC SQL AT :db_link_name ALLOCATE :blob;


    lvr = (long_varraw *)malloc(sizeof(ub4) + nMsgLen);
    lvr->len = nMsgLen;
    memcpy(lvr->buf,pmsg,nMsgLen);
    EXEC SQL AT :db_link_name LOB WRITE ONE :nMsgLen
        FROM :lvr WITH LENGTH :nMsgLen INTO :blob AT :offset;
    db_ret = sqlca.sqlcode;
    if (conn_error(db_ret))
    {
        iReconnTimes=0;
        bReconn=ConnectDB();
        while(!bReconn)
        {
            iReconnTimes++;
            sleep(iReconnTimes%10);
            bReconn=ConnectDB();
        }
        goto start;
    }

    if( db_ret < 0 || db_ret == 1403 )
    {
        sql_error(sqlca, oraca);
        EXEC SQL AT :db_link_name ROLLBACK;
        EXEC SQL AT :db_link_name FREE :blob;
        free(lvr);
        return DB_ERROR;
    }
    free(lvr);


    EXEC SQL AT :db_link_name EXECUTE
       begin
        Mini_Local_Pkg.SaveFamilyRequestMsg(:nMsgSeq, :nFamilyID,:nSenderID,:nSendTime,:nMsgType,:nMsgLen,:blob,:retcode);
    end;
    END-EXEC;

    EXEC SQL AT :db_link_name FREE :blob;
    EXEC SQL AT :db_link_name COMMIT;

    return DB_SUCCESS;
}

int CDatabaseMini::SetWokuMsgRecvID(uint32 userID, uint8 Type, uint32 recID)
{
    DEF_ORASET;
    EXEC SQL BEGIN DECLARE SECTION;
        unsigned int     recid, userid;
        int             type;
        VARCHAR db_link_name[32];
        int      retcode;
    EXEC SQL END DECLARE SECTION;

    strncpy((char*)db_link_name.arr, m_Connect,32);
    db_link_name.len = (short)strlen((char*)db_link_name.arr);

    recid = recID;
    userid = userID;
    type = Type;
    int db_ret;
    int iReconnTimes;
    bool bReconn;

    EXEC SQL CONTEXT USE :m_ctx[m_nMyContextid];
start:

    EXEC SQL AT :db_link_name EXECUTE
       begin
        Mini_Local_Pkg.SetWokuMsgRecvID(:userid,:type,:recid,:retcode);
    end;
    END-EXEC;
    db_ret = sqlca.sqlcode;
    if (conn_error(db_ret))
    {
        iReconnTimes=0;
        bReconn=ConnectDB();
        while(!bReconn)
        {
            iReconnTimes++;
            sleep(iReconnTimes%10);
            bReconn=ConnectDB();
        }
        goto start;
    }

    if (db_ret < 0 || db_ret == 1403)
    {
        sql_error(sqlca, oraca);
        return DB_ERROR;
    }
    return DB_SUCCESS;
}

int CDatabaseMini::GetWokuMsgID(uint32 userID,uint32 &nOperationID,uint32 &nUserMsgID,uint32 &nSysMsgID,uint32 &nBroadcastID,uint32 &nUsercommentID,uint32 &nLogcommentID)
{
    DEF_ORASET;
    EXEC SQL BEGIN DECLARE SECTION;
        unsigned int     userid,OperationID,UserMsgID,SysMsgID,BroadcastID,UsercommentID,LogcommentID;
        VARCHAR db_link_name[32];
        int      retcode;
    EXEC SQL END DECLARE SECTION;

    strncpy((char*)db_link_name.arr, m_Connect,32);
    db_link_name.len = (short)strlen((char*)db_link_name.arr);

    userid = userID;
    int db_ret;
    int iReconnTimes;
    bool bReconn;

    EXEC SQL CONTEXT USE :m_ctx[m_nMyContextid];
start:
    EXEC SQL AT :db_link_name EXECUTE
       begin
        Mini_Local_Pkg.GetWokuMsgID(:userid,:OperationID,:UserMsgID,:SysMsgID,:BroadcastID,:UsercommentID,:LogcommentID,:retcode);
    end;
    END-EXEC;
    db_ret = sqlca.sqlcode;
    if (conn_error(db_ret))
    {
        iReconnTimes=0;
        bReconn=ConnectDB();
        while(!bReconn)
        {
            iReconnTimes++;
            sleep(iReconnTimes%10);
            bReconn=ConnectDB();
        }
        goto start;
    }

    if ((db_ret < 0 && db_ret != -1405)|| db_ret == 1403)
    {
        sql_error(sqlca, oraca);
        return DB_ERROR;
    }
    if(retcode != 1403)
    {
        nOperationID = OperationID;
        nUserMsgID = UserMsgID;
        nSysMsgID = SysMsgID;
        nBroadcastID = BroadcastID;
        nUsercommentID = UsercommentID;
        nLogcommentID = LogcommentID;
    }
    return DB_SUCCESS;
}

/* 获取WEBIM互通消息(及离线消息) */
/*
int  CDatabaseMini::Get_WebIM_Msg(int ServerNo,ST_WEBIM_MSG *pWebIMMsg, uint16 &nRetCount)
{
    DEF_ORASET;
    EXEC SQL BEGIN DECLARE SECTION;
        int v_serverno;
        unsigned long v_msgid;
        unsigned int v_receiver, v_sender, v_sendtime, v_msglen, v_reqcount;
        unsigned int amt,offset, bufsize = MAX_MSG_LEN;
        short  v_msgtype;
        long_varraw *lvr;
        OCIBlobLocator *blob;
        varchar v_sendername[41], v_text[1401];
        varchar db_link_name[32];
    EXEC SQL END DECLARE SECTION;

    SET_INIT_NULL(db_link_name);

    strncpy((char*)db_link_name.arr, m_Connect,32);
    db_link_name.len = (short)strlen((char*)db_link_name.arr);

    v_serverno = ServerNo;
    v_reqcount = nRetCount;

    int db_ret;
    int iReconnTimes;
    bool bReconn;

    EXEC SQL CONTEXT USE :m_ctx[m_nMyContextid];
    EXEC SQL AT :db_link_name ALLOCATE :blob;

start:

    EXEC SQL AT :db_link_name DECLARE cur_webimmsg CURSOR FOR
       select t1.MsgId,t1.Receiver,t1.Sender,
       (cast(cast(t1.SendTime as timestamp) at time zone 'gmt' as date)-to_date('19700101 00:00:00','yyyymmdd hh24:mi:ss'))*24*60*60 as SendTime,
       t1.MsgType,t1.MsgLen,t1.Msg,t1.SenderName,t1.Text
       from IM_OFFLINETALKMSG t1, IM_USERONLINE t2
       where t2.ServerNo=:v_serverno and t2.status=1 and t1.Receiver=t2.UserId
       and rownum <= :v_reqcount
       order by t1.Receiver,t1.MsgId;
    EXEC SQL OPEN cur_webimmsg;

    db_ret = sqlca.sqlcode;
    if (conn_error(db_ret))
    {
        EXEC SQL CLOSE cur_webimmsg;
        iReconnTimes=0;
        bReconn=ConnectDB();
        while(!bReconn)
        {
            iReconnTimes++;
            sleep(iReconnTimes%10);
            bReconn=ConnectDB();
        }
        goto start;
    }

    if( db_ret < 0 && db_ret != -1405)
    {
        sql_error(sqlca, oraca);
        EXEC SQL CLOSE cur_webimmsg;
        return DB_ERROR;
    }

    db_ret = sqlca.sqlcode;
    if (conn_error(db_ret))
    {
        EXEC SQL CLOSE cur_webimmsg;
        iReconnTimes=0;
        bReconn=ConnectDB();
        while(!bReconn)
        {
            iReconnTimes++;
            sleep(iReconnTimes%10);
            bReconn=ConnectDB();
        }
        goto start;
    }

    if (db_ret < 0)
    {
        sql_error(sqlca, oraca);
        EXEC SQL AT :db_link_name FREE :blob;
        EXEC SQL CLOSE cur_webimmsg;
        return DB_ERROR;
    }

    lvr = (long_varraw *)malloc(sizeof(unsigned int) + bufsize);
    lvr->len = bufsize;

    int iNum = 0;

    for(;;)
    {
        amt = 0;
        offset = 1;
        bufsize = MAX_MSG_LEN;

        SET_INIT_NULL(v_sendername);
        SET_INIT_NULL(v_text);

        EXEC SQL FETCH cur_webimmsg INTO
        :v_msgid, :v_receiver, :v_sender, :v_sendtime,:v_msgtype,:v_msglen,:blob, :v_sendername, :v_text;

        db_ret = sqlca.sqlcode;
        if (( db_ret < 0  && db_ret != -1405)|| db_ret == 1403 || iNum >= nRetCount)
        {
            if (db_ret != 1403)
                sql_error(sqlca, oraca);
            EXEC SQL AT :db_link_name FREE :blob;
            EXEC SQL CLOSE cur_webimmsg;
            free(lvr);
            EXEC SQL AT :db_link_name COMMIT;
            nRetCount = iNum;
            return DB_SUCCESS;
        }

        pWebIMMsg[iNum].msgid   = v_msgid;
        pWebIMMsg[iNum].recvID  = v_receiver;
        pWebIMMsg[iNum].sendID  = v_sender;
        pWebIMMsg[iNum].tm      = (unsigned int)v_sendtime;
        pWebIMMsg[iNum].msgtype = (unsigned short)v_msgtype;
        pWebIMMsg[iNum].msglen  = v_msglen;
        strncpy(pWebIMMsg[iNum].from_nickname, (char*)v_sendername.arr, MAX_NICKNAME_LEN+1);
        strncpy(pWebIMMsg[iNum].msgtext, (char*)v_text.arr, MAX_MSG_LEN);

        if(v_msglen > 0)
        {
            EXEC SQL AT :db_link_name LOB READ :amt FROM :blob AT :offset INTO :lvr WITH LENGTH :v_msglen;
            if (sqlca.sqlcode == 1403 )
            {
                memcpy((char*)pWebIMMsg[iNum].msg,lvr->buf,v_msglen);
            }
        }
        ++iNum;

        EXEC SQL AT :db_link_name insert into
        IM_OFFLINETALKMSG_ARC (
                msgid,receiver,sender,srcip,srcport,sendtime,msgtype,msglen,msg,
                receivername,sendername,readtime,status,text)
            select
                msgid,receiver,sender,srcip,srcport,sendtime,msgtype,msglen,msg,
                receivername,sendername,sysdate,1,text
            from IM_OFFLINETALKMSG where msgid=:v_msgid;
        EXEC SQL AT :db_link_name delete from IM_OFFLINETALKMSG where msgid=:v_msgid;
#ifdef ACCESS_SERVER        
        LPONLINE_USER_INFO lpUser = CAppManager::GetInstance().GetAppNetWork().FindOnlineUser(v_receiver);
        if(lpUser == NULL)
        {
#else
		BOOL bExit = CAppManager::GetInstance().GetAppNetWork().FindOnlineUser(m_pRouter->GetGlobalBusi(),v_receiver);
        if(!bExit)
        {
#endif
            EXEC SQL AT :db_link_name UPDATE IM_USERONLINE SET STATUS=0 WHERE USERId= :v_receiver;
            db_ret = sqlca.sqlcode;
            if (db_ret < 0 )
            {
                EXEC SQL AT :db_link_name FREE :blob;
                EXEC SQL CLOSE cur_webimmsg;
                free(lvr);
                return DB_ERROR;
            }
        }
    }
    EXEC SQL AT :db_link_name FREE :blob;
    EXEC SQL CLOSE cur_webimmsg;
    free(lvr);
    EXEC SQL AT :db_link_name COMMIT;
    return DB_SUCCESS;
}
*/

// 获取时间段之间的历史消息
int CDatabaseMini::WebHistoryMsg(uint32 nFromID, uint32 nToID, uint32 nStartMsgID, uint32 nStartTime, uint32 nEndTime, uint32 nMaxMsg, uint32& nRetCount, MsgList &lsMsg)
{
	lsMsg.set_ret(0);

	DEF_ORASET;
	EXEC SQL BEGIN DECLARE SECTION;
		VARCHAR	db_link_name[32],var_fontName[50],var_nickName[41],var_data[1315],var_uuid[80];
		unsigned int sid,did,startmsgid,starttime,endtime,msgnum,msgid;
		unsigned int from_id,to_id,send_time,fontSize,fontColor,fontStyle,datatype;
		int	retcode;
		SQL_CURSOR cur_msgInfo;
	EXEC SQL END DECLARE SECTION;

	SET_INIT_NULL(db_link_name);
	
	strncpy((char*)db_link_name.arr, m_Connect,32);
	db_link_name.len = (short)strlen(m_Connect);
	
	sid=nFromID;
	did=nToID;
	startmsgid=nStartMsgID;
	starttime=nStartTime;
	endtime=nEndTime;
	msgnum=nMaxMsg+1;		// 多请求一条数据，用于判断是否所有历史消息都查询完
	
	SET_INIT_NULL(var_fontName);
	SET_INIT_NULL(var_nickName);
	SET_INIT_NULL(var_data);
	SET_INIT_NULL(var_uuid);
  
	int db_ret, iReconnTimes;
	uint32 iNum = 0;	
	bool bReconn;	
	
	EXEC SQL CONTEXT USE :m_ctx[m_nMyContextid];  

start:  
		EXEC SQL ALLOCATE :cur_msgInfo;
		EXEC SQL AT :db_link_name EXECUTE
			begin
				Mini_User_Pkg.WebHistoryMsg(:sid,:did,:startmsgid,:starttime,:endtime,:msgnum,:cur_msgInfo,:retcode);
			end;
		END-EXEC;

		db_ret = sqlca.sqlcode;
		if (conn_error(db_ret))
		{
			EXEC SQL CLOSE :cur_msgInfo;
			iReconnTimes=0;
			bReconn=ConnectDB();
			while(!bReconn)
			{
				iReconnTimes++;
				sleep(iReconnTimes%10);
				bReconn=ConnectDB();
			}
			goto start;				
		}
		
		if(db_ret < 0 && db_ret != -1405) 
		{
			lsMsg.set_ret(1);
			sql_error(sqlca, oraca);		
			EXEC SQL CLOSE :cur_msgInfo;
			EXEC SQL FREE  :cur_msgInfo;
			return DB_ERROR;
		}

		for(;;)
		{  
			EXEC SQL FETCH :cur_msgInfo INTO :from_id,:to_id,:send_time,:fontSize,:fontColor,:fontStyle,:var_fontName,:var_nickName,:var_data,:msgid,:var_uuid,:datatype;
			db_ret = sqlca.sqlcode;
			if (db_ret == 1403 )
			{
				nRetCount = iNum;
				break;
			}
			if (iNum >= nRetCount)
			{
				break;
			}	
			if( db_ret < 0 && db_ret != -1405 )
			{
				sql_error(sqlca, oraca);
				nRetCount = iNum;
				break;
			}	

			if(iNum < nMaxMsg)
			{
				MsgInfo* msginfo = lsMsg.add_msglist();
				msginfo->set_fromid(from_id);
				msginfo->set_toid(to_id);
				msginfo->set_fontsize(fontSize);
				msginfo->set_fontcolor(fontColor);
				msginfo->set_fontstyle(fontStyle);
				msginfo->set_fontname((char*)var_fontName.arr);
				msginfo->set_fromnickname((char*)var_nickName.arr);
				msginfo->set_data((char*)var_data.arr);
				msginfo->set_msgid(msgid);
				msginfo->set_uuid((char*)var_uuid.arr);
				msginfo->set_send_time(send_time);
				msginfo->set_datatype(datatype);
				lsMsg.set_lastmsgid(msgid);
			}
			
			SET_INIT_NULL(var_fontName);
			SET_INIT_NULL(var_nickName);
			SET_INIT_NULL(var_data);
			SET_INIT_NULL(var_uuid);
			
			++iNum;
		}

		SET_END_NULL(var_fontName);
		SET_END_NULL(var_nickName);
		SET_END_NULL(var_data);
		SET_END_NULL(var_uuid);

		if(iNum > nMaxMsg)
		{	// 说明还有后续的历史消息
			lsMsg.set_isend(0);
		}
		else
		{
			lsMsg.set_isend(1);
		}

		CLog::Log("WebHistoryMsg",CLog::TYPE_DEBUG,"查询历史消息条数:%d", iNum);
		
		EXEC SQL CLOSE :cur_msgInfo;
		EXEC SQL FREE  :cur_msgInfo;
		return DB_SUCCESS;		
}





void ForDisableBuildWarningMini()
{
    unsigned int nTest =  sqlstm.sqlvsn;
    nTest++;
}
int CDatabaseMini::Modify_CS_Pwd(uint32 id, char* pwd)
{
    DEF_ORASET;
    EXEC SQL BEGIN DECLARE SECTION;
        VARCHAR var_pwd[61];
        VARCHAR db_link_name[32];
        unsigned int nID;
        int retcode;
    EXEC SQL END DECLARE SECTION;
    nID = id;

    var_pwd.len = (unsigned short)strlen(pwd);
    strncpy((char*)var_pwd.arr,pwd,MAX_PASSWORD_LEN);
    strncpy((char*)db_link_name.arr, m_Connect,32);
    db_link_name.len = (short)strlen((char*)db_link_name.arr);

    int db_ret;
    int iReconnTimes;
    bool bReconn;

    EXEC SQL CONTEXT USE :m_ctx[m_nMyContextid];

start:

    EXEC SQL AT :db_link_name EXECUTE
       begin
        Mini_User_Pkg.ModifyCSPwd(:nID,:var_pwd,:retcode);
    end;
    END-EXEC;
    db_ret = sqlca.sqlcode;
    if (conn_error(db_ret))
    {
        iReconnTimes=0;
        bReconn=ConnectDB();
        while(!bReconn)
        {
            iReconnTimes++;
            sleep(iReconnTimes%10);
            bReconn=ConnectDB();
        }
        goto start;
    }

    if(db_ret == 1403 || db_ret < 0)
    {
        sql_error(sqlca, oraca);
        return DB_ERROR;
    }
    if (retcode == 1)
        return DB_ERROR;

    return DB_SUCCESS;
}
int CDatabaseMini::Import_CS_Req(char *username,int permission,int receptionlimit,char *importname,uint32 &userid,uint32 importtime)
{
    DEF_ORASET;
    EXEC SQL BEGIN DECLARE SECTION;
        VARCHAR var_username[121],var_importname[121];
        int i_permission, i_receptionlimit;
        unsigned int i_userid,i_importtime;
        int retcode;
        VARCHAR db_link_name[32];
    EXEC SQL END DECLARE SECTION;

    strncpy((char*)db_link_name.arr, m_Connect,32);
    db_link_name.len = (short)strlen(m_Connect);

    i_userid = 0;
    i_permission = permission;
    i_receptionlimit =receptionlimit;
    i_importtime = importtime;

    SET_INIT_NULL(var_username);
    SET_INIT_NULL(var_importname);

    strncpy((char*)var_username.arr,username,MAX_USERNAME_LEN);
    var_username.len = (short)strlen((char *)var_username.arr);
    strncpy((char*)var_importname.arr,importname,MAX_USERNAME_LEN);
    var_importname.len = (short)strlen((char *)var_importname.arr);
    int db_ret;
    EXEC SQL CONTEXT USE :m_ctx[m_nMyContextid];
    int iReconnTimes;
    bool bReconn;

start:

    EXEC SQL AT :db_link_name EXECUTE
    begin
      Mini_User_Pkg.ImportCSReq(:var_username,:i_permission,:i_receptionlimit,:var_importname,:i_userid,:i_importtime,:retcode);
    end;
    END-EXEC;

    db_ret = sqlca.sqlcode;
    CLog::Log("Import_CS_Req",CLog::TYPE_IMPORTANT,"i_userid:%d,var_username:%s,i_permission:%d,i_receptionlimit:%d,var_importname:%s,i_importtime:%d,db_ret:%d",
              i_userid,var_importname.arr,i_permission,i_receptionlimit,var_importname.arr,i_importtime,db_ret);
    if (conn_error(db_ret))
    {
        iReconnTimes=0;
        bReconn=ConnectDB();
        while(!bReconn)
        {
            iReconnTimes++;
            sleep(iReconnTimes%10);
            bReconn=ConnectDB();
        }
        goto start;
    }

    if (retcode == 1403 || db_ret == 1403 || db_ret == -1405)
    {
        return DB_NOUSER;
    }

    if (db_ret >= 0)
    {
        CLog::Log("Import_CS_Req",CLog::TYPE_IMPORTANT,"i_userid:%d,db_ret:%d",i_userid,db_ret);
        userid = i_userid;
        SET_END_NULL(var_username);
        SET_END_NULL(var_importname);
        return DB_SUCCESS;
    }
    return DB_ERROR;

}

int CDatabaseMini::Modify_CS_Req(char* username, char* csRealName,int receptionLimit,char *password,uint32& importtime,uint32 csid,int permission)
{
    DEF_ORASET;
    EXEC SQL BEGIN DECLARE SECTION;
        VARCHAR var_username[121];
        VARCHAR var_csRealName[121];
        VARCHAR var_password[64];
        VARCHAR db_link_name[32];
        int i_receptionLimit;
        int i_permission;
        unsigned int i_csid;
        unsigned int i_importtime;
        int retcode;
    EXEC SQL END DECLARE SECTION;

    i_receptionLimit = receptionLimit;
    i_importtime = importtime;
    i_permission = permission;
    i_csid = csid;


    var_username.len = (unsigned short)strlen(username);
    strncpy((char*)var_username.arr,username,MAX_USERNAME_LEN);

    var_csRealName.len = (unsigned short)strlen(csRealName);
    strncpy((char*)var_csRealName.arr,csRealName,MAX_USERNAME_LEN);

    var_password.len = (unsigned short)strlen(password);
    strncpy((char*)var_password.arr,password,MAX_PASSWORD_LEN);

    strncpy((char*)db_link_name.arr, m_Connect,32);
    db_link_name.len = (short)strlen((char*)db_link_name.arr);

    int db_ret;
    int iReconnTimes;
    bool bReconn;

    EXEC SQL CONTEXT USE :m_ctx[m_nMyContextid];

start:

    EXEC SQL AT :db_link_name EXECUTE
       begin
        Mini_User_Pkg.ModifyCSReq(:i_receptionLimit,:var_username,:var_csRealName,:var_password,:i_importtime,:i_csid,:i_permission,:retcode);
    end;
    END-EXEC;
    db_ret = sqlca.sqlcode;
    if (conn_error(db_ret))
    {
        iReconnTimes=0;
        bReconn=ConnectDB();
        while(!bReconn)
        {
            iReconnTimes++;
            sleep(iReconnTimes%10);
            bReconn=ConnectDB();
        }
        goto start;
    }

    if(db_ret == 1403 || db_ret < 0)
    {
        sql_error(sqlca, oraca);
        return DB_ERROR;
    }
    if (retcode == 1)
        return DB_ERROR;
    importtime = i_importtime;

    return DB_SUCCESS;
}


int CDatabaseMini::Modify_CS_Status(char* username, int status)
{
    DEF_ORASET;
    EXEC SQL BEGIN DECLARE SECTION;
        VARCHAR var_username[121],db_link_name[32];
        int i_status,retcode;
    EXEC SQL END DECLARE SECTION;

    i_status = status;
    var_username.len = (unsigned short)strlen(username);
    strncpy((char*)var_username.arr,username,MAX_USERNAME_LEN);

    strncpy((char*)db_link_name.arr, m_Connect,32);
    db_link_name.len = (short)strlen((char*)db_link_name.arr);

    int db_ret;
    int iReconnTimes;
    bool bReconn;

    EXEC SQL CONTEXT USE :m_ctx[m_nMyContextid];

start:

    EXEC SQL AT :db_link_name EXECUTE
       begin
        Mini_User_Pkg.ModifyCSStatusReq(:var_username,:i_status,:retcode);
    end;
    END-EXEC;
    db_ret = sqlca.sqlcode;
    if (conn_error(db_ret))
    {
        iReconnTimes=0;
        bReconn=ConnectDB();
        while(!bReconn)
        {
            iReconnTimes++;
            sleep(iReconnTimes%10);
            bReconn=ConnectDB();
        }
        goto start;
    }

    if(db_ret == 1403 || db_ret < 0)
    {
        sql_error(sqlca, oraca);
        return DB_ERROR;
    }
    if (retcode == 1)
        return DB_ERROR;

    return DB_SUCCESS;
}



int CDatabaseMini::Get_Vaild_CS_List(XT_CS_INFO * CSList, int &nRetCount)
{
    DEF_ORASET;
    EXEC SQL BEGIN DECLARE SECTION;
        VARCHAR CSrealname[121];
        VARCHAR db_link_name[32];
        unsigned int Id=0;
        unsigned int CSId=0;
        int iNum = 0;

        SQL_CURSOR cur_CSlist;
        int retcode;
    EXEC SQL END DECLARE SECTION;

    if (nRetCount <= 0)
        return DB_PARAM;
    strncpy((char*)db_link_name.arr, m_Connect,32);
    db_link_name.len = (short)strlen((char*)db_link_name.arr);

    SET_INIT_NULL(CSrealname);
    int db_ret = 0;
    int iReconnTimes;
    bool bReconn;
    EXEC SQL ALLOCATE :cur_CSlist;
    EXEC SQL CONTEXT USE :m_ctx[m_nMyContextid];


start:

    EXEC SQL AT :db_link_name EXECUTE
       begin
        Mini_User_Pkg.GetVaildCS_20160106(:cur_CSlist,:retcode);
    end;
    END-EXEC;

    db_ret = sqlca.sqlcode;
    if (conn_error(db_ret))
    {
        EXEC SQL CLOSE :cur_CSlist;
        iReconnTimes=0;
        bReconn=ConnectDB();
        while(!bReconn)
        {
            iReconnTimes++;
            sleep(iReconnTimes%10);
            bReconn=ConnectDB();
        }
        goto start;
    }
    CLog::Log("GetVaildCS",CLog::TYPE_IMPORTANT,"db_ret:%d, retcode:%d", db_ret, retcode);

    if(db_ret < 0 && db_ret != -1405)
    {
        sql_error(sqlca, oraca);
        EXEC SQL CLOSE :cur_CSlist;
        EXEC SQL FREE :cur_CSlist;
        return DB_ERROR;
    }


    for(;;)
    {
        EXEC SQL FETCH :cur_CSlist INTO :CSrealname,:Id,:CSId;

        db_ret = sqlca.sqlcode;
        if (db_ret == 1403 )
        {
            nRetCount = iNum;
            break;
        }
        if (iNum >= nRetCount)
        {
            break;
        }
        if( db_ret < 0 && db_ret != -1405 )
        {
            sql_error(sqlca, oraca);
            nRetCount = iNum;
            break;
        }
        SET_END_NULL(CSrealname);
        strncpy(CSList[iNum].realname,(const char *)(CSrealname.arr),MAX_USERNAME_LEN);
        CSList[iNum].id= Id;
        CSList[iNum].csid= CSId;
        CLog::Log("GetVaildCS",CLog::TYPE_IMPORTANT,"iNum:%d,realname:%s", iNum, CSList[iNum].realname);
        ++iNum;

        SET_INIT_NULL(CSrealname);
        Id=0;
        CSId=0;
    }
    EXEC SQL CLOSE :cur_CSlist;
    EXEC SQL FREE  :cur_CSlist;
    return DB_SUCCESS;
}


int CDatabaseMini::Qurery_CS_Info(XT_CS_INFO * CSInfoList,char *username, char *importname, char *realname, int status,uint32 begintime,uint32 endtime,int &nRetCount)
{
    DEF_ORASET;
    EXEC SQL BEGIN DECLARE SECTION;
        VARCHAR CSusername[121];
        VARCHAR CSrealname[121];
        VARCHAR CSimportname[121];
        VARCHAR db_link_name[32];
        int iNum = 0;
        int CSstatus = 0;
        int CSpermission=0;
        int CSreceptionlimit = 0;
        unsigned int CSbegintime=0;
        unsigned int CSendtime=0;
        unsigned int CSimporttime =0;
        SQL_CURSOR cur_CSInfolist;
        int retcode;
    EXEC SQL END DECLARE SECTION;

    if (nRetCount <= 0)
        return DB_PARAM;
    SET_INIT_NULL(CSusername);
    SET_INIT_NULL(CSrealname);
    SET_INIT_NULL(CSimportname);
    strncpy((char*)db_link_name.arr, m_Connect,32);
    db_link_name.len = (short)strlen((char*)db_link_name.arr);

    strncpy((char*)CSusername.arr, username,MAX_USERNAME_LEN);
    CSusername.len = (short)strlen((char*)CSusername.arr);

    strncpy((char*)CSrealname.arr, realname,MAX_USERNAME_LEN);
    CSrealname.len = (short)strlen((char*)CSrealname.arr);

    strncpy((char*)CSimportname.arr, importname,MAX_USERNAME_LEN);
    CSimportname.len = (short)strlen((char*)CSimportname.arr);
    CSstatus = status;
    CSbegintime = begintime;
    CSendtime = endtime;
    CLog::Log("QureryCSInfo",CLog::TYPE_IMPORTANT,"username:%s,realname:%s,importname:%s,status:%d,CSbegintime:%d,CSendtime:%d",
              (char*)CSusername.arr,(char*)CSrealname.arr,(char*)CSimportname.arr,CSstatus,CSbegintime,CSendtime);


    int db_ret = 0;
    int iReconnTimes;
    bool bReconn;
    EXEC SQL ALLOCATE :cur_CSInfolist;
    EXEC SQL CONTEXT USE :m_ctx[m_nMyContextid];


start:


    EXEC SQL AT :db_link_name EXECUTE
       begin
        Mini_User_Pkg.QureryCSInfo(:cur_CSInfolist,:CSusername,:CSimportname,:CSrealname,:CSstatus,:CSbegintime,:CSendtime,:retcode);
    end;
    END-EXEC;

    db_ret = sqlca.sqlcode;
    if (conn_error(db_ret))
    {
        EXEC SQL CLOSE :cur_CSInfolist;
        iReconnTimes=0;
        bReconn=ConnectDB();
        while(!bReconn)
        {
            iReconnTimes++;
            sleep(iReconnTimes%10);
            bReconn=ConnectDB();
        }
        goto start;
    }
    CLog::Log("QureryCSInfo",CLog::TYPE_IMPORTANT,"CSusername:%s,db_ret:%d, retcode:%d", CSusername.arr,db_ret, retcode);

    if(db_ret < 0 && db_ret != -1405)
    {
        sql_error(sqlca, oraca);
        EXEC SQL CLOSE :cur_CSInfolist;
        EXEC SQL FREE :cur_CSInfolist;
        return DB_ERROR;
    }


    for(;;)
    {

        EXEC SQL FETCH :cur_CSInfolist INTO :CSusername,:CSpermission,:CSimportname,:CSimporttime,:CSrealname,:CSstatus,:CSreceptionlimit;

        db_ret = sqlca.sqlcode;
        CLog::Log("QureryCSInfo",CLog::TYPE_IMPORTANT,"db_ret:%d", db_ret);
        if (db_ret == 1403 )
        {
            nRetCount = iNum;
            break;
        }
        if (iNum >= nRetCount)
        {
            CLog::Log("QureryCSInfo",CLog::TYPE_IMPORTANT,"iNum:%d",iNum);
            break;
        }
        if( db_ret < 0 && db_ret != -1405 )
        {
            sql_error(sqlca, oraca);
            nRetCount = iNum;
            CLog::Log("QureryCSInfo",CLog::TYPE_IMPORTANT,"db_ret:%d",db_ret);
            break;
        }

        SET_END_NULL(CSusername);
        SET_END_NULL(CSrealname);
        SET_END_NULL(CSimportname);

        if (CSusername.len > 0)
            strncpy(CSInfoList[iNum].username,(const char *)(CSusername.arr),MAX_USERNAME_LEN);
        CSInfoList[iNum].permission = CSpermission;
        if (CSimportname.len > 0)
            strncpy(CSInfoList[iNum].importname,(const char *)(CSimportname.arr),MAX_USERNAME_LEN);

        CSInfoList[iNum].importtime = CSimporttime;
        if (CSrealname.len > 0)
            strncpy(CSInfoList[iNum].realname,(const char *)(CSrealname.arr),MAX_USERNAME_LEN);

        CSInfoList[iNum].status = CSstatus;
        CSInfoList[iNum].receptionlimit = CSreceptionlimit;


        CLog::Log("QureryCSInfo",CLog::TYPE_IMPORTANT,"iNum:%d,username:%s,permission:%d,importname:%s,importtime:%d,realname:%s,status:%d,receptionlimit:%d",
                  iNum, CSInfoList[iNum].username,CSInfoList[iNum].permission,CSInfoList[iNum].importname,CSInfoList[iNum].importtime,CSInfoList[iNum].realname,CSInfoList[iNum].status,CSInfoList[iNum].receptionlimit);
        ++iNum;
    }
    EXEC SQL CLOSE :cur_CSInfolist;
    EXEC SQL FREE  :cur_CSInfolist;
    return DB_SUCCESS;
}

int CDatabaseMini::CS_Get_Group_Account(uint32 groupId,vector<uint32> &userlist )
{
    DEF_ORASET;
    EXEC SQL BEGIN DECLARE SECTION;
        unsigned int nGroupId;
        unsigned int n_UserNode;
        VARCHAR db_link_name[32];
        int retcode;
        SQL_CURSOR cur_cliInfo;
    EXEC SQL END DECLARE SECTION;


    nGroupId=groupId;


    int db_ret, iReconnTimes;
    uint32 iNum = 0;
    bool bReconn;

    strncpy((char*)db_link_name.arr, m_Connect,32);
    db_link_name.len = (short)strlen((char*)db_link_name.arr);

    EXEC SQL CONTEXT USE :m_ctx[m_nMyContextid];

start:
    EXEC SQL ALLOCATE :cur_cliInfo;
    EXEC SQL AT :db_link_name EXECUTE
    begin
      Mini_User_Pkg.GetCSGroupMemFlow(:nGroupId,:cur_cliInfo,:retcode);
    end;
    END-EXEC;

    db_ret = sqlca.sqlcode;
    if (conn_error(db_ret))
    {
        EXEC SQL CLOSE :cur_cliInfo;
        iReconnTimes=0;
        bReconn=ConnectDB();
        while(!bReconn)
        {
            iReconnTimes++;
            sleep(iReconnTimes%10);
            bReconn=ConnectDB();
        }
        goto start;
    }
    CLog::Log("CS_Get_Group_Account",CLog::TYPE_DEBUG,"id:%d, db_ret:%d, retcode:%d ",nGroupId, db_ret, retcode);

    if(db_ret < 0 && db_ret != -1405)
    {
        sql_error(sqlca, oraca);
        EXEC SQL CLOSE :cur_cliInfo;
        EXEC SQL FREE  :cur_cliInfo;
        return DB_ERROR;
    }

    for(;;)
    {
        EXEC SQL FETCH :cur_cliInfo INTO :n_UserNode;
        db_ret = sqlca.sqlcode;
        if (db_ret == 1403 )
        {
            break;
        }
        if( db_ret < 0 && db_ret != -1405 )
        {
            sql_error(sqlca, oraca);
            break;
        }
        // userlist[iNum] = n_UserNode;
        userlist.push_back(n_UserNode);
        ++iNum;
    }
    EXEC SQL CLOSE :cur_cliInfo;
    EXEC SQL FREE  :cur_cliInfo;
    return DB_SUCCESS;
}

int CDatabaseMini::CS_Get_Groups(uint32 userid,vector<uint32> &groups )
{
    DEF_ORASET;
    EXEC SQL BEGIN DECLARE SECTION;
        unsigned int nUserId;
        unsigned int n_GroupNode;
        VARCHAR db_link_name[32];
        int retcode;
        SQL_CURSOR cur_cliInfo;
    EXEC SQL END DECLARE SECTION;


    nUserId=userid;


    int db_ret, iReconnTimes;
    uint32 iNum = 0;
    bool bReconn;

    strncpy((char*)db_link_name.arr, m_Connect,32);
    db_link_name.len = (short)strlen((char*)db_link_name.arr);

    EXEC SQL CONTEXT USE :m_ctx[m_nMyContextid];

start:
    EXEC SQL ALLOCATE :cur_cliInfo;
    EXEC SQL AT :db_link_name EXECUTE
    begin
      Mini_User_Pkg.GetCSGroups(:nUserId,:cur_cliInfo,:retcode);
    end;
    END-EXEC;

    db_ret = sqlca.sqlcode;
    if (conn_error(db_ret))
    {
        EXEC SQL CLOSE :cur_cliInfo;
        iReconnTimes=0;
        bReconn=ConnectDB();
        while(!bReconn)
        {
            iReconnTimes++;
            sleep(iReconnTimes%10);
            bReconn=ConnectDB();
        }
        goto start;
    }
    CLog::Log("CS_Get_Groups",CLog::TYPE_DEBUG,"id:%d, db_ret:%d, retcode:%d ",nUserId, db_ret, retcode);

    if(db_ret < 0 && db_ret != -1405)
    {
        sql_error(sqlca, oraca);
        EXEC SQL CLOSE :cur_cliInfo;
        EXEC SQL FREE  :cur_cliInfo;
        return DB_ERROR;
    }

    for(;;)
    {
        EXEC SQL FETCH :cur_cliInfo INTO :n_GroupNode;
        db_ret = sqlca.sqlcode;
        if (db_ret == 1403 )
        {
            break;
        }
        if( db_ret < 0 && db_ret != -1405 )
        {
            sql_error(sqlca, oraca);
            break;
        }
        // userlist[iNum] = n_UserNode;
        groups.push_back(n_GroupNode);
        ++iNum;
    }
    EXEC SQL CLOSE :cur_cliInfo;
    EXEC SQL FREE  :cur_cliInfo;
    return DB_SUCCESS;
}


int CDatabaseMini::CS_Get_RecptionLimit(uint32 iUserID,uint32 &RecpLimit)
{
    DEF_ORASET;
    EXEC SQL BEGIN DECLARE SECTION;
        unsigned int      n_iUserID,n_RecpLimit;
        int  retcode;
        VARCHAR db_link_name[32];
    EXEC SQL END DECLARE SECTION;

    n_iUserID=iUserID;
    strncpy((char*)db_link_name.arr, m_Connect,32);
    db_link_name.len = (short)strlen((char*)db_link_name.arr);
    int db_ret;
    int iReconnTimes;
    bool bReconn;
    EXEC SQL CONTEXT USE :m_ctx[m_nMyContextid];

start:
    EXEC SQL AT :db_link_name EXECUTE
       begin
        Mini_User_Pkg.GetCSRecpLimit(:n_iUserID,:n_RecpLimit,:retcode);
    end;
    END-EXEC;

    db_ret = sqlca.sqlcode;
    if (conn_error(db_ret))
    {
        iReconnTimes=0;
        bReconn=ConnectDB();
        while(!bReconn)
        {
            iReconnTimes++;
            sleep(iReconnTimes%10);
            bReconn=ConnectDB();
        }
        goto start;
    }
    CLog::Log("CS_Get_RecptionLimit",CLog::TYPE_DEBUG,"id:%d, db_ret:%d, retcode:%d ",iUserID, db_ret, retcode);

    if(db_ret == 1403 || db_ret < 0)
    {
        sql_error(sqlca, oraca);
        return DB_ERROR;
    }
    if (retcode == 1)
        return DB_ERROR;

    RecpLimit = n_RecpLimit;
    return DB_SUCCESS;
}


int CDatabaseMini::CS_Get_Group_Friend(uint32 iUserID,vector<csTeam_t>&teamInfo)
{
    DEF_ORASET;
    EXEC SQL BEGIN DECLARE SECTION;
        unsigned int niUserID;
        unsigned int nFriendId,nTeamId;
        int nPermission;
        int retcode;
        SQL_CURSOR cur_cliInfo;
        VARCHAR db_link_name[32];
    EXEC SQL END DECLARE SECTION;

    csTeam_t csTeamInfo;
    niUserID=iUserID;

    int db_ret, iReconnTimes;
    uint32 iNum = 0;
    bool bReconn;

    strncpy((char*)db_link_name.arr, m_Connect,32);
    db_link_name.len = (short)strlen((char*)db_link_name.arr);

    EXEC SQL CONTEXT USE :m_ctx[m_nMyContextid];

start:
    EXEC SQL ALLOCATE :cur_cliInfo;
    EXEC SQL AT :db_link_name EXECUTE
    begin
      Mini_User_Pkg.GetCSFriend(:niUserID,:cur_cliInfo,:retcode);
    end;
    END-EXEC;

    db_ret = sqlca.sqlcode;
    if (conn_error(db_ret))
    {
        EXEC SQL CLOSE :cur_cliInfo;
        iReconnTimes=0;
        bReconn=ConnectDB();
        while(!bReconn)
        {
            iReconnTimes++;
            sleep(iReconnTimes%10);
            bReconn=ConnectDB();
        }
        goto start;
    }
    CLog::Log("CS_Get_Group_Friend",CLog::TYPE_DEBUG,"id:%d, db_ret:%d, retcode:%d ",iUserID, db_ret, retcode);

    if(db_ret < 0 && db_ret != -1405)
    {
        sql_error(sqlca, oraca);
        EXEC SQL CLOSE :cur_cliInfo;
        EXEC SQL FREE  :cur_cliInfo;
        return DB_ERROR;
    }

    for(;;)
    {
        EXEC SQL FETCH :cur_cliInfo INTO :nFriendId,:nTeamId,:nPermission;
        db_ret = sqlca.sqlcode;
        if (db_ret == 1403 )
        {
            break;
        }

        if( db_ret < 0 && db_ret != -1405 )
        {
            sql_error(sqlca, oraca);
            break;
        }
        memset(&csTeamInfo,0,sizeof(csTeam_t));
        csTeamInfo.teamid = nTeamId;
        csTeamInfo.userid = nFriendId;
        csTeamInfo.team_permission = nPermission;
        teamInfo.push_back(csTeamInfo);
        // teamInfo[iNum].teamid = nTeamId;
        // teamInfo[iNum].userid = nFriendId;

        ++iNum;
    }
    EXEC SQL CLOSE :cur_cliInfo;
    EXEC SQL FREE  :cur_cliInfo;
    return DB_SUCCESS;
}

int CDatabaseMini::Get_CS_Info(uint32 iUserID, XT_SERVER_CS_GET_ACK &lpAck)
{
    DEF_ORASET;
    EXEC SQL BEGIN DECLARE SECTION;
        unsigned int nUserID;
        VARCHAR  var_username[121];
        VARCHAR db_link_name[32];
        int var_state,var_maxRecConsult,var_permission;
        int retcode;


    EXEC SQL END DECLARE SECTION;
    SET_INIT_NULL(var_username);

    var_state = 0;
    var_maxRecConsult = 0;
    var_permission = 0;
    retcode = 0;

    strncpy((char*)db_link_name.arr, m_Connect,32);
    db_link_name.len = (short)strlen((char*)db_link_name.arr);

    nUserID = iUserID;
    int db_ret;
    EXEC SQL CONTEXT USE :m_ctx[m_nMyContextid];
    int iReconnTimes;
    bool bReconn;

start:
    EXEC SQL AT :db_link_name EXECUTE
       begin
        Mini_User_Pkg.GetCSInfo(:nUserID,:var_username,:var_state,:var_maxRecConsult,:var_permission,:retcode);
    end;
    END-EXEC;

    SET_END_NULL(var_username);

    db_ret = sqlca.sqlcode;
    if (conn_error(db_ret))
    {
        iReconnTimes=0;
        bReconn=ConnectDB();
        while(!bReconn)
        {
            iReconnTimes++;
            sleep(iReconnTimes%10);
            bReconn=ConnectDB();
        }
        goto start;
    }

    CLog::Log("CDatabaseWeb::Get_CS_Info", CLog::TYPE_IMPORTANT, "id:%d, db_ret:%d, retcode:%d",nUserID, db_ret, retcode);

    if (db_ret == 1403 || retcode == 1403)
    {
        return DB_NOUSER;
    }

    if( db_ret < 0 && db_ret != -1405)
    {
        sql_error(sqlca, oraca);
        return DB_ERROR;
    }

    lpAck.m_nID     = nUserID;  // 0 用户id
    strncpy(lpAck.m_CSname, (char*)var_username.arr,MAX_USERNAME_LEN) ; // 3 用户名

    lpAck.m_State   = var_state;
    lpAck.m_MaxRecConsult   = var_maxRecConsult;
    lpAck.m_permission = var_permission;

    return DB_SUCCESS;
}


int CDatabaseMini::WebLastMsgReq(XT_WEB_BUSI_LAST_MSG_REQ* msgReq,XT_WEB_BUSI_LAST_MSG_ACK::BusiLastList * msgInfo,uint32& nRetCount)
{
    DEF_ORASET;
    EXEC SQL BEGIN DECLARE SECTION;
        VARCHAR db_link_name[32],var_nickName[41];
        VARCHAR var_lastMsg[1315];
        unsigned int sid,msgnum,subAccountID,lastMsgTime;
        int retcode;
        SQL_CURSOR cur_msgInfo;
    EXEC SQL END DECLARE SECTION;


    strncpy((char*)db_link_name.arr, m_Connect,32);
    db_link_name.len = (short)strlen(m_Connect);

    sid=msgReq->id;
    msgnum=msgReq->msgnum;

    SET_INIT_NULL(var_nickName);
    SET_INIT_NULL(var_lastMsg);

    int db_ret, iReconnTimes;
    uint32 iNum = 0;
    bool bReconn;

    EXEC SQL CONTEXT USE :m_ctx[m_nMyContextid];

start:
    EXEC SQL ALLOCATE :cur_msgInfo;
    EXEC SQL AT :db_link_name EXECUTE
    begin
      Mini_User_Pkg.WebLastMsgReq(:sid,:msgnum,:cur_msgInfo,:retcode);
    end;
    END-EXEC;

    db_ret = sqlca.sqlcode;
    if (conn_error(db_ret))
    {
        EXEC SQL CLOSE :cur_msgInfo;
        iReconnTimes=0;
        bReconn=ConnectDB();
        while(!bReconn)
        {
            iReconnTimes++;
            sleep(iReconnTimes%10);
            bReconn=ConnectDB();
        }
        goto start;
    }

    if(db_ret < 0 && db_ret != -1405)
    {
        sql_error(sqlca, oraca);
        EXEC SQL CLOSE :cur_msgInfo;
        EXEC SQL FREE  :cur_msgInfo;
        return DB_ERROR;
    }


    for(;;)
    {
        EXEC SQL FETCH :cur_msgInfo INTO :subAccountID,:lastMsgTime,:var_nickName,:var_lastMsg;
        db_ret = sqlca.sqlcode;
        if (db_ret == 1403 )
        {
            nRetCount = iNum;
            break;
        }
        if (iNum >= nRetCount)
        {
            break;
        }
        if( db_ret < 0 && db_ret != -1405 )
        {
            sql_error(sqlca, oraca);
            nRetCount = iNum;
            break;
        }
        msgInfo[iNum].subAccountID = subAccountID;
        msgInfo[iNum].lastMsgTime = lastMsgTime;

        SET_END_NULL(var_lastMsg);
        SET_END_NULL(var_nickName);

        strncpy(msgInfo[iNum].nickname,(char*)var_nickName.arr,MAX_NICKNAME_LEN+1);
        strncpy(msgInfo[iNum].lastMsg,(char*)var_lastMsg.arr,1315);

        ++iNum;
    }
    EXEC SQL CLOSE :cur_msgInfo;
    EXEC SQL FREE  :cur_msgInfo;
    return DB_SUCCESS;
}

int CDatabaseMini::Get_Userid_Map_CSid(uint32 userid,uint32 &csid)
{
    DEF_ORASET;
    EXEC SQL BEGIN DECLARE SECTION;
        unsigned int iuserid,icsid;
        int retcode;
        VARCHAR db_link_name[32];
    EXEC SQL END DECLARE SECTION;

    iuserid=userid;

    int db_ret, iReconnTimes;
    bool bReconn;

    strncpy((char*)db_link_name.arr, m_Connect,32);
    db_link_name.len = (short)strlen((char*)db_link_name.arr);

    EXEC SQL CONTEXT USE :m_ctx[m_nMyContextid];

start:
    EXEC SQL AT :db_link_name EXECUTE
    begin
      Mini_User_Pkg.getUseridMapCSid(:iuserid,:icsid,:retcode);
    end;
    END-EXEC;

    db_ret = sqlca.sqlcode;
    if (conn_error(db_ret))
    {
        iReconnTimes=0;
        bReconn=ConnectDB();
        while(!bReconn)
        {
            iReconnTimes++;
            sleep(iReconnTimes%10);
            bReconn=ConnectDB();
        }
        goto start;
    }
    CLog::Log("Get_Userid_Map_CSid",CLog::TYPE_DEBUG,"userid:%d, csid:%d, db_ret:%d, retcode:%d ",iuserid, icsid, db_ret, retcode);

    if(db_ret == 1403 || db_ret < 0)
    {
        sql_error(sqlca, oraca);
        return DB_ERROR;
    }
    if (retcode == 1)
        return DB_ERROR;

    csid = icsid;
    return DB_SUCCESS;
}
/*
// 插入一条消息推送数据
int CDatabaseMini::InsertMsgNotify(const char *pUuid, const std::vector<uint32> &vecUserID, const string &buffer, int nBufferType)
{
    DEF_ORASET;
    EXEC SQL BEGIN DECLARE SECTION;
        VARCHAR db_link_name[32];
        VARCHAR uuid[60];
        OCIBlobLocator *blob_buffer;
        int NewCharbufLen;
        int ClobLen, WriteAmt, Offset;
        unsigned char NewCharbuf[5000];
        EXEC SQL VAR NewCharbuf IS RAW(5000) ;
        int userid;
        int buftype;
    EXEC SQL END DECLARE SECTION;


    strncpy((char*)db_link_name.arr, m_Connect,32);
    db_link_name.len = (short)strlen(m_Connect);

    SET_INIT_NULL(uuid);
    strncpy((char*)uuid.arr, pUuid, strlen(pUuid));
    uuid.len = (short)strlen(pUuid);

    buftype = nBufferType;

    int db_ret;

    EXEC SQL AT :db_link_name ALLOCATE :blob_buffer;

    // 写入表IM_MSGNOTIFY
    // 先插入空的blob
    EXEC SQL AT :db_link_name INSERT INTO IM_MSGNOTIFY(UUID,BUF,BUFFTYPE) VALUES (:uuid, empty_blob(), :buftype);
    db_ret = sqlca.sqlcode;
    if(db_ret == 1403 || db_ret < 0)
    {
        sql_error(sqlca, oraca);
        EXEC SQL AT :db_link_name FREE :blob_buffer;
        EXEC SQL AT :db_link_name ROLLBACK;
        return DB_ERROR;
    }

	EXEC SQL AT :db_link_name COMMIT;

    // 再写入blob
    EXEC SQL AT :db_link_name SELECT BUF INTO :blob_buffer FROM IM_MSGNOTIFY WHERE UUID = :uuid FOR UPDATE;
    db_ret = sqlca.sqlcode;
    if(db_ret == 1403 || db_ret < 0)
    {
        sql_error(sqlca, oraca);
        EXEC SQL AT :db_link_name FREE :blob_buffer;
        EXEC SQL AT :db_link_name ROLLBACK;
        return DB_ERROR;
    }

    NewCharbufLen = buffer.length();
    memcpy(NewCharbuf, buffer.c_str(), NewCharbufLen);

    WriteAmt = NewCharbufLen;
    Offset = 1;
    EXEC SQL AT :db_link_name LOB WRITE ONE :WriteAmt FROM :NewCharbuf
      WITH LENGTH :NewCharbufLen INTO :blob_buffer AT :Offset;
    db_ret = sqlca.sqlcode;
    if(db_ret == 1403 || db_ret < 0)
    {
        sql_error(sqlca, oraca);
        EXEC SQL AT :db_link_name FREE :blob_buffer;
        EXEC SQL AT :db_link_name ROLLBACK;
        return db_ret;
    }

    // 写入表IM_USER_WITH_MSGNOTIFY
    for(int i = 0; i < (int)vecUserID.size(); ++i)
    {
        userid = (int)vecUserID[i];
        EXEC SQL AT :db_link_name INSERT INTO IM_USER_WITH_MSGNOTIFY VALUES (:userid, :uuid);
        db_ret = sqlca.sqlcode;
        if(db_ret == 1403 || db_ret < 0)
        {
            sql_error(sqlca, oraca);
            EXEC SQL AT :db_link_name FREE :blob_buffer;
            EXEC SQL AT :db_link_name ROLLBACK;
            return db_ret;
        }
    }

	EXEC SQL AT :db_link_name FREE :blob_buffer;
    EXEC SQL AT :db_link_name COMMIT;    

    return DB_SUCCESS;
}

// 删除一条记录
int CDatabaseMini::DeleteMsgNotify(const char *pUuid, uint32 userid)
{
	DEF_ORASET;
    EXEC SQL BEGIN DECLARE SECTION;
        VARCHAR db_link_name[32];
        unsigned int t_userid;
        VARCHAR uuid[60];
        int retcode;
    EXEC SQL END DECLARE SECTION;

    SET_INIT_NULL(db_link_name);
    strncpy((char*)db_link_name.arr, m_Connect,32);
    db_link_name.len = (short)strlen(m_Connect);

    SET_INIT_NULL(uuid);
    strncpy((char*)uuid.arr, pUuid,strlen(pUuid));
    uuid.len = (short)strlen(pUuid);

    t_userid=userid;

    int db_ret, iReconnTimes;
    uint32 iNum = 0;
    bool bReconn;

    EXEC SQL CONTEXT USE :m_ctx[m_nMyContextid];

start:
    EXEC SQL AT :db_link_name EXECUTE
    begin
      Mini_User_Pkg.DeleteOneMsgNotify(:t_userid,:uuid,:retcode);
    end;
    END-EXEC;

    db_ret = sqlca.sqlcode;
    if (conn_error(db_ret))
    {
        iReconnTimes=0;
        bReconn=ConnectDB();
        while(!bReconn)
        {
            iReconnTimes++;
            sleep(iReconnTimes%10);
            bReconn=ConnectDB();
        }
        goto start;
    }

    if(db_ret < 0 && db_ret != -1405)
    {
        sql_error(sqlca, oraca);
        return DB_ERROR;
    }

    return DB_SUCCESS;
}

// 查询推送消息数据
int CDatabaseMini::SearchMsgNotify(const char *pUuid, std::string &buffer, int &nBufferType)
{
    DEF_ORASET;
    EXEC SQL BEGIN DECLARE SECTION;
        VARCHAR db_link_name[32];
        VARCHAR uuid[60];
        OCIBlobLocator *blob_buffer;
        int NewCharbufLen;
        int ClobLen, amt;
        unsigned char NewCharbuf[5000];
        EXEC SQL VAR NewCharbuf IS RAW(5000) ;
        int buftype;
    EXEC SQL END DECLARE SECTION;

    strncpy((char*)db_link_name.arr, m_Connect,32);
    db_link_name.len = (short)strlen(m_Connect);

    SET_INIT_NULL(uuid);
    strncpy((char*)uuid.arr, pUuid, strlen(pUuid));
    uuid.len = (short)strlen(pUuid);

    buftype = nBufferType;

    int db_ret;

    EXEC SQL AT :db_link_name ALLOCATE :blob_buffer;

    // 写入表IM_MSGNOTIFY
    EXEC SQL AT :db_link_name SELECT BUF,BUFFTYPE INTO :blob_buffer, :buftype
    FROM IM_MSGNOTIFY WHERE UUID = :uuid;

    EXEC SQL AT :db_link_name LOB DESCRIBE :blob_buffer GET LENGTH INTO :ClobLen;

    if(ClobLen == 0)
    {
        EXEC SQL AT :db_link_name FREE :blob_buffer;
        return DB_ERROR;
    }
    else
    {
        amt = ClobLen;

        EXEC SQL WHENEVER NOT FOUND CONTINUE;
        EXEC SQL AT :db_link_name LOB READ :amt
          FROM :blob_buffer INTO :NewCharbuf WITH LENGTH :ClobLen;

        buffer.assign((char*)NewCharbuf, ClobLen);
        nBufferType = buftype;
    }

    EXEC SQL AT :db_link_name FREE :blob_buffer;

    return DB_SUCCESS;
}
*/
// 查找订单提醒方式
int CDatabaseMini::GetMsgRemind(uint32 userid, MsgRemindAck &ack)
{
    DEF_ORASET;
    EXEC SQL BEGIN DECLARE SECTION;
        VARCHAR db_link_name[32];
        unsigned int t_userid;
        int retcode;
        SQL_CURSOR cur_msgremind;
        int t_neworder,t_payorder,t_goodscomment,t_returnordr;
    EXEC SQL END DECLARE SECTION;

    SET_INIT_NULL(db_link_name);

    strncpy((char*)db_link_name.arr, m_Connect,32);
    db_link_name.len = (short)strlen(m_Connect);

    t_userid=userid;

    int db_ret, iReconnTimes;
    //uint32 iNum = 0;
    bool bReconn;

    EXEC SQL CONTEXT USE :m_ctx[m_nMyContextid];

start:
    EXEC SQL ALLOCATE :cur_msgremind;
    EXEC SQL AT :db_link_name EXECUTE
    begin
      Mini_User_Pkg.GetMsgRemind(:t_userid,:cur_msgremind,:retcode);
    end;
    END-EXEC;

    db_ret = sqlca.sqlcode;
    if (conn_error(db_ret))
    {
        EXEC SQL CLOSE :cur_msgremind;
        iReconnTimes=0;
        bReconn=ConnectDB();
        while(!bReconn)
        {
            iReconnTimes++;
            sleep(iReconnTimes%10);
            bReconn=ConnectDB();
        }
        goto start;
    }

    if(db_ret < 0 && db_ret != -1405)
    {
        sql_error(sqlca, oraca);
        EXEC SQL CLOSE :cur_msgremind;
        EXEC SQL FREE  :cur_msgremind;
        return DB_ERROR;
    }

    EXEC SQL FETCH :cur_msgremind INTO :t_neworder,:t_payorder,:t_goodscomment,:t_returnordr;
    db_ret = sqlca.sqlcode;
    if (db_ret != 1403 && db_ret >= 0)
    {    
    	ack.set_neworder((REMIND_TYPE)t_neworder);
    	ack.set_payorder((REMIND_TYPE)t_payorder);
    	ack.set_goodscomment((REMIND_TYPE)t_goodscomment);
    	ack.set_returnorder((REMIND_TYPE)t_returnordr);
    }
    else
    {
    	ack.set_neworder(RT_RECEIVE_AND_POPMSG);
    	ack.set_payorder(RT_RECEIVE_AND_POPMSG);
    	ack.set_goodscomment(RT_RECEIVE_AND_POPMSG);
    	ack.set_returnorder(RT_RECEIVE_AND_POPMSG);
    }

	EXEC SQL CLOSE :cur_msgremind;
    EXEC SQL FREE  :cur_msgremind;

    return DB_SUCCESS;
}

// 写入订单提醒方式
int CDatabaseMini::SetMsgRemind(uint32 userid, const MsgRemindAck &ack)
{
    DEF_ORASET;
    EXEC SQL BEGIN DECLARE SECTION;
        VARCHAR db_link_name[32];
        unsigned int t_userid;
        int retcode;
        int t_neworder,t_payorder,t_goodscomment,t_returnordr;
    EXEC SQL END DECLARE SECTION;

    SET_INIT_NULL(db_link_name);

    strncpy((char*)db_link_name.arr, m_Connect,32);
    db_link_name.len = (short)strlen(m_Connect);

    t_userid=userid;
    t_neworder = (int)ack.neworder();
    t_payorder = (int)ack.payorder();
    t_goodscomment = (int)ack.goodscomment();
    t_returnordr = (int)ack.returnorder();

    int db_ret, iReconnTimes;
    //uint32 iNum = 0;
    bool bReconn;

    EXEC SQL CONTEXT USE :m_ctx[m_nMyContextid];

start:
    EXEC SQL AT :db_link_name EXECUTE
    begin
      Mini_User_Pkg.SetMsgRemind(:t_userid,:t_neworder,:t_payorder,:t_goodscomment,:t_returnordr,:retcode);
    end;
    END-EXEC;

    db_ret = sqlca.sqlcode;
    if (conn_error(db_ret))
    {
        iReconnTimes=0;
        bReconn=ConnectDB();
        while(!bReconn)
        {
            iReconnTimes++;
            sleep(iReconnTimes%10);
            bReconn=ConnectDB();
        }
        goto start;
    }

    if(db_ret < 0 && db_ret != -1405)
    {
        sql_error(sqlca, oraca);
        return DB_ERROR;
    }

    return DB_SUCCESS;
}

// 获取最近联系人
int CDatabaseMini::GetRecentContact(const char *pGuid, uint32 starttime, vector<uint32> &arrID)
{
    DEF_ORASET;
    EXEC SQL BEGIN DECLARE SECTION;
        VARCHAR db_link_name[32];
        VARCHAR var_guid[80];
        int retcode;
        SQL_CURSOR cur_recentcontact;
        int t_starttime;
        unsigned int t_toid;
    EXEC SQL END DECLARE SECTION;

    SET_INIT_NULL(db_link_name);
    SET_INIT_NULL(var_guid);

    strncpy((char*)db_link_name.arr, m_Connect,32);
    db_link_name.len = (short)strlen(m_Connect);

    strncpy((char*)var_guid.arr, pGuid,strlen(pGuid));
    var_guid.len = (short)strlen(pGuid);

    int db_ret, iReconnTimes;
    //uint32 iNum = 0;
    bool bReconn;

    EXEC SQL CONTEXT USE :m_ctx[m_nMyContextid];

start:
    EXEC SQL ALLOCATE :cur_recentcontact;
    EXEC SQL AT :db_link_name EXECUTE
    begin
      Mini_User_Pkg.GetRecentContact(:var_guid,:t_starttime,:cur_recentcontact,:retcode);
    end;
    END-EXEC;

    db_ret = sqlca.sqlcode;
    if (conn_error(db_ret))
    {
        EXEC SQL CLOSE :cur_recentcontact;
        iReconnTimes=0;
        bReconn=ConnectDB();
        while(!bReconn)
        {
            iReconnTimes++;
            sleep(iReconnTimes%10);
            bReconn=ConnectDB();
        }
        goto start;
    }

    if(db_ret < 0 && db_ret != -1405)
    {
        sql_error(sqlca, oraca);
        EXEC SQL CLOSE :cur_recentcontact;
        EXEC SQL FREE  :cur_recentcontact;
        return DB_ERROR;
    }

	for(;;)
    {

        EXEC SQL FETCH :cur_recentcontact INTO :t_toid;
        db_ret = sqlca.sqlcode;
        if (db_ret == 1403 )
        {
            break;
        }

        if( db_ret < 0 )
        {
            break;
        }

		arrID.push_back(t_toid);
    }

	 EXEC SQL CLOSE :cur_recentcontact;
     EXEC SQL FREE  :cur_recentcontact;

    return DB_SUCCESS;
}

// 获取商家需要推送的消息记录
int CDatabaseMini::GetMsgNotifyDataOnePerson(uint32 userid, vector<string> &arrUUID)
{
    DEF_ORASET;
    EXEC SQL BEGIN DECLARE SECTION;
        VARCHAR db_link_name[32];
        VARCHAR var_uuid[60];
        int retcode;
        int t_userid;
        SQL_CURSOR cur_recentcontact;
    EXEC SQL END DECLARE SECTION;

    SET_INIT_NULL(db_link_name);
    SET_INIT_NULL(var_uuid);

    strncpy((char*)db_link_name.arr, m_Connect,32);
    db_link_name.len = (short)strlen(m_Connect);

	t_userid = userid;

    int db_ret, iReconnTimes;
    //uint32 iNum = 0;
    bool bReconn;

    EXEC SQL CONTEXT USE :m_ctx[m_nMyContextid];

start:
    EXEC SQL ALLOCATE :cur_recentcontact;
    EXEC SQL AT :db_link_name EXECUTE
    begin
      Mini_User_Pkg.GetMsgNotifyDataOnePerson(:t_userid,:cur_recentcontact,:retcode);
    end;
    END-EXEC;

    db_ret = sqlca.sqlcode;
    if (conn_error(db_ret))
    {
        EXEC SQL CLOSE :cur_recentcontact;
        iReconnTimes=0;
        bReconn=ConnectDB();
        while(!bReconn)
        {
            iReconnTimes++;
            sleep(iReconnTimes%10);
            bReconn=ConnectDB();
        }
        goto start;
    }

    if(db_ret < 0 && db_ret != -1405)
    {
        sql_error(sqlca, oraca);
        EXEC SQL CLOSE :cur_recentcontact;
        EXEC SQL FREE  :cur_recentcontact;
        return DB_ERROR;
    }

	for(;;)
    {
		SET_INIT_NULL(var_uuid);

        EXEC SQL FETCH :cur_recentcontact INTO :var_uuid;
        db_ret = sqlca.sqlcode;
        if (db_ret == 1403 )
        {
            break;
        }

        if( db_ret < 0 )
        {
            break;
        }

		arrUUID.push_back((char*)var_uuid.arr);
    }

	EXEC SQL CLOSE :cur_recentcontact;
    EXEC SQL FREE  :cur_recentcontact;

    return DB_SUCCESS;
}