// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: msgnotifyinner.proto

#ifndef PROTOBUF_msgnotifyinner_2eproto__INCLUDED
#define PROTOBUF_msgnotifyinner_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include "base.pb.h"
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_msgnotifyinner_2eproto();
void protobuf_AssignDesc_msgnotifyinner_2eproto();
void protobuf_ShutdownFile_msgnotifyinner_2eproto();

class KfkNewOrder;
class KfkPayOrder;
class KfkGoodsComment;
class KfkReturnOrder;
class MsgPushInner;

// ===================================================================

class KfkNewOrder : public ::google::protobuf::MessageLite {
 public:
  KfkNewOrder();
  virtual ~KfkNewOrder();

  KfkNewOrder(const KfkNewOrder& from);

  inline KfkNewOrder& operator=(const KfkNewOrder& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const KfkNewOrder& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const KfkNewOrder* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(KfkNewOrder* other);

  // implements Message ----------------------------------------------

  KfkNewOrder* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const KfkNewOrder& from);
  void MergeFrom(const KfkNewOrder& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string memguid = 1;
  inline bool has_memguid() const;
  inline void clear_memguid();
  static const int kMemguidFieldNumber = 1;
  inline const ::std::string& memguid() const;
  inline void set_memguid(const ::std::string& value);
  inline void set_memguid(const char* value);
  inline void set_memguid(const char* value, size_t size);
  inline ::std::string* mutable_memguid();
  inline ::std::string* release_memguid();
  inline void set_allocated_memguid(::std::string* memguid);

  // optional string ogno = 2;
  inline bool has_ogno() const;
  inline void clear_ogno();
  static const int kOgnoFieldNumber = 2;
  inline const ::std::string& ogno() const;
  inline void set_ogno(const ::std::string& value);
  inline void set_ogno(const char* value);
  inline void set_ogno(const char* value, size_t size);
  inline ::std::string* mutable_ogno();
  inline ::std::string* release_ogno();
  inline void set_allocated_ogno(::std::string* ogno);

  // optional string ogseq = 3;
  inline bool has_ogseq() const;
  inline void clear_ogseq();
  static const int kOgseqFieldNumber = 3;
  inline const ::std::string& ogseq() const;
  inline void set_ogseq(const ::std::string& value);
  inline void set_ogseq(const char* value);
  inline void set_ogseq(const char* value, size_t size);
  inline ::std::string* mutable_ogseq();
  inline ::std::string* release_ogseq();
  inline void set_allocated_ogseq(::std::string* ogseq);

  // @@protoc_insertion_point(class_scope:KfkNewOrder)
 private:
  inline void set_has_memguid();
  inline void clear_has_memguid();
  inline void set_has_ogno();
  inline void clear_has_ogno();
  inline void set_has_ogseq();
  inline void clear_has_ogseq();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* memguid_;
  ::std::string* ogno_;
  ::std::string* ogseq_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_msgnotifyinner_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_msgnotifyinner_2eproto();
  #endif
  friend void protobuf_AssignDesc_msgnotifyinner_2eproto();
  friend void protobuf_ShutdownFile_msgnotifyinner_2eproto();

  void InitAsDefaultInstance();
  static KfkNewOrder* default_instance_;
};
// -------------------------------------------------------------------

class KfkPayOrder : public ::google::protobuf::MessageLite {
 public:
  KfkPayOrder();
  virtual ~KfkPayOrder();

  KfkPayOrder(const KfkPayOrder& from);

  inline KfkPayOrder& operator=(const KfkPayOrder& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const KfkPayOrder& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const KfkPayOrder* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(KfkPayOrder* other);

  // implements Message ----------------------------------------------

  KfkPayOrder* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const KfkPayOrder& from);
  void MergeFrom(const KfkPayOrder& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string memguid = 1;
  inline bool has_memguid() const;
  inline void clear_memguid();
  static const int kMemguidFieldNumber = 1;
  inline const ::std::string& memguid() const;
  inline void set_memguid(const ::std::string& value);
  inline void set_memguid(const char* value);
  inline void set_memguid(const char* value, size_t size);
  inline ::std::string* mutable_memguid();
  inline ::std::string* release_memguid();
  inline void set_allocated_memguid(::std::string* memguid);

  // optional string ogno = 2;
  inline bool has_ogno() const;
  inline void clear_ogno();
  static const int kOgnoFieldNumber = 2;
  inline const ::std::string& ogno() const;
  inline void set_ogno(const ::std::string& value);
  inline void set_ogno(const char* value);
  inline void set_ogno(const char* value, size_t size);
  inline ::std::string* mutable_ogno();
  inline ::std::string* release_ogno();
  inline void set_allocated_ogno(::std::string* ogno);

  // optional string ogseq = 3;
  inline bool has_ogseq() const;
  inline void clear_ogseq();
  static const int kOgseqFieldNumber = 3;
  inline const ::std::string& ogseq() const;
  inline void set_ogseq(const ::std::string& value);
  inline void set_ogseq(const char* value);
  inline void set_ogseq(const char* value, size_t size);
  inline ::std::string* mutable_ogseq();
  inline ::std::string* release_ogseq();
  inline void set_allocated_ogseq(::std::string* ogseq);

  // optional string paytype = 4;
  inline bool has_paytype() const;
  inline void clear_paytype();
  static const int kPaytypeFieldNumber = 4;
  inline const ::std::string& paytype() const;
  inline void set_paytype(const ::std::string& value);
  inline void set_paytype(const char* value);
  inline void set_paytype(const char* value, size_t size);
  inline ::std::string* mutable_paytype();
  inline ::std::string* release_paytype();
  inline void set_allocated_paytype(::std::string* paytype);

  // optional string transno = 5;
  inline bool has_transno() const;
  inline void clear_transno();
  static const int kTransnoFieldNumber = 5;
  inline const ::std::string& transno() const;
  inline void set_transno(const ::std::string& value);
  inline void set_transno(const char* value);
  inline void set_transno(const char* value, size_t size);
  inline ::std::string* mutable_transno();
  inline ::std::string* release_transno();
  inline void set_allocated_transno(::std::string* transno);

  // @@protoc_insertion_point(class_scope:KfkPayOrder)
 private:
  inline void set_has_memguid();
  inline void clear_has_memguid();
  inline void set_has_ogno();
  inline void clear_has_ogno();
  inline void set_has_ogseq();
  inline void clear_has_ogseq();
  inline void set_has_paytype();
  inline void clear_has_paytype();
  inline void set_has_transno();
  inline void clear_has_transno();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* memguid_;
  ::std::string* ogno_;
  ::std::string* ogseq_;
  ::std::string* paytype_;
  ::std::string* transno_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_msgnotifyinner_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_msgnotifyinner_2eproto();
  #endif
  friend void protobuf_AssignDesc_msgnotifyinner_2eproto();
  friend void protobuf_ShutdownFile_msgnotifyinner_2eproto();

  void InitAsDefaultInstance();
  static KfkPayOrder* default_instance_;
};
// -------------------------------------------------------------------

class KfkGoodsComment : public ::google::protobuf::MessageLite {
 public:
  KfkGoodsComment();
  virtual ~KfkGoodsComment();

  KfkGoodsComment(const KfkGoodsComment& from);

  inline KfkGoodsComment& operator=(const KfkGoodsComment& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const KfkGoodsComment& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const KfkGoodsComment* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(KfkGoodsComment* other);

  // implements Message ----------------------------------------------

  KfkGoodsComment* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const KfkGoodsComment& from);
  void MergeFrom(const KfkGoodsComment& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string memguid = 1;
  inline bool has_memguid() const;
  inline void clear_memguid();
  static const int kMemguidFieldNumber = 1;
  inline const ::std::string& memguid() const;
  inline void set_memguid(const ::std::string& value);
  inline void set_memguid(const char* value);
  inline void set_memguid(const char* value, size_t size);
  inline ::std::string* mutable_memguid();
  inline ::std::string* release_memguid();
  inline void set_allocated_memguid(::std::string* memguid);

  // optional string ogno = 2;
  inline bool has_ogno() const;
  inline void clear_ogno();
  static const int kOgnoFieldNumber = 2;
  inline const ::std::string& ogno() const;
  inline void set_ogno(const ::std::string& value);
  inline void set_ogno(const char* value);
  inline void set_ogno(const char* value, size_t size);
  inline ::std::string* mutable_ogno();
  inline ::std::string* release_ogno();
  inline void set_allocated_ogno(::std::string* ogno);

  // optional string bugername = 3;
  inline bool has_bugername() const;
  inline void clear_bugername();
  static const int kBugernameFieldNumber = 3;
  inline const ::std::string& bugername() const;
  inline void set_bugername(const ::std::string& value);
  inline void set_bugername(const char* value);
  inline void set_bugername(const char* value, size_t size);
  inline ::std::string* mutable_bugername();
  inline ::std::string* release_bugername();
  inline void set_allocated_bugername(::std::string* bugername);

  // optional double evaluatelevel = 4;
  inline bool has_evaluatelevel() const;
  inline void clear_evaluatelevel();
  static const int kEvaluatelevelFieldNumber = 4;
  inline double evaluatelevel() const;
  inline void set_evaluatelevel(double value);

  // optional string evaluatecontext = 5;
  inline bool has_evaluatecontext() const;
  inline void clear_evaluatecontext();
  static const int kEvaluatecontextFieldNumber = 5;
  inline const ::std::string& evaluatecontext() const;
  inline void set_evaluatecontext(const ::std::string& value);
  inline void set_evaluatecontext(const char* value);
  inline void set_evaluatecontext(const char* value, size_t size);
  inline ::std::string* mutable_evaluatecontext();
  inline ::std::string* release_evaluatecontext();
  inline void set_allocated_evaluatecontext(::std::string* evaluatecontext);

  // optional string skuid = 6;
  inline bool has_skuid() const;
  inline void clear_skuid();
  static const int kSkuidFieldNumber = 6;
  inline const ::std::string& skuid() const;
  inline void set_skuid(const ::std::string& value);
  inline void set_skuid(const char* value);
  inline void set_skuid(const char* value, size_t size);
  inline ::std::string* mutable_skuid();
  inline ::std::string* release_skuid();
  inline void set_allocated_skuid(::std::string* skuid);

  // @@protoc_insertion_point(class_scope:KfkGoodsComment)
 private:
  inline void set_has_memguid();
  inline void clear_has_memguid();
  inline void set_has_ogno();
  inline void clear_has_ogno();
  inline void set_has_bugername();
  inline void clear_has_bugername();
  inline void set_has_evaluatelevel();
  inline void clear_has_evaluatelevel();
  inline void set_has_evaluatecontext();
  inline void clear_has_evaluatecontext();
  inline void set_has_skuid();
  inline void clear_has_skuid();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* memguid_;
  ::std::string* ogno_;
  ::std::string* bugername_;
  double evaluatelevel_;
  ::std::string* evaluatecontext_;
  ::std::string* skuid_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_msgnotifyinner_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_msgnotifyinner_2eproto();
  #endif
  friend void protobuf_AssignDesc_msgnotifyinner_2eproto();
  friend void protobuf_ShutdownFile_msgnotifyinner_2eproto();

  void InitAsDefaultInstance();
  static KfkGoodsComment* default_instance_;
};
// -------------------------------------------------------------------

class KfkReturnOrder : public ::google::protobuf::MessageLite {
 public:
  KfkReturnOrder();
  virtual ~KfkReturnOrder();

  KfkReturnOrder(const KfkReturnOrder& from);

  inline KfkReturnOrder& operator=(const KfkReturnOrder& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const KfkReturnOrder& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const KfkReturnOrder* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(KfkReturnOrder* other);

  // implements Message ----------------------------------------------

  KfkReturnOrder* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const KfkReturnOrder& from);
  void MergeFrom(const KfkReturnOrder& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string memGuid = 1;
  inline bool has_memguid() const;
  inline void clear_memguid();
  static const int kMemGuidFieldNumber = 1;
  inline const ::std::string& memguid() const;
  inline void set_memguid(const ::std::string& value);
  inline void set_memguid(const char* value);
  inline void set_memguid(const char* value, size_t size);
  inline ::std::string* mutable_memguid();
  inline ::std::string* release_memguid();
  inline void set_allocated_memguid(::std::string* memguid);

  // optional string ogNo = 2;
  inline bool has_ogno() const;
  inline void clear_ogno();
  static const int kOgNoFieldNumber = 2;
  inline const ::std::string& ogno() const;
  inline void set_ogno(const ::std::string& value);
  inline void set_ogno(const char* value);
  inline void set_ogno(const char* value, size_t size);
  inline ::std::string* mutable_ogno();
  inline ::std::string* release_ogno();
  inline void set_allocated_ogno(::std::string* ogno);

  // optional string ogSeq = 3;
  inline bool has_ogseq() const;
  inline void clear_ogseq();
  static const int kOgSeqFieldNumber = 3;
  inline const ::std::string& ogseq() const;
  inline void set_ogseq(const ::std::string& value);
  inline void set_ogseq(const char* value);
  inline void set_ogseq(const char* value, size_t size);
  inline ::std::string* mutable_ogseq();
  inline ::std::string* release_ogseq();
  inline void set_allocated_ogseq(::std::string* ogseq);

  // optional string ogsSeq = 4;
  inline bool has_ogsseq() const;
  inline void clear_ogsseq();
  static const int kOgsSeqFieldNumber = 4;
  inline const ::std::string& ogsseq() const;
  inline void set_ogsseq(const ::std::string& value);
  inline void set_ogsseq(const char* value);
  inline void set_ogsseq(const char* value, size_t size);
  inline ::std::string* mutable_ogsseq();
  inline ::std::string* release_ogsseq();
  inline void set_allocated_ogsseq(::std::string* ogsseq);

  // optional string rsSeq = 5;
  inline bool has_rsseq() const;
  inline void clear_rsseq();
  static const int kRsSeqFieldNumber = 5;
  inline const ::std::string& rsseq() const;
  inline void set_rsseq(const ::std::string& value);
  inline void set_rsseq(const char* value);
  inline void set_rsseq(const char* value, size_t size);
  inline ::std::string* mutable_rsseq();
  inline ::std::string* release_rsseq();
  inline void set_allocated_rsseq(::std::string* rsseq);

  // @@protoc_insertion_point(class_scope:KfkReturnOrder)
 private:
  inline void set_has_memguid();
  inline void clear_has_memguid();
  inline void set_has_ogno();
  inline void clear_has_ogno();
  inline void set_has_ogseq();
  inline void clear_has_ogseq();
  inline void set_has_ogsseq();
  inline void clear_has_ogsseq();
  inline void set_has_rsseq();
  inline void clear_has_rsseq();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* memguid_;
  ::std::string* ogno_;
  ::std::string* ogseq_;
  ::std::string* ogsseq_;
  ::std::string* rsseq_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_msgnotifyinner_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_msgnotifyinner_2eproto();
  #endif
  friend void protobuf_AssignDesc_msgnotifyinner_2eproto();
  friend void protobuf_ShutdownFile_msgnotifyinner_2eproto();

  void InitAsDefaultInstance();
  static KfkReturnOrder* default_instance_;
};
// -------------------------------------------------------------------

class MsgPushInner : public ::google::protobuf::MessageLite {
 public:
  MsgPushInner();
  virtual ~MsgPushInner();

  MsgPushInner(const MsgPushInner& from);

  inline MsgPushInner& operator=(const MsgPushInner& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const MsgPushInner& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const MsgPushInner* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(MsgPushInner* other);

  // implements Message ----------------------------------------------

  MsgPushInner* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MsgPushInner& from);
  void MergeFrom(const MsgPushInner& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .EuMsgPush mpType = 1;
  inline bool has_mptype() const;
  inline void clear_mptype();
  static const int kMpTypeFieldNumber = 1;
  inline ::EuMsgPush mptype() const;
  inline void set_mptype(::EuMsgPush value);

  // required bytes mpData = 2;
  inline bool has_mpdata() const;
  inline void clear_mpdata();
  static const int kMpDataFieldNumber = 2;
  inline const ::std::string& mpdata() const;
  inline void set_mpdata(const ::std::string& value);
  inline void set_mpdata(const char* value);
  inline void set_mpdata(const void* value, size_t size);
  inline ::std::string* mutable_mpdata();
  inline ::std::string* release_mpdata();
  inline void set_allocated_mpdata(::std::string* mpdata);

  // @@protoc_insertion_point(class_scope:MsgPushInner)
 private:
  inline void set_has_mptype();
  inline void clear_has_mptype();
  inline void set_has_mpdata();
  inline void clear_has_mpdata();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* mpdata_;
  int mptype_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_msgnotifyinner_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_msgnotifyinner_2eproto();
  #endif
  friend void protobuf_AssignDesc_msgnotifyinner_2eproto();
  friend void protobuf_ShutdownFile_msgnotifyinner_2eproto();

  void InitAsDefaultInstance();
  static MsgPushInner* default_instance_;
};
// ===================================================================


// ===================================================================

// KfkNewOrder

// optional string memguid = 1;
inline bool KfkNewOrder::has_memguid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void KfkNewOrder::set_has_memguid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void KfkNewOrder::clear_has_memguid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void KfkNewOrder::clear_memguid() {
  if (memguid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    memguid_->clear();
  }
  clear_has_memguid();
}
inline const ::std::string& KfkNewOrder::memguid() const {
  // @@protoc_insertion_point(field_get:KfkNewOrder.memguid)
  return *memguid_;
}
inline void KfkNewOrder::set_memguid(const ::std::string& value) {
  set_has_memguid();
  if (memguid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    memguid_ = new ::std::string;
  }
  memguid_->assign(value);
  // @@protoc_insertion_point(field_set:KfkNewOrder.memguid)
}
inline void KfkNewOrder::set_memguid(const char* value) {
  set_has_memguid();
  if (memguid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    memguid_ = new ::std::string;
  }
  memguid_->assign(value);
  // @@protoc_insertion_point(field_set_char:KfkNewOrder.memguid)
}
inline void KfkNewOrder::set_memguid(const char* value, size_t size) {
  set_has_memguid();
  if (memguid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    memguid_ = new ::std::string;
  }
  memguid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:KfkNewOrder.memguid)
}
inline ::std::string* KfkNewOrder::mutable_memguid() {
  set_has_memguid();
  if (memguid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    memguid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:KfkNewOrder.memguid)
  return memguid_;
}
inline ::std::string* KfkNewOrder::release_memguid() {
  clear_has_memguid();
  if (memguid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = memguid_;
    memguid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void KfkNewOrder::set_allocated_memguid(::std::string* memguid) {
  if (memguid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete memguid_;
  }
  if (memguid) {
    set_has_memguid();
    memguid_ = memguid;
  } else {
    clear_has_memguid();
    memguid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:KfkNewOrder.memguid)
}

// optional string ogno = 2;
inline bool KfkNewOrder::has_ogno() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void KfkNewOrder::set_has_ogno() {
  _has_bits_[0] |= 0x00000002u;
}
inline void KfkNewOrder::clear_has_ogno() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void KfkNewOrder::clear_ogno() {
  if (ogno_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ogno_->clear();
  }
  clear_has_ogno();
}
inline const ::std::string& KfkNewOrder::ogno() const {
  // @@protoc_insertion_point(field_get:KfkNewOrder.ogno)
  return *ogno_;
}
inline void KfkNewOrder::set_ogno(const ::std::string& value) {
  set_has_ogno();
  if (ogno_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ogno_ = new ::std::string;
  }
  ogno_->assign(value);
  // @@protoc_insertion_point(field_set:KfkNewOrder.ogno)
}
inline void KfkNewOrder::set_ogno(const char* value) {
  set_has_ogno();
  if (ogno_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ogno_ = new ::std::string;
  }
  ogno_->assign(value);
  // @@protoc_insertion_point(field_set_char:KfkNewOrder.ogno)
}
inline void KfkNewOrder::set_ogno(const char* value, size_t size) {
  set_has_ogno();
  if (ogno_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ogno_ = new ::std::string;
  }
  ogno_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:KfkNewOrder.ogno)
}
inline ::std::string* KfkNewOrder::mutable_ogno() {
  set_has_ogno();
  if (ogno_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ogno_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:KfkNewOrder.ogno)
  return ogno_;
}
inline ::std::string* KfkNewOrder::release_ogno() {
  clear_has_ogno();
  if (ogno_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = ogno_;
    ogno_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void KfkNewOrder::set_allocated_ogno(::std::string* ogno) {
  if (ogno_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete ogno_;
  }
  if (ogno) {
    set_has_ogno();
    ogno_ = ogno;
  } else {
    clear_has_ogno();
    ogno_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:KfkNewOrder.ogno)
}

// optional string ogseq = 3;
inline bool KfkNewOrder::has_ogseq() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void KfkNewOrder::set_has_ogseq() {
  _has_bits_[0] |= 0x00000004u;
}
inline void KfkNewOrder::clear_has_ogseq() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void KfkNewOrder::clear_ogseq() {
  if (ogseq_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ogseq_->clear();
  }
  clear_has_ogseq();
}
inline const ::std::string& KfkNewOrder::ogseq() const {
  // @@protoc_insertion_point(field_get:KfkNewOrder.ogseq)
  return *ogseq_;
}
inline void KfkNewOrder::set_ogseq(const ::std::string& value) {
  set_has_ogseq();
  if (ogseq_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ogseq_ = new ::std::string;
  }
  ogseq_->assign(value);
  // @@protoc_insertion_point(field_set:KfkNewOrder.ogseq)
}
inline void KfkNewOrder::set_ogseq(const char* value) {
  set_has_ogseq();
  if (ogseq_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ogseq_ = new ::std::string;
  }
  ogseq_->assign(value);
  // @@protoc_insertion_point(field_set_char:KfkNewOrder.ogseq)
}
inline void KfkNewOrder::set_ogseq(const char* value, size_t size) {
  set_has_ogseq();
  if (ogseq_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ogseq_ = new ::std::string;
  }
  ogseq_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:KfkNewOrder.ogseq)
}
inline ::std::string* KfkNewOrder::mutable_ogseq() {
  set_has_ogseq();
  if (ogseq_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ogseq_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:KfkNewOrder.ogseq)
  return ogseq_;
}
inline ::std::string* KfkNewOrder::release_ogseq() {
  clear_has_ogseq();
  if (ogseq_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = ogseq_;
    ogseq_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void KfkNewOrder::set_allocated_ogseq(::std::string* ogseq) {
  if (ogseq_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete ogseq_;
  }
  if (ogseq) {
    set_has_ogseq();
    ogseq_ = ogseq;
  } else {
    clear_has_ogseq();
    ogseq_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:KfkNewOrder.ogseq)
}

// -------------------------------------------------------------------

// KfkPayOrder

// optional string memguid = 1;
inline bool KfkPayOrder::has_memguid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void KfkPayOrder::set_has_memguid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void KfkPayOrder::clear_has_memguid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void KfkPayOrder::clear_memguid() {
  if (memguid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    memguid_->clear();
  }
  clear_has_memguid();
}
inline const ::std::string& KfkPayOrder::memguid() const {
  // @@protoc_insertion_point(field_get:KfkPayOrder.memguid)
  return *memguid_;
}
inline void KfkPayOrder::set_memguid(const ::std::string& value) {
  set_has_memguid();
  if (memguid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    memguid_ = new ::std::string;
  }
  memguid_->assign(value);
  // @@protoc_insertion_point(field_set:KfkPayOrder.memguid)
}
inline void KfkPayOrder::set_memguid(const char* value) {
  set_has_memguid();
  if (memguid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    memguid_ = new ::std::string;
  }
  memguid_->assign(value);
  // @@protoc_insertion_point(field_set_char:KfkPayOrder.memguid)
}
inline void KfkPayOrder::set_memguid(const char* value, size_t size) {
  set_has_memguid();
  if (memguid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    memguid_ = new ::std::string;
  }
  memguid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:KfkPayOrder.memguid)
}
inline ::std::string* KfkPayOrder::mutable_memguid() {
  set_has_memguid();
  if (memguid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    memguid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:KfkPayOrder.memguid)
  return memguid_;
}
inline ::std::string* KfkPayOrder::release_memguid() {
  clear_has_memguid();
  if (memguid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = memguid_;
    memguid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void KfkPayOrder::set_allocated_memguid(::std::string* memguid) {
  if (memguid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete memguid_;
  }
  if (memguid) {
    set_has_memguid();
    memguid_ = memguid;
  } else {
    clear_has_memguid();
    memguid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:KfkPayOrder.memguid)
}

// optional string ogno = 2;
inline bool KfkPayOrder::has_ogno() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void KfkPayOrder::set_has_ogno() {
  _has_bits_[0] |= 0x00000002u;
}
inline void KfkPayOrder::clear_has_ogno() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void KfkPayOrder::clear_ogno() {
  if (ogno_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ogno_->clear();
  }
  clear_has_ogno();
}
inline const ::std::string& KfkPayOrder::ogno() const {
  // @@protoc_insertion_point(field_get:KfkPayOrder.ogno)
  return *ogno_;
}
inline void KfkPayOrder::set_ogno(const ::std::string& value) {
  set_has_ogno();
  if (ogno_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ogno_ = new ::std::string;
  }
  ogno_->assign(value);
  // @@protoc_insertion_point(field_set:KfkPayOrder.ogno)
}
inline void KfkPayOrder::set_ogno(const char* value) {
  set_has_ogno();
  if (ogno_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ogno_ = new ::std::string;
  }
  ogno_->assign(value);
  // @@protoc_insertion_point(field_set_char:KfkPayOrder.ogno)
}
inline void KfkPayOrder::set_ogno(const char* value, size_t size) {
  set_has_ogno();
  if (ogno_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ogno_ = new ::std::string;
  }
  ogno_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:KfkPayOrder.ogno)
}
inline ::std::string* KfkPayOrder::mutable_ogno() {
  set_has_ogno();
  if (ogno_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ogno_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:KfkPayOrder.ogno)
  return ogno_;
}
inline ::std::string* KfkPayOrder::release_ogno() {
  clear_has_ogno();
  if (ogno_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = ogno_;
    ogno_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void KfkPayOrder::set_allocated_ogno(::std::string* ogno) {
  if (ogno_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete ogno_;
  }
  if (ogno) {
    set_has_ogno();
    ogno_ = ogno;
  } else {
    clear_has_ogno();
    ogno_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:KfkPayOrder.ogno)
}

// optional string ogseq = 3;
inline bool KfkPayOrder::has_ogseq() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void KfkPayOrder::set_has_ogseq() {
  _has_bits_[0] |= 0x00000004u;
}
inline void KfkPayOrder::clear_has_ogseq() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void KfkPayOrder::clear_ogseq() {
  if (ogseq_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ogseq_->clear();
  }
  clear_has_ogseq();
}
inline const ::std::string& KfkPayOrder::ogseq() const {
  // @@protoc_insertion_point(field_get:KfkPayOrder.ogseq)
  return *ogseq_;
}
inline void KfkPayOrder::set_ogseq(const ::std::string& value) {
  set_has_ogseq();
  if (ogseq_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ogseq_ = new ::std::string;
  }
  ogseq_->assign(value);
  // @@protoc_insertion_point(field_set:KfkPayOrder.ogseq)
}
inline void KfkPayOrder::set_ogseq(const char* value) {
  set_has_ogseq();
  if (ogseq_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ogseq_ = new ::std::string;
  }
  ogseq_->assign(value);
  // @@protoc_insertion_point(field_set_char:KfkPayOrder.ogseq)
}
inline void KfkPayOrder::set_ogseq(const char* value, size_t size) {
  set_has_ogseq();
  if (ogseq_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ogseq_ = new ::std::string;
  }
  ogseq_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:KfkPayOrder.ogseq)
}
inline ::std::string* KfkPayOrder::mutable_ogseq() {
  set_has_ogseq();
  if (ogseq_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ogseq_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:KfkPayOrder.ogseq)
  return ogseq_;
}
inline ::std::string* KfkPayOrder::release_ogseq() {
  clear_has_ogseq();
  if (ogseq_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = ogseq_;
    ogseq_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void KfkPayOrder::set_allocated_ogseq(::std::string* ogseq) {
  if (ogseq_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete ogseq_;
  }
  if (ogseq) {
    set_has_ogseq();
    ogseq_ = ogseq;
  } else {
    clear_has_ogseq();
    ogseq_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:KfkPayOrder.ogseq)
}

// optional string paytype = 4;
inline bool KfkPayOrder::has_paytype() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void KfkPayOrder::set_has_paytype() {
  _has_bits_[0] |= 0x00000008u;
}
inline void KfkPayOrder::clear_has_paytype() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void KfkPayOrder::clear_paytype() {
  if (paytype_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    paytype_->clear();
  }
  clear_has_paytype();
}
inline const ::std::string& KfkPayOrder::paytype() const {
  // @@protoc_insertion_point(field_get:KfkPayOrder.paytype)
  return *paytype_;
}
inline void KfkPayOrder::set_paytype(const ::std::string& value) {
  set_has_paytype();
  if (paytype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    paytype_ = new ::std::string;
  }
  paytype_->assign(value);
  // @@protoc_insertion_point(field_set:KfkPayOrder.paytype)
}
inline void KfkPayOrder::set_paytype(const char* value) {
  set_has_paytype();
  if (paytype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    paytype_ = new ::std::string;
  }
  paytype_->assign(value);
  // @@protoc_insertion_point(field_set_char:KfkPayOrder.paytype)
}
inline void KfkPayOrder::set_paytype(const char* value, size_t size) {
  set_has_paytype();
  if (paytype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    paytype_ = new ::std::string;
  }
  paytype_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:KfkPayOrder.paytype)
}
inline ::std::string* KfkPayOrder::mutable_paytype() {
  set_has_paytype();
  if (paytype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    paytype_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:KfkPayOrder.paytype)
  return paytype_;
}
inline ::std::string* KfkPayOrder::release_paytype() {
  clear_has_paytype();
  if (paytype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = paytype_;
    paytype_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void KfkPayOrder::set_allocated_paytype(::std::string* paytype) {
  if (paytype_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete paytype_;
  }
  if (paytype) {
    set_has_paytype();
    paytype_ = paytype;
  } else {
    clear_has_paytype();
    paytype_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:KfkPayOrder.paytype)
}

// optional string transno = 5;
inline bool KfkPayOrder::has_transno() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void KfkPayOrder::set_has_transno() {
  _has_bits_[0] |= 0x00000010u;
}
inline void KfkPayOrder::clear_has_transno() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void KfkPayOrder::clear_transno() {
  if (transno_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    transno_->clear();
  }
  clear_has_transno();
}
inline const ::std::string& KfkPayOrder::transno() const {
  // @@protoc_insertion_point(field_get:KfkPayOrder.transno)
  return *transno_;
}
inline void KfkPayOrder::set_transno(const ::std::string& value) {
  set_has_transno();
  if (transno_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    transno_ = new ::std::string;
  }
  transno_->assign(value);
  // @@protoc_insertion_point(field_set:KfkPayOrder.transno)
}
inline void KfkPayOrder::set_transno(const char* value) {
  set_has_transno();
  if (transno_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    transno_ = new ::std::string;
  }
  transno_->assign(value);
  // @@protoc_insertion_point(field_set_char:KfkPayOrder.transno)
}
inline void KfkPayOrder::set_transno(const char* value, size_t size) {
  set_has_transno();
  if (transno_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    transno_ = new ::std::string;
  }
  transno_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:KfkPayOrder.transno)
}
inline ::std::string* KfkPayOrder::mutable_transno() {
  set_has_transno();
  if (transno_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    transno_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:KfkPayOrder.transno)
  return transno_;
}
inline ::std::string* KfkPayOrder::release_transno() {
  clear_has_transno();
  if (transno_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = transno_;
    transno_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void KfkPayOrder::set_allocated_transno(::std::string* transno) {
  if (transno_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete transno_;
  }
  if (transno) {
    set_has_transno();
    transno_ = transno;
  } else {
    clear_has_transno();
    transno_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:KfkPayOrder.transno)
}

// -------------------------------------------------------------------

// KfkGoodsComment

// optional string memguid = 1;
inline bool KfkGoodsComment::has_memguid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void KfkGoodsComment::set_has_memguid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void KfkGoodsComment::clear_has_memguid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void KfkGoodsComment::clear_memguid() {
  if (memguid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    memguid_->clear();
  }
  clear_has_memguid();
}
inline const ::std::string& KfkGoodsComment::memguid() const {
  // @@protoc_insertion_point(field_get:KfkGoodsComment.memguid)
  return *memguid_;
}
inline void KfkGoodsComment::set_memguid(const ::std::string& value) {
  set_has_memguid();
  if (memguid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    memguid_ = new ::std::string;
  }
  memguid_->assign(value);
  // @@protoc_insertion_point(field_set:KfkGoodsComment.memguid)
}
inline void KfkGoodsComment::set_memguid(const char* value) {
  set_has_memguid();
  if (memguid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    memguid_ = new ::std::string;
  }
  memguid_->assign(value);
  // @@protoc_insertion_point(field_set_char:KfkGoodsComment.memguid)
}
inline void KfkGoodsComment::set_memguid(const char* value, size_t size) {
  set_has_memguid();
  if (memguid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    memguid_ = new ::std::string;
  }
  memguid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:KfkGoodsComment.memguid)
}
inline ::std::string* KfkGoodsComment::mutable_memguid() {
  set_has_memguid();
  if (memguid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    memguid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:KfkGoodsComment.memguid)
  return memguid_;
}
inline ::std::string* KfkGoodsComment::release_memguid() {
  clear_has_memguid();
  if (memguid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = memguid_;
    memguid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void KfkGoodsComment::set_allocated_memguid(::std::string* memguid) {
  if (memguid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete memguid_;
  }
  if (memguid) {
    set_has_memguid();
    memguid_ = memguid;
  } else {
    clear_has_memguid();
    memguid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:KfkGoodsComment.memguid)
}

// optional string ogno = 2;
inline bool KfkGoodsComment::has_ogno() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void KfkGoodsComment::set_has_ogno() {
  _has_bits_[0] |= 0x00000002u;
}
inline void KfkGoodsComment::clear_has_ogno() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void KfkGoodsComment::clear_ogno() {
  if (ogno_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ogno_->clear();
  }
  clear_has_ogno();
}
inline const ::std::string& KfkGoodsComment::ogno() const {
  // @@protoc_insertion_point(field_get:KfkGoodsComment.ogno)
  return *ogno_;
}
inline void KfkGoodsComment::set_ogno(const ::std::string& value) {
  set_has_ogno();
  if (ogno_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ogno_ = new ::std::string;
  }
  ogno_->assign(value);
  // @@protoc_insertion_point(field_set:KfkGoodsComment.ogno)
}
inline void KfkGoodsComment::set_ogno(const char* value) {
  set_has_ogno();
  if (ogno_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ogno_ = new ::std::string;
  }
  ogno_->assign(value);
  // @@protoc_insertion_point(field_set_char:KfkGoodsComment.ogno)
}
inline void KfkGoodsComment::set_ogno(const char* value, size_t size) {
  set_has_ogno();
  if (ogno_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ogno_ = new ::std::string;
  }
  ogno_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:KfkGoodsComment.ogno)
}
inline ::std::string* KfkGoodsComment::mutable_ogno() {
  set_has_ogno();
  if (ogno_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ogno_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:KfkGoodsComment.ogno)
  return ogno_;
}
inline ::std::string* KfkGoodsComment::release_ogno() {
  clear_has_ogno();
  if (ogno_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = ogno_;
    ogno_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void KfkGoodsComment::set_allocated_ogno(::std::string* ogno) {
  if (ogno_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete ogno_;
  }
  if (ogno) {
    set_has_ogno();
    ogno_ = ogno;
  } else {
    clear_has_ogno();
    ogno_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:KfkGoodsComment.ogno)
}

// optional string bugername = 3;
inline bool KfkGoodsComment::has_bugername() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void KfkGoodsComment::set_has_bugername() {
  _has_bits_[0] |= 0x00000004u;
}
inline void KfkGoodsComment::clear_has_bugername() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void KfkGoodsComment::clear_bugername() {
  if (bugername_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bugername_->clear();
  }
  clear_has_bugername();
}
inline const ::std::string& KfkGoodsComment::bugername() const {
  // @@protoc_insertion_point(field_get:KfkGoodsComment.bugername)
  return *bugername_;
}
inline void KfkGoodsComment::set_bugername(const ::std::string& value) {
  set_has_bugername();
  if (bugername_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bugername_ = new ::std::string;
  }
  bugername_->assign(value);
  // @@protoc_insertion_point(field_set:KfkGoodsComment.bugername)
}
inline void KfkGoodsComment::set_bugername(const char* value) {
  set_has_bugername();
  if (bugername_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bugername_ = new ::std::string;
  }
  bugername_->assign(value);
  // @@protoc_insertion_point(field_set_char:KfkGoodsComment.bugername)
}
inline void KfkGoodsComment::set_bugername(const char* value, size_t size) {
  set_has_bugername();
  if (bugername_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bugername_ = new ::std::string;
  }
  bugername_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:KfkGoodsComment.bugername)
}
inline ::std::string* KfkGoodsComment::mutable_bugername() {
  set_has_bugername();
  if (bugername_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bugername_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:KfkGoodsComment.bugername)
  return bugername_;
}
inline ::std::string* KfkGoodsComment::release_bugername() {
  clear_has_bugername();
  if (bugername_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = bugername_;
    bugername_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void KfkGoodsComment::set_allocated_bugername(::std::string* bugername) {
  if (bugername_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete bugername_;
  }
  if (bugername) {
    set_has_bugername();
    bugername_ = bugername;
  } else {
    clear_has_bugername();
    bugername_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:KfkGoodsComment.bugername)
}

// optional double evaluatelevel = 4;
inline bool KfkGoodsComment::has_evaluatelevel() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void KfkGoodsComment::set_has_evaluatelevel() {
  _has_bits_[0] |= 0x00000008u;
}
inline void KfkGoodsComment::clear_has_evaluatelevel() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void KfkGoodsComment::clear_evaluatelevel() {
  evaluatelevel_ = 0;
  clear_has_evaluatelevel();
}
inline double KfkGoodsComment::evaluatelevel() const {
  // @@protoc_insertion_point(field_get:KfkGoodsComment.evaluatelevel)
  return evaluatelevel_;
}
inline void KfkGoodsComment::set_evaluatelevel(double value) {
  set_has_evaluatelevel();
  evaluatelevel_ = value;
  // @@protoc_insertion_point(field_set:KfkGoodsComment.evaluatelevel)
}

// optional string evaluatecontext = 5;
inline bool KfkGoodsComment::has_evaluatecontext() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void KfkGoodsComment::set_has_evaluatecontext() {
  _has_bits_[0] |= 0x00000010u;
}
inline void KfkGoodsComment::clear_has_evaluatecontext() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void KfkGoodsComment::clear_evaluatecontext() {
  if (evaluatecontext_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    evaluatecontext_->clear();
  }
  clear_has_evaluatecontext();
}
inline const ::std::string& KfkGoodsComment::evaluatecontext() const {
  // @@protoc_insertion_point(field_get:KfkGoodsComment.evaluatecontext)
  return *evaluatecontext_;
}
inline void KfkGoodsComment::set_evaluatecontext(const ::std::string& value) {
  set_has_evaluatecontext();
  if (evaluatecontext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    evaluatecontext_ = new ::std::string;
  }
  evaluatecontext_->assign(value);
  // @@protoc_insertion_point(field_set:KfkGoodsComment.evaluatecontext)
}
inline void KfkGoodsComment::set_evaluatecontext(const char* value) {
  set_has_evaluatecontext();
  if (evaluatecontext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    evaluatecontext_ = new ::std::string;
  }
  evaluatecontext_->assign(value);
  // @@protoc_insertion_point(field_set_char:KfkGoodsComment.evaluatecontext)
}
inline void KfkGoodsComment::set_evaluatecontext(const char* value, size_t size) {
  set_has_evaluatecontext();
  if (evaluatecontext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    evaluatecontext_ = new ::std::string;
  }
  evaluatecontext_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:KfkGoodsComment.evaluatecontext)
}
inline ::std::string* KfkGoodsComment::mutable_evaluatecontext() {
  set_has_evaluatecontext();
  if (evaluatecontext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    evaluatecontext_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:KfkGoodsComment.evaluatecontext)
  return evaluatecontext_;
}
inline ::std::string* KfkGoodsComment::release_evaluatecontext() {
  clear_has_evaluatecontext();
  if (evaluatecontext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = evaluatecontext_;
    evaluatecontext_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void KfkGoodsComment::set_allocated_evaluatecontext(::std::string* evaluatecontext) {
  if (evaluatecontext_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete evaluatecontext_;
  }
  if (evaluatecontext) {
    set_has_evaluatecontext();
    evaluatecontext_ = evaluatecontext;
  } else {
    clear_has_evaluatecontext();
    evaluatecontext_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:KfkGoodsComment.evaluatecontext)
}

// optional string skuid = 6;
inline bool KfkGoodsComment::has_skuid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void KfkGoodsComment::set_has_skuid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void KfkGoodsComment::clear_has_skuid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void KfkGoodsComment::clear_skuid() {
  if (skuid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    skuid_->clear();
  }
  clear_has_skuid();
}
inline const ::std::string& KfkGoodsComment::skuid() const {
  // @@protoc_insertion_point(field_get:KfkGoodsComment.skuid)
  return *skuid_;
}
inline void KfkGoodsComment::set_skuid(const ::std::string& value) {
  set_has_skuid();
  if (skuid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    skuid_ = new ::std::string;
  }
  skuid_->assign(value);
  // @@protoc_insertion_point(field_set:KfkGoodsComment.skuid)
}
inline void KfkGoodsComment::set_skuid(const char* value) {
  set_has_skuid();
  if (skuid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    skuid_ = new ::std::string;
  }
  skuid_->assign(value);
  // @@protoc_insertion_point(field_set_char:KfkGoodsComment.skuid)
}
inline void KfkGoodsComment::set_skuid(const char* value, size_t size) {
  set_has_skuid();
  if (skuid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    skuid_ = new ::std::string;
  }
  skuid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:KfkGoodsComment.skuid)
}
inline ::std::string* KfkGoodsComment::mutable_skuid() {
  set_has_skuid();
  if (skuid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    skuid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:KfkGoodsComment.skuid)
  return skuid_;
}
inline ::std::string* KfkGoodsComment::release_skuid() {
  clear_has_skuid();
  if (skuid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = skuid_;
    skuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void KfkGoodsComment::set_allocated_skuid(::std::string* skuid) {
  if (skuid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete skuid_;
  }
  if (skuid) {
    set_has_skuid();
    skuid_ = skuid;
  } else {
    clear_has_skuid();
    skuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:KfkGoodsComment.skuid)
}

// -------------------------------------------------------------------

// KfkReturnOrder

// optional string memGuid = 1;
inline bool KfkReturnOrder::has_memguid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void KfkReturnOrder::set_has_memguid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void KfkReturnOrder::clear_has_memguid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void KfkReturnOrder::clear_memguid() {
  if (memguid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    memguid_->clear();
  }
  clear_has_memguid();
}
inline const ::std::string& KfkReturnOrder::memguid() const {
  // @@protoc_insertion_point(field_get:KfkReturnOrder.memGuid)
  return *memguid_;
}
inline void KfkReturnOrder::set_memguid(const ::std::string& value) {
  set_has_memguid();
  if (memguid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    memguid_ = new ::std::string;
  }
  memguid_->assign(value);
  // @@protoc_insertion_point(field_set:KfkReturnOrder.memGuid)
}
inline void KfkReturnOrder::set_memguid(const char* value) {
  set_has_memguid();
  if (memguid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    memguid_ = new ::std::string;
  }
  memguid_->assign(value);
  // @@protoc_insertion_point(field_set_char:KfkReturnOrder.memGuid)
}
inline void KfkReturnOrder::set_memguid(const char* value, size_t size) {
  set_has_memguid();
  if (memguid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    memguid_ = new ::std::string;
  }
  memguid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:KfkReturnOrder.memGuid)
}
inline ::std::string* KfkReturnOrder::mutable_memguid() {
  set_has_memguid();
  if (memguid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    memguid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:KfkReturnOrder.memGuid)
  return memguid_;
}
inline ::std::string* KfkReturnOrder::release_memguid() {
  clear_has_memguid();
  if (memguid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = memguid_;
    memguid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void KfkReturnOrder::set_allocated_memguid(::std::string* memguid) {
  if (memguid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete memguid_;
  }
  if (memguid) {
    set_has_memguid();
    memguid_ = memguid;
  } else {
    clear_has_memguid();
    memguid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:KfkReturnOrder.memGuid)
}

// optional string ogNo = 2;
inline bool KfkReturnOrder::has_ogno() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void KfkReturnOrder::set_has_ogno() {
  _has_bits_[0] |= 0x00000002u;
}
inline void KfkReturnOrder::clear_has_ogno() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void KfkReturnOrder::clear_ogno() {
  if (ogno_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ogno_->clear();
  }
  clear_has_ogno();
}
inline const ::std::string& KfkReturnOrder::ogno() const {
  // @@protoc_insertion_point(field_get:KfkReturnOrder.ogNo)
  return *ogno_;
}
inline void KfkReturnOrder::set_ogno(const ::std::string& value) {
  set_has_ogno();
  if (ogno_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ogno_ = new ::std::string;
  }
  ogno_->assign(value);
  // @@protoc_insertion_point(field_set:KfkReturnOrder.ogNo)
}
inline void KfkReturnOrder::set_ogno(const char* value) {
  set_has_ogno();
  if (ogno_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ogno_ = new ::std::string;
  }
  ogno_->assign(value);
  // @@protoc_insertion_point(field_set_char:KfkReturnOrder.ogNo)
}
inline void KfkReturnOrder::set_ogno(const char* value, size_t size) {
  set_has_ogno();
  if (ogno_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ogno_ = new ::std::string;
  }
  ogno_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:KfkReturnOrder.ogNo)
}
inline ::std::string* KfkReturnOrder::mutable_ogno() {
  set_has_ogno();
  if (ogno_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ogno_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:KfkReturnOrder.ogNo)
  return ogno_;
}
inline ::std::string* KfkReturnOrder::release_ogno() {
  clear_has_ogno();
  if (ogno_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = ogno_;
    ogno_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void KfkReturnOrder::set_allocated_ogno(::std::string* ogno) {
  if (ogno_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete ogno_;
  }
  if (ogno) {
    set_has_ogno();
    ogno_ = ogno;
  } else {
    clear_has_ogno();
    ogno_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:KfkReturnOrder.ogNo)
}

// optional string ogSeq = 3;
inline bool KfkReturnOrder::has_ogseq() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void KfkReturnOrder::set_has_ogseq() {
  _has_bits_[0] |= 0x00000004u;
}
inline void KfkReturnOrder::clear_has_ogseq() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void KfkReturnOrder::clear_ogseq() {
  if (ogseq_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ogseq_->clear();
  }
  clear_has_ogseq();
}
inline const ::std::string& KfkReturnOrder::ogseq() const {
  // @@protoc_insertion_point(field_get:KfkReturnOrder.ogSeq)
  return *ogseq_;
}
inline void KfkReturnOrder::set_ogseq(const ::std::string& value) {
  set_has_ogseq();
  if (ogseq_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ogseq_ = new ::std::string;
  }
  ogseq_->assign(value);
  // @@protoc_insertion_point(field_set:KfkReturnOrder.ogSeq)
}
inline void KfkReturnOrder::set_ogseq(const char* value) {
  set_has_ogseq();
  if (ogseq_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ogseq_ = new ::std::string;
  }
  ogseq_->assign(value);
  // @@protoc_insertion_point(field_set_char:KfkReturnOrder.ogSeq)
}
inline void KfkReturnOrder::set_ogseq(const char* value, size_t size) {
  set_has_ogseq();
  if (ogseq_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ogseq_ = new ::std::string;
  }
  ogseq_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:KfkReturnOrder.ogSeq)
}
inline ::std::string* KfkReturnOrder::mutable_ogseq() {
  set_has_ogseq();
  if (ogseq_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ogseq_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:KfkReturnOrder.ogSeq)
  return ogseq_;
}
inline ::std::string* KfkReturnOrder::release_ogseq() {
  clear_has_ogseq();
  if (ogseq_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = ogseq_;
    ogseq_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void KfkReturnOrder::set_allocated_ogseq(::std::string* ogseq) {
  if (ogseq_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete ogseq_;
  }
  if (ogseq) {
    set_has_ogseq();
    ogseq_ = ogseq;
  } else {
    clear_has_ogseq();
    ogseq_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:KfkReturnOrder.ogSeq)
}

// optional string ogsSeq = 4;
inline bool KfkReturnOrder::has_ogsseq() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void KfkReturnOrder::set_has_ogsseq() {
  _has_bits_[0] |= 0x00000008u;
}
inline void KfkReturnOrder::clear_has_ogsseq() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void KfkReturnOrder::clear_ogsseq() {
  if (ogsseq_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ogsseq_->clear();
  }
  clear_has_ogsseq();
}
inline const ::std::string& KfkReturnOrder::ogsseq() const {
  // @@protoc_insertion_point(field_get:KfkReturnOrder.ogsSeq)
  return *ogsseq_;
}
inline void KfkReturnOrder::set_ogsseq(const ::std::string& value) {
  set_has_ogsseq();
  if (ogsseq_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ogsseq_ = new ::std::string;
  }
  ogsseq_->assign(value);
  // @@protoc_insertion_point(field_set:KfkReturnOrder.ogsSeq)
}
inline void KfkReturnOrder::set_ogsseq(const char* value) {
  set_has_ogsseq();
  if (ogsseq_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ogsseq_ = new ::std::string;
  }
  ogsseq_->assign(value);
  // @@protoc_insertion_point(field_set_char:KfkReturnOrder.ogsSeq)
}
inline void KfkReturnOrder::set_ogsseq(const char* value, size_t size) {
  set_has_ogsseq();
  if (ogsseq_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ogsseq_ = new ::std::string;
  }
  ogsseq_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:KfkReturnOrder.ogsSeq)
}
inline ::std::string* KfkReturnOrder::mutable_ogsseq() {
  set_has_ogsseq();
  if (ogsseq_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ogsseq_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:KfkReturnOrder.ogsSeq)
  return ogsseq_;
}
inline ::std::string* KfkReturnOrder::release_ogsseq() {
  clear_has_ogsseq();
  if (ogsseq_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = ogsseq_;
    ogsseq_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void KfkReturnOrder::set_allocated_ogsseq(::std::string* ogsseq) {
  if (ogsseq_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete ogsseq_;
  }
  if (ogsseq) {
    set_has_ogsseq();
    ogsseq_ = ogsseq;
  } else {
    clear_has_ogsseq();
    ogsseq_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:KfkReturnOrder.ogsSeq)
}

// optional string rsSeq = 5;
inline bool KfkReturnOrder::has_rsseq() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void KfkReturnOrder::set_has_rsseq() {
  _has_bits_[0] |= 0x00000010u;
}
inline void KfkReturnOrder::clear_has_rsseq() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void KfkReturnOrder::clear_rsseq() {
  if (rsseq_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rsseq_->clear();
  }
  clear_has_rsseq();
}
inline const ::std::string& KfkReturnOrder::rsseq() const {
  // @@protoc_insertion_point(field_get:KfkReturnOrder.rsSeq)
  return *rsseq_;
}
inline void KfkReturnOrder::set_rsseq(const ::std::string& value) {
  set_has_rsseq();
  if (rsseq_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rsseq_ = new ::std::string;
  }
  rsseq_->assign(value);
  // @@protoc_insertion_point(field_set:KfkReturnOrder.rsSeq)
}
inline void KfkReturnOrder::set_rsseq(const char* value) {
  set_has_rsseq();
  if (rsseq_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rsseq_ = new ::std::string;
  }
  rsseq_->assign(value);
  // @@protoc_insertion_point(field_set_char:KfkReturnOrder.rsSeq)
}
inline void KfkReturnOrder::set_rsseq(const char* value, size_t size) {
  set_has_rsseq();
  if (rsseq_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rsseq_ = new ::std::string;
  }
  rsseq_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:KfkReturnOrder.rsSeq)
}
inline ::std::string* KfkReturnOrder::mutable_rsseq() {
  set_has_rsseq();
  if (rsseq_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rsseq_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:KfkReturnOrder.rsSeq)
  return rsseq_;
}
inline ::std::string* KfkReturnOrder::release_rsseq() {
  clear_has_rsseq();
  if (rsseq_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = rsseq_;
    rsseq_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void KfkReturnOrder::set_allocated_rsseq(::std::string* rsseq) {
  if (rsseq_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete rsseq_;
  }
  if (rsseq) {
    set_has_rsseq();
    rsseq_ = rsseq;
  } else {
    clear_has_rsseq();
    rsseq_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:KfkReturnOrder.rsSeq)
}

// -------------------------------------------------------------------

// MsgPushInner

// required .EuMsgPush mpType = 1;
inline bool MsgPushInner::has_mptype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MsgPushInner::set_has_mptype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MsgPushInner::clear_has_mptype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MsgPushInner::clear_mptype() {
  mptype_ = 1;
  clear_has_mptype();
}
inline ::EuMsgPush MsgPushInner::mptype() const {
  // @@protoc_insertion_point(field_get:MsgPushInner.mpType)
  return static_cast< ::EuMsgPush >(mptype_);
}
inline void MsgPushInner::set_mptype(::EuMsgPush value) {
  assert(::EuMsgPush_IsValid(value));
  set_has_mptype();
  mptype_ = value;
  // @@protoc_insertion_point(field_set:MsgPushInner.mpType)
}

// required bytes mpData = 2;
inline bool MsgPushInner::has_mpdata() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MsgPushInner::set_has_mpdata() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MsgPushInner::clear_has_mpdata() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MsgPushInner::clear_mpdata() {
  if (mpdata_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mpdata_->clear();
  }
  clear_has_mpdata();
}
inline const ::std::string& MsgPushInner::mpdata() const {
  // @@protoc_insertion_point(field_get:MsgPushInner.mpData)
  return *mpdata_;
}
inline void MsgPushInner::set_mpdata(const ::std::string& value) {
  set_has_mpdata();
  if (mpdata_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mpdata_ = new ::std::string;
  }
  mpdata_->assign(value);
  // @@protoc_insertion_point(field_set:MsgPushInner.mpData)
}
inline void MsgPushInner::set_mpdata(const char* value) {
  set_has_mpdata();
  if (mpdata_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mpdata_ = new ::std::string;
  }
  mpdata_->assign(value);
  // @@protoc_insertion_point(field_set_char:MsgPushInner.mpData)
}
inline void MsgPushInner::set_mpdata(const void* value, size_t size) {
  set_has_mpdata();
  if (mpdata_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mpdata_ = new ::std::string;
  }
  mpdata_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:MsgPushInner.mpData)
}
inline ::std::string* MsgPushInner::mutable_mpdata() {
  set_has_mpdata();
  if (mpdata_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mpdata_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:MsgPushInner.mpData)
  return mpdata_;
}
inline ::std::string* MsgPushInner::release_mpdata() {
  clear_has_mpdata();
  if (mpdata_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = mpdata_;
    mpdata_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MsgPushInner::set_allocated_mpdata(::std::string* mpdata) {
  if (mpdata_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete mpdata_;
  }
  if (mpdata) {
    set_has_mpdata();
    mpdata_ = mpdata;
  } else {
    clear_has_mpdata();
    mpdata_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:MsgPushInner.mpData)
}


// @@protoc_insertion_point(namespace_scope)

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_msgnotifyinner_2eproto__INCLUDED
